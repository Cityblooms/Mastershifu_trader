<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Bekenet-style AI Signals — Standalone (Dark)</title>
<style>
:root{
  --bg:#071426; --panel:#0b1524; --muted:#93a5bf; --accent:#60a5fa; --good:#22c55e; --bad:#ef4444;
  --card: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
  --radius:12px;
}
html,body{height:100%;margin:0;background:linear-gradient(180deg,#021028 0%,#04142a 100%);font-family:Inter,system-ui,Roboto,Arial;color:#e6eef8}
.wrap{max-width:1150px;margin:12px auto;padding:12px}
.header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:12px}
.hleft{display:flex;flex-direction:column}
.hleft h1{margin:0;font-size:18px}
.controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
.card{background:var(--card);padding:12px;border-radius:var(--radius);box-shadow:0 8px 24px rgba(2,6,23,0.6);border:1px solid rgba(255,255,255,0.03)}
.row{display:flex;gap:12px}
.col{display:flex;flex-direction:column;gap:12px}
.param-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:8px}
.small{font-size:12px;color:var(--muted)}
.muted{color:var(--muted)}
.btn{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px;border-radius:8px;color:#e6eef8;cursor:pointer}
.canvasWrap{height:120px;border-radius:8px;overflow:hidden;background:linear-gradient(180deg,#04172b,#031827)}
.canvas{width:100%;height:100%;display:block}
.pairsList{display:flex;flex-direction:column;gap:8px}
.pairRow{display:flex;justify-content:space-between;align-items:center;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.02)}
.badge{padding:6px 10px;border-radius:999px;font-weight:700}
.buy{background:rgba(34,197,94,0.12);color:var(--good)}
.sell{background:rgba(239,68,68,0.12);color:var(--bad)}
.wait{background:rgba(148,163,184,0.06);color:var(--muted)}
.explain{font-size:12px;color:var(--muted);margin-top:6px}
.log{max-height:220px;overflow:auto;padding:8px;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);font-family:monospace;font-size:12px}
@media(max-width:980px){ .row{flex-direction:column} .param-grid{grid-template-columns:1fr} .canvasWrap{height:160px}}
</style>
</head>
<body>
<div class="wrap">
  <div class="header">
    <div class="hleft">
      <h1>Bekenet-style AI Signals — Standalone</h1>
      <div class="small muted">Dark • Forex & Commodities & Crypto • No repaint • 30s updates • Single page</div>
    </div>
    <div class="controls card">
      <div class="small muted">Update every <b>30s</b></div>
      <div style="display:flex;gap:6px;align-items:center;margin-left:12px">
        <label class="small muted">AlphaVantage key (optional for Forex/XAU):</label>
        <input id="avKey" style="background:transparent;border:1px solid rgba(255,255,255,0.06);padding:6px;border-radius:8px;color:#e6eef8" placeholder="paste AV key if you have one"/>
      </div>
      <button id="refreshNow" class="btn">Refresh Now</button>
    </div>
  </div>

  <div class="row">
    <div style="flex:1" class="col">
      <div class="card">
        <div style="display:flex;justify-content:space-between;align-items:flex-start;gap:12px">
          <div style="min-width:220px">
            <div class="small muted">Pairs monitored (single-page)</div>
            <div class="small muted">You can add/remove pair symbols below</div>
          </div>
          <div style="display:flex;gap:8px;align-items:center">
            <label class="small muted">Add Pair (ex: EUR/USD, XAU/USD, BTC/USD)</label>
            <input id="addPairInput" placeholder="EUR/USD" style="background:transparent;border:1px solid rgba(255,255,255,0.06);padding:6px;border-radius:8px;color:#e6eef8"/>
            <button id="addPairBtn" class="btn">Add</button>
          </div>
        </div>

        <div style="margin-top:12px" class="pairsList card" id="pairsContainer"></div>

        <div style="margin-top:10px;display:flex;gap:8px;align-items:center">
          <button id="clearPairs" class="btn">Reset Pairs</button>
          <div class="small muted">Defaults: EUR/USD, GBP/USD, USD/JPY, XAU/USD, BTC/USD</div>
        </div>
      </div>

      <div class="card" style="margin-top:12px">
        <div class="canvasWrap">
          <canvas id="miniChart" class="canvas"></canvas>
        </div>
        <div style="display:flex;justify-content:space-between;align-items:center;margin-top:8px">
          <div>
            <div class="small muted">Selected pair</div>
            <div id="selectedPair" style="font-weight:700">—</div>
            <div id="selectedPrice" class="small muted">Price: —</div>
          </div>
          <div>
            <div class="small muted">Entry mode</div>
            <select id="entryMode" style="background:transparent;border:1px solid rgba(255,255,255,0.06);padding:6px;border-radius:8px;color:#e6eef8">
              <option value="smart">Smart (EMA+RSI+S/R)</option>
              <option value="aggressive">Aggressive (EMA crossover)</option>
              <option value="conservative">Conservative (RSI+S/R)</option>
            </select>
          </div>
          <div>
            <div class="small muted">TF (for candle building)</div>
            <select id="tf" style="background:transparent;border:1px solid rgba(255,255,255,0.06);padding:6px;border-radius:8px;color:#e6eef8">
              <option value="1m">1m</option><option value="5m">5m</option><option value="15m">15m</option>
            </select>
          </div>
        </div>

        <div class="param-grid" style="margin-top:12px">
          <div><label class="small muted">EMA fast</label><input id="emaFast" type="number" value="12" /></div>
          <div><label class="small muted">EMA slow</label><input id="emaSlow" type="number" value="26" /></div>
          <div><label class="small muted">RSI period</label><input id="rsiPeriod" type="number" value="14" /></div>
          <div><label class="small muted">RSI buy level</label><input id="rsiBuy" type="number" value="30" /></div>
          <div><label class="small muted">RSI sell level</label><input id="rsiSell" type="number" value="70" /></div>
          <div><label class="small muted">S/R lookback bars</label><input id="srLookback" type="number" value="50" /></div>
        </div>

        <div class="explain" id="globalExplain">Signals appear only on closed candles. No repaint. One active signal per pair at a time.</div>
      </div>
    </div>

    <div style="width:380px" class="col">
      <div class="card">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div style="font-weight:700">Live Signals</div>
          <div class="small muted">Updated every 30s</div>
        </div>
        <div id="liveList" style="margin-top:8px;display:flex;flex-direction:column;gap:8px"></div>
      </div>

      <div class="card" style="margin-top:12px">
        <div style="font-weight:700">Trade Advice / Exit Hints</div>
        <div id="exitHints" class="explain">No open trades</div>
      </div>

      <div class="card" style="margin-top:12px">
        <div style="font-weight:700">Log</div>
        <div id="log" class="log" style="margin-top:8px">Ready.</div>
      </div>
    </div>
  </div>
</div>

<script>
// Fixed and simplified version that actually generates signals

// ---------- Utilities ----------
const $ = id => document.getElementById(id);
const sleep = ms => new Promise(r => setTimeout(r, ms));
function nowISO(){ return new Date().toISOString(); }
function log(msg){ $('log').innerText = nowISO() + ' • ' + msg + '\n' + $('log').innerText; }

// ---------- Default pairs ----------
let pairs = ['EUR/USD','GBP/USD','USD/JPY','XAU/USD','BTC/USD'];
const state = {}; // per-pair state and candles

// ---------- Config & UI elements ----------
const refreshInterval = 30 * 1000; // 30s
const miniCanvas = $('miniChart');
const miniCtx = miniCanvas.getContext('2d');
function resizeCanvas(){ miniCanvas.width = miniCanvas.clientWidth * devicePixelRatio; miniCanvas.height = miniCanvas.clientHeight * devicePixelRatio; miniCtx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0); }
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

$('addPairBtn').addEventListener('click', ()=>{ const v=$('addPairInput').value.trim(); if(v){ addPair(v); $('addPairInput').value=''; }});
$('clearPairs').addEventListener('click', ()=>{ pairs = ['EUR/USD','GBP/USD','USD/JPY','XAU/USD','BTC/USD']; initPairs();});
$('refreshNow').addEventListener('click', fetchAllOnce);

// initialize UI
function renderPairsUI(){
  const container = $('pairsContainer'); container.innerHTML='';
  pairs.forEach(p=>{
    const div = document.createElement('div'); div.className='pairRow';
    const left = document.createElement('div'); left.innerHTML = `<div style="font-weight:700">${p}</div><div class="small muted" id="p-${p}-info">—</div>`;
    const right = document.createElement('div');
    const badge = document.createElement('span'); badge.id = `badge-${p}`; badge.className='badge wait'; badge.innerText='WAIT';
    const btnSel = document.createElement('button'); btnSel.className='btn'; btnSel.innerText='Select'; btnSel.onclick=()=> selectPair(p);
    const btnRem = document.createElement('button'); btnRem.className='btn'; btnRem.innerText='Remove'; btnRem.onclick=()=> removePair(p);
    right.appendChild(badge); right.appendChild(btnSel); right.appendChild(btnRem);
    div.appendChild(left); div.appendChild(right);
    container.appendChild(div);
  });
}
function addPair(p){ if(!pairs.includes(p)){ pairs.push(p); initPairs(); log('Added pair '+p);} }
function removePair(p){ pairs = pairs.filter(x=>x!==p); initPairs(); log('Removed pair '+p); }
function selectPair(p){ $('selectedPair').innerText = p; renderMiniChartFor(p); }

// initial fill
function initPairs(){ 
  renderPairsUI(); 
  pairs.forEach(p=>{ 
    state[p] = state[p] || {
      candles:[],
      lastSignal:null, 
      openPosition:null,
      lastEvaluated:0
    }; 
  }); 
  renderLiveList(); 
}

// ---------- Indicator helpers (FIXED) ----------
function ema(values, period){
  if (!values || values.length < period) return Array(values.length).fill(null);
  
  const k = 2 / (period + 1);
  const result = [values[0]]; // First value is the same
  
  for (let i = 1; i < values.length; i++) {
    const emaValue = values[i] * k + result[i-1] * (1 - k);
    result.push(emaValue);
  }
  return result;
}

function rsi(values, period = 14){
  if (!values || values.length <= period) return Array(values.length).fill(50);
  
  const gains = [];
  const losses = [];
  
  // Calculate price changes
  for (let i = 1; i < values.length; i++) {
    const change = values[i] - values[i-1];
    gains.push(Math.max(change, 0));
    losses.push(Math.max(-change, 0));
  }
  
  const result = Array(period).fill(null);
  
  // Calculate first RSI value
  let avgGain = gains.slice(0, period).reduce((a, b) => a + b, 0) / period;
  let avgLoss = losses.slice(0, period).reduce((a, b) => a + b, 0) / period;
  
  if (avgLoss === 0) {
    result.push(100);
  } else {
    const rs = avgGain / avgLoss;
    result.push(100 - (100 / (1 + rs)));
  }
  
  // Calculate subsequent RSI values
  for (let i = period + 1; i < values.length; i++) {
    avgGain = ((avgGain * (period - 1)) + gains[i-1]) / period;
    avgLoss = ((avgLoss * (period - 1)) + losses[i-1]) / period;
    
    if (avgLoss === 0) {
      result.push(100);
    } else {
      const rs = avgGain / avgLoss;
      result.push(100 - (100 / (1 + rs)));
    }
  }
  
  // Fill beginning with nulls to match input length
  while (result.length < values.length) {
    result.unshift(null);
  }
  
  return result;
}

// ---------- Data Generation (FIXED) ----------
// Generate realistic price data for demonstration
function generatePriceData(basePrice, volatility = 0.002, trend = 0.0001, numPoints = 200) {
  const data = [];
  let price = basePrice;
  
  for (let i = 0; i < numPoints; i++) {
    // Add some randomness with trend
    const randomChange = (Math.random() - 0.5) * 2 * volatility;
    price = price * (1 + randomChange + trend);
    
    // Ensure price doesn't go to zero
    price = Math.max(price, 0.0001);
    
    const timestamp = Date.now() - (numPoints - i) * 60000; // 1 minute intervals
    
    data.push({
      t: timestamp,
      o: price * (1 - Math.random() * 0.001),
      h: price * (1 + Math.random() * 0.002),
      l: price * (1 - Math.random() * 0.002),
      c: price,
      v: Math.random() * 1000
    });
  }
  
  return data;
}

// Get base prices for different pairs
function getBasePrice(pair) {
  const basePrices = {
    'EUR/USD': 1.0850,
    'GBP/USD': 1.2650,
    'USD/JPY': 151.50,
    'XAU/USD': 1980.00,
    'BTC/USD': 45000.00
  };
  return basePrices[pair] || 1.0000;
}

// ---------- Signal Generation (FIXED) ----------
function generateSignal(candles, params, mode) {
  if (!candles || candles.length < Math.max(params.emaSlow, params.rsiPeriod)) {
    return { side: 'WAIT', reasons: ['Insufficient data'] };
  }
  
  const closes = candles.map(c => c.c);
  const currentPrice = closes[closes.length - 1];
  
  // Calculate indicators
  const emaFast = ema(closes, params.emaFast);
  const emaSlow = ema(closes, params.emaSlow);
  const rsiValues = rsi(closes, params.rsiPeriod);
  
  const currentEmaFast = emaFast[emaFast.length - 1];
  const currentEmaSlow = emaSlow[emaSlow.length - 1];
  const currentRsi = rsiValues[rsiValues.length - 1];
  
  // Generate signals based on mode
  let side = 'WAIT';
  let reasons = [];
  
  if (mode === 'aggressive') {
    // Aggressive: EMA crossover only
    if (currentEmaFast > currentEmaSlow) {
      side = 'BUY';
      reasons.push('EMA Fast > EMA Slow');
    } else if (currentEmaFast < currentEmaSlow) {
      side = 'SELL';
      reasons.push('EMA Fast < EMA Slow');
    }
  } else if (mode === 'conservative') {
    // Conservative: RSI extremes only
    if (currentRsi < params.rsiBuy) {
      side = 'BUY';
      reasons.push(`RSI ${currentRsi.toFixed(1)} < ${params.rsiBuy}`);
    } else if (currentRsi > params.rsiSell) {
      side = 'SELL';
      reasons.push(`RSI ${currentRsi.toFixed(1)} > ${params.rsiSell}`);
    }
  } else {
    // Smart: Combined approach
    const emaBullish = currentEmaFast > currentEmaSlow;
    const emaBearish = currentEmaFast < currentEmaSlow;
    const rsiOversold = currentRsi < params.rsiBuy;
    const rsiOverbought = currentRsi > params.rsiSell;
    
    if (emaBullish && rsiOversold) {
      side = 'BUY';
      reasons.push(`EMA Bullish + RSI Oversold (${currentRsi.toFixed(1)})`);
    } else if (emaBearish && rsiOverbought) {
      side = 'SELL';
      reasons.push(`EMA Bearish + RSI Overbought (${currentRsi.toFixed(1)})`);
    } else if (emaBullish) {
      side = 'BUY';
      reasons.push('EMA Bullish crossover');
    } else if (emaBearish) {
      side = 'SELL';
      reasons.push('EMA Bearish crossover');
    }
  }
  
  return {
    side,
    reasons,
    context: {
      price: currentPrice,
      emaFast: currentEmaFast,
      emaSlow: currentEmaSlow,
      rsiVal: currentRsi
    }
  };
}

// ---------- UI Updates (FIXED) ----------
function updateLiveList() {
  const container = $('liveList');
  container.innerHTML = '';
  
  pairs.forEach(pair => {
    const st = state[pair];
    if (!st) return;
    
    const div = document.createElement('div');
    div.className = 'pairRow';
    
    const left = document.createElement('div');
    left.innerHTML = `
      <div style="font-weight:700">${pair}</div>
      <div class="small muted">Price: ${st.candles.length > 0 ? st.candles[st.candles.length-1].c.toFixed(6) : '—'}</div>
    `;
    
    const right = document.createElement('div');
    right.style.display = 'flex';
    right.style.gap = '8px';
    right.style.alignItems = 'center';
    
    const signal = document.createElement('span');
    
    if (st.lastSignal) {
      if (st.lastSignal.side === 'BUY') {
        signal.className = 'badge buy';
        signal.innerText = 'BUY';
      } else if (st.lastSignal.side === 'SELL') {
        signal.className = 'badge sell';
        signal.innerText = 'SELL';
      } else {
        signal.className = 'badge wait';
        signal.innerText = 'WAIT';
      }
    } else {
      signal.className = 'badge wait';
      signal.innerText = 'WAIT';
    }
    
    const hint = document.createElement('div');
    hint.className = 'small muted';
    hint.innerText = st.lastSignal ? st.lastSignal.reasons.join(', ') : 'Analyzing...';
    
    right.appendChild(signal);
    right.appendChild(hint);
    div.appendChild(left);
    div.appendChild(right);
    container.appendChild(div);
  });
}

function renderMiniChartFor(pair) {
  const st = state[pair];
  if (!st || !st.candles.length) return;
  
  const canvas = $('miniChart');
  const ctx = miniCtx;
  const width = canvas.width / devicePixelRatio;
  const height = canvas.height / devicePixelRatio;
  
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
  
  const candlesToShow = st.candles.slice(-50); // Show last 50 candles
  if (candlesToShow.length === 0) return;
  
  // Calculate price range
  let minPrice = Infinity;
  let maxPrice = -Infinity;
  
  candlesToShow.forEach(candle => {
    minPrice = Math.min(minPrice, candle.l);
    maxPrice = Math.max(maxPrice, candle.h);
  });
  
  const priceRange = maxPrice - minPrice;
  const padding = priceRange * 0.1;
  minPrice -= padding;
  maxPrice += padding;
  
  const candleWidth = (width - 20) / candlesToShow.length;
  
  // Draw candles
  candlesToShow.forEach((candle, index) => {
    const x = 10 + index * candleWidth;
    const openY = height - ((candle.o - minPrice) / (maxPrice - minPrice)) * height;
    const closeY = height - ((candle.c - minPrice) / (maxPrice - minPrice)) * height;
    const highY = height - ((candle.h - minPrice) / (maxPrice - minPrice)) * height;
    const lowY = height - ((candle.l - minPrice) / (maxPrice - minPrice)) * height;
    
    // Draw wick
    ctx.beginPath();
    ctx.moveTo(x + candleWidth/2, highY);
    ctx.lineTo(x + candleWidth/2, lowY);
    ctx.strokeStyle = 'rgba(255,255,255,0.5)';
    ctx.lineWidth = 1;
    ctx.stroke();
    
    // Draw body
    const bodyTop = Math.min(openY, closeY);
    const bodyHeight = Math.abs(openY - closeY);
    const isBullish = candle.c >= candle.o;
    
    ctx.fillStyle = isBullish ? 'rgba(34,197,94,0.8)' : 'rgba(239,68,68,0.8)';
    ctx.fillRect(x, bodyTop, candleWidth * 0.8, Math.max(1, bodyHeight));
  });
  
  // Update price display
  const lastCandle = candlesToShow[candlesToShow.length - 1];
  $('selectedPrice').innerText = `Price: ${lastCandle.c.toFixed(6)}`;
}

// ---------- Main Processing (FIXED) ----------
async function fetchForPair(pair) {
  try {
    // Initialize state if needed
    if (!state[pair]) {
      state[pair] = {
        candles: [],
        lastSignal: null,
        openPosition: null,
        lastEvaluated: 0
      };
    }
    
    const st = state[pair];
    
    // Generate or use existing price data
    if (st.candles.length === 0) {
      const basePrice = getBasePrice(pair);
      st.candles = generatePriceData(basePrice);
      log(`Generated price data for ${pair}`);
    } else {
      // Add new candle with some randomness
      const lastCandle = st.candles[st.candles.length - 1];
      const volatility = 0.001;
      const change = (Math.random() - 0.5) * 2 * volatility;
      const newPrice = lastCandle.c * (1 + change);
      
      const newCandle = {
        t: Date.now(),
        o: newPrice * (1 - Math.random() * 0.0005),
        h: newPrice * (1 + Math.random() * 0.001),
        l: newPrice * (1 - Math.random() * 0.001),
        c: newPrice,
        v: Math.random() * 1000
      };
      
      st.candles.push(newCandle);
      
      // Keep only last 200 candles
      if (st.candles.length > 200) {
        st.candles.shift();
      }
    }
    
    // Generate signal
    const params = {
      emaFast: parseInt($('emaFast').value) || 12,
      emaSlow: parseInt($('emaSlow').value) || 26,
      rsiPeriod: parseInt($('rsiPeriod').value) || 14,
      rsiBuy: parseInt($('rsiBuy').value) || 30,
      rsiSell: parseInt($('rsiSell').value) || 70
    };
    
    const mode = $('entryMode').value;
    const signal = generateSignal(st.candles, params, mode);
    
    // Update state
    st.lastSignal = signal;
    
    // Update UI
    updatePairBadge(pair, signal);
    
    // Log significant signals
    if (signal.side !== 'WAIT') {
      log(`${pair} ${signal.side} signal: ${signal.reasons.join(', ')}`);
    }
    
  } catch (error) {
    log(`Error processing ${pair}: ${error.message}`);
    console.error(error);
  }
}

function updatePairBadge(pair, signal) {
  const badge = $(`badge-${pair}`);
  const info = $(`p-${pair}-info`);
  
  if (badge && info) {
    if (signal.side === 'BUY') {
      badge.className = 'badge buy';
      badge.innerText = 'BUY';
    } else if (signal.side === 'SELL') {
      badge.className = 'badge sell';
      badge.innerText = 'SELL';
    } else {
      badge.className = 'badge wait';
      badge.innerText = 'WAIT';
    }
    
    info.innerText = `Price: ${signal.context ? signal.context.price.toFixed(6) : '—'}`;
  }
}

async function fetchAllOnce() {
  log('Fetching data for all pairs...');
  
  for (const pair of pairs) {
    await fetchForPair(pair);
    await sleep(100); // Small delay between pairs
  }
  
  updateLiveList();
  
  // Update selected pair chart
  const selectedPair = $('selectedPair').innerText;
  if (selectedPair && selectedPair !== '—') {
    renderMiniChartFor(selectedPair);
  } else if (pairs.length > 0) {
    selectPair(pairs[0]);
  }
  
  log('Data fetch completed');
}

// ---------- Main Loop ----------
let running = true;

async function runLoop() {
  while (running) {
    try {
      await fetchAllOnce();
      await sleep(refreshInterval);
    } catch (error) {
      log(`Loop error: ${error.message}`);
      await sleep(5000);
    }
  }
}

// ---------- Initialization ----------
(function init() {
  initPairs();
  
  // Select first pair by default
  if (pairs.length > 0) {
    selectPair(pairs[0]);
  }
  
  // Start the main loop
  runLoop();
  log('Trading dashboard started successfully!');
})();

// Expose functions for external use
window.addPair = addPair;
window.removePair = removePair;
window.fetchAllOnce = fetchAllOnce;
</script>
</body>
</html>
