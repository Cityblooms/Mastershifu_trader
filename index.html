<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>AI SMC Multi-Asset Dashboard</title>
<script src="https://unpkg.com/lightweight-charts@4.0.1/dist/lightweight-charts.standalone.production.js"></script>
<style>
body{font-family:'Poppins',sans-serif;background:#0b0b10;color:#eee;margin:0;padding:0;display:flex;flex-direction:column;align-items:center}
header{background:#111827;width:100%;padding:10px 20px;text-align:center;font-size:1.3em;box-shadow:0 2px 5px rgba(0,0,0,.4)}
.controls{margin:15px 0;display:flex;gap:10px;flex-wrap:wrap;justify-content:center}
select,button,input[type=checkbox]{background:#1f2937;color:#fff;border:none;padding:10px 16px;border-radius:10px;cursor:pointer;font-weight:600;transition:.3s}
button:hover,select:hover{background:#4f46e5}
#chart{width:95%;height:400px;margin-top:10px;border-radius:10px}
#signalLog{width:95%;margin-top:20px;background:#1e1e2e;border-radius:10px;padding:10px;max-height:250px;overflow-y:auto}
.signal-card{background:#26263a;margin:5px 0;padding:10px;border-left:5px solid #6366f1;border-radius:8px;font-size:.9em}
.buy{border-left-color:#22c55e}.sell{border-left-color:#ef4444}
label{display:flex;align-items:center;gap:6px;font-size:.9em}
.status-container{display:flex;gap:15px;margin:10px 0;flex-wrap:wrap;justify-content:center}
.status-item{padding:8px 15px;background:#1f2937;border-radius:8px;font-size:0.9em}
.connected{color:#22c55e}.disconnected{color:#ef4444}.connecting{color:#f59e0b}
.loading{display:none;color:#f59e0b}
.time-display{font-size:0.9em;color:#888;margin:5px 0}
.conditions{background:#1a1a2e;padding:10px;border-radius:8px;margin:10px 0;font-size:0.8em}
.condition-met{color:#22c55e}
.condition-failed{color:#ef4444}
.current-signal{font-size:1.2em;font-weight:bold;padding:10px;border-radius:8px;margin:10px 0;text-align:center}
.signal-buy{background:#1a2e1a;color:#22c55e;border:2px solid #22c55e}
.signal-sell{background:#2e1a1a;color:#ef4444;border:2px solid #ef4444}
.signal-none{background:#1a1a2e;color:#888;border:2px solid #6366f1}
.sync-status{font-size:0.8em;color:#f59e0b;margin:5px 0}
</style>
</head>
<body>
<header>AI SMC Multi-Asset Dashboard</header>

<div class="controls">
  <select id="pairSelect">
    <optgroup label="Forex Major">
      <option value="EURUSD">EUR/USD</option>
      <option value="GBPUSD">GBP/USD</option>
      <option value="USDJPY">USD/JPY</option>
      <option value="AUDUSD">AUD/USD</option>
      <option value="USDCAD">USD/CAD</option>
      <option value="NZDUSD">NZD/USD</option>
      <option value="EURGBP">EUR/GBP</option>
      <option value="EURJPY">EUR/JPY</option>
    </optgroup>
    <optgroup label="Commodities & Crypto">
      <option value="XAUUSD">Gold (XAU/USD)</option>
      <option value="BTCUSD">Bitcoin (BTC/USD)</option>
    </optgroup>
    <optgroup label="Volatility Indices">
      <option value="Volatility 10 Index">Volatility 10 Index</option>
      <option value="Volatility 25 Index">Volatility 25 Index</option>
      <option value="Volatility 50 Index">Volatility 50 Index</option>
      <option value="Volatility 75 Index">Volatility 75 Index</option>
      <option value="Volatility 100 Index">Volatility 100 Index</option>
    </optgroup>
    <optgroup label="Boom & Crash Indices">
      <option value="Boom 1000 Index">Boom 1000 Index</option>
      <option value="Boom 500 Index">Boom 500 Index</option>
      <option value="Crash 1000 Index">Crash 1000 Index</option>
      <option value="Crash 500 Index">Crash 500 Index</option>
    </optgroup>
    <optgroup label="Step & Jump Indices">
      <option value="Step 100 Index">Step 100 Index</option>
      <option value="Step 400 Index">Step 400 Index</option>
      <option value="Step 500 Index">Step 500 Index</option>
      <option value="Step Index">Step Index</option>
      <option value="Jump 10 Index">Jump 10 Index</option>
      <option value="Jump 25 Index">Jump 25 Index</option>
      <option value="Jump 50 Index">Jump 50 Index</option>
      <option value="Jump 75 Index">Jump 75 Index</option>
      <option value="Jump 100 Index">Jump 100 Index</option>
    </optgroup>
  </select>
  <button id="connectFeed">üîå Connect Live Feed</button>
  <button id="disconnectFeed">üîå Disconnect</button>
  <button id="generateSignal">‚ö° Manual SMC Signal</button>
  <label><input type="checkbox" id="autoMode" checked> Auto Signal Mode</label>
  <label><input type="checkbox" id="filterMode" checked> EMA + RSI Filter</label>
  <button id="clearSignals">üßπ Clear</button>
</div>

<div class="status-container">
  <div>Status: <span id="connectionStatus" class="disconnected">Disconnected</span></div>
  <div>5m Feed: <span id="feed5mStatus" class="disconnected">‚ùå</span></div>
  <div>15m Feed: <span id="feed15mStatus" class="disconnected">‚ùå</span></div>
  <div class="loading" id="loadingIndicator">üîÑ Loading Historical Data...</div>
</div>

<div class="time-display">
  System Time: <span id="systemTime">-</span> | 
  Chart Time: <span id="chartTime">-</span> |
  Next Candle: <span id="nextCandleTime">-</span>
</div>

<div class="sync-status" id="syncStatus">üîÑ Synchronizing timeframes...</div>

<div id="currentSignal" class="current-signal signal-none">
  üü° NO CURRENT SIGNAL - Waiting for perfect conditions...
</div>

<div class="conditions">
  <strong>Signal Conditions:</strong>
  <div id="conditionStatus">Waiting for data...</div>
</div>

<div id="chart"></div>
<h3>üìä Recent Signals <span id="signalCount">(0)</span></h3>
<div id="signalLog"></div>

<script>
// --- Global State ---
const state = {
  wsBinance5m: null,
  wsBinance15m: null,
  wsDeriv: null,
  pair: "EURUSD",
  candles: [],
  candlesHTF: [],
  ema: [],
  emaHTF: [],
  rsi: [],
  rsiHTF: [],
  auto: true,
  filter: true,
  lastSignalTime: 0,
  series: null,
  emaSeries: null,
  signals: [],
  markers: [],
  reconnectAttempts: 0,
  maxReconnectAttempts: 5,
  currentTime: Math.floor(Date.now() / 1000),
  lastCandleTime: null,
  liveUpdateInterval: null,
  currentBias: null,
  timeSyncInterval: null,
  pendingResponses: {}, // For Deriv req_id
  nextReqId: 1,
  binancePairs: ['BTCUSD'],
  derivPairs: [
    'Volatility 10 Index', 'Volatility 25 Index', 'Volatility 50 Index', 'Volatility 75 Index', 'Volatility 100 Index',
    'Boom 1000 Index', 'Boom 500 Index', 'Crash 1000 Index', 'Crash 500 Index',
    'Step 100 Index', 'Step 400 Index', 'Step 500 Index', 'Step Index',
    'Jump 10 Index', 'Jump 25 Index', 'Jump 50 Index', 'Jump 75 Index', 'Jump 100 Index'
  ]
};

// --- Deriv Symbol Mapping ---
function getDerivSymbol(pair) {
  const mapping = {
    'Volatility 10 Index': 'R_10',
    'Volatility 25 Index': 'R_25',
    'Volatility 50 Index': 'R_50',
    'Volatility 75 Index': 'R_75',
    'Volatility 100 Index': 'R_100',
    'Boom 1000 Index': 'Boom1000',
    'Boom 500 Index': 'Boom500',
    'Crash 1000 Index': 'Crash1000',
    'Crash 500 Index': 'Crash500',
    'Step 100 Index': 'Step100',
    'Step 400 Index': 'Step400',
    'Step 500 Index': 'Step500',
    'Step Index': 'StepIndex',
    'Jump 10 Index': 'Jump10',
    'Jump 25 Index': 'Jump25',
    'Jump 50 Index': 'Jump50',
    'Jump 75 Index': 'Jump75',
    'Jump 100 Index': 'Jump100'
  };
  return mapping[pair] || pair;
}

// --- Chart setup ---
const chart = LightweightCharts.createChart(document.getElementById('chart'), {
  layout: { background: { color: "#0b0b10" }, textColor: "#DDD" },
  grid: { vertLines: { color: "#1e1e2e" }, horzLines: { color: "#1e1e2e" } },
  timeScale: { 
    timeVisible: true, 
    secondsVisible: false,
    rightOffset: 12,
    barSpacing: 6,
    minBarSpacing: 0.5
  },
  crosshair: {
    mode: LightweightCharts.CrosshairMode.Normal,
  }
});
state.series = chart.addCandlestickSeries();
state.emaSeries = chart.addLineSeries({ color: '#f59e0b', lineWidth: 2 });

// --- Asset Properties ---
const assetProperties = {
  // Forex Pairs
  "EURUSD": { basePrice: 1.0800, volatility: 0.0008, trendStrength: 0.0001, decimals: 5 },
  "GBPUSD": { basePrice: 1.2600, volatility: 0.0010, trendStrength: 0.0001, decimals: 5 },
  "USDJPY": { basePrice: 148.50, volatility: 0.0080, trendStrength: 0.0005, decimals: 3 },
  "AUDUSD": { basePrice: 0.6550, volatility: 0.0012, trendStrength: 0.0001, decimals: 5 },
  "USDCAD": { basePrice: 1.3500, volatility: 0.0010, trendStrength: 0.0001, decimals: 5 },
  "NZDUSD": { basePrice: 0.6100, volatility: 0.0012, trendStrength: 0.0001, decimals: 5 },
  "EURGBP": { basePrice: 0.8570, volatility: 0.0006, trendStrength: 0.00005, decimals: 5 },
  "EURJPY": { basePrice: 160.00, volatility: 0.0090, trendStrength: 0.0005, decimals: 3 },
  
  // Commodities & Crypto
  "XAUUSD": { basePrice: 1980.00, volatility: 0.005, trendStrength: 0.002, decimals: 2 },
  "BTCUSD": { basePrice: 43000.00, volatility: 0.015, trendStrength: 0.005, decimals: 2 },
  
  // Volatility Indices
  "Volatility 10 Index": { basePrice: 10000, volatility: 0.08, trendStrength: 0.1, decimals: 0 },
  "Volatility 25 Index": { basePrice: 10000, volatility: 0.12, trendStrength: 0.15, decimals: 0 },
  "Volatility 50 Index": { basePrice: 10000, volatility: 0.18, trendStrength: 0.2, decimals: 0 },
  "Volatility 75 Index": { basePrice: 10000, volatility: 0.25, trendStrength: 0.25, decimals: 0 },
  "Volatility 100 Index": { basePrice: 10000, volatility: 0.35, trendStrength: 0.3, decimals: 0 },
  
  // Boom & Crash Indices
  "Boom 1000 Index": { basePrice: 1000, volatility: 0.05, trendStrength: 0.4, decimals: 0 },
  "Boom 500 Index": { basePrice: 500, volatility: 0.06, trendStrength: 0.35, decimals: 0 },
  "Crash 1000 Index": { basePrice: 1000, volatility: 0.05, trendStrength: -0.4, decimals: 0 },
  "Crash 500 Index": { basePrice: 500, volatility: 0.06, trendStrength: -0.35, decimals: 0 },
  
  // Step & Jump Indices
  "Step 100 Index": { basePrice: 10000, volatility: 0.02, trendStrength: 0.1, decimals: 0 },
  "Step 400 Index": { basePrice: 10000, volatility: 0.08, trendStrength: 0.1, decimals: 0 },
  "Step 500 Index": { basePrice: 10000, volatility: 0.10, trendStrength: 0.1, decimals: 0 },
  "Step Index": { basePrice: 10000, volatility: 0.02, trendStrength: 0.1, decimals: 0 },
  "Jump 10 Index": { basePrice: 10000, volatility: 0.15, trendStrength: 0.1, decimals: 0 },
  "Jump 25 Index": { basePrice: 10000, volatility: 0.2, trendStrength: 0.15, decimals: 0 },
  "Jump 50 Index": { basePrice: 10000, volatility: 0.25, trendStrength: 0.2, decimals: 0 },
  "Jump 75 Index": { basePrice: 10000, volatility: 0.3, trendStrength: 0.25, decimals: 0 },
  "Jump 100 Index": { basePrice: 10000, volatility: 0.4, trendStrength: 0.3, decimals: 0 }
};

// --- Persistence ---
function saveSignals() {
  localStorage.setItem('smcSignals', JSON.stringify(state.signals));
}

function loadSignals() {
  const saved = localStorage.getItem('smcSignals');
  if (saved) {
    state.signals = JSON.parse(saved);
    repopulateSignalLog();
  }
}

function repopulateSignalLog() {
  document.getElementById('signalLog').innerHTML = '';
  state.signals.slice().reverse().forEach(addSignalToLog);
  document.getElementById('signalCount').textContent = `(${state.signals.length})`;
}

function addSignalToLog(sig) {
  const div = document.createElement('div');
  div.className = `signal-card ${sig.bias.toLowerCase()}`;
  const properties = assetProperties[state.pair] || { decimals: 2 };
  const decimals = properties.decimals;
  div.innerHTML = `<b>${sig.pair}</b> | <b>${sig.bias}</b> | Entry ${sig.entry.toFixed(decimals)} TP ${sig.tp.toFixed(decimals)} SL ${sig.sl.toFixed(decimals)}<br>
    Reason: ${sig.reason}<br>Conf: ${sig.confidence}% | ${sig.time}`;
  document.getElementById('signalLog').appendChild(div);
}

// --- Time Synchronization Functions ---
function getCurrentCandleTime(timeframe = 5) {
  const now = Math.floor(Date.now() / 1000);
  const alignedTime = now - (now % (timeframe * 60));
  return alignedTime;
}

function updateTimeDisplay() {
  const now = new Date();
  document.getElementById('systemTime').textContent = now.toLocaleTimeString();
  
  if (state.candles.length > 0) {
    const lastCandleTime = new Date(state.candles[state.candles.length - 1].time * 1000);
    document.getElementById('chartTime').textContent = lastCandleTime.toLocaleTimeString();
    
    const nextCandleTime = new Date((state.candles[state.candles.length - 1].time + 300) * 1000);
    document.getElementById('nextCandleTime').textContent = nextCandleTime.toLocaleTimeString();
    
    const timeDiff = Math.abs(now.getTime() - lastCandleTime.getTime());
    const syncElement = document.getElementById('syncStatus');
    if (timeDiff < 10000) {
      syncElement.textContent = '‚úÖ Timeframes synchronized';
      syncElement.style.color = '#22c55e';
    } else {
      syncElement.textContent = '‚ö†Ô∏è Timeframes slightly out of sync';
      syncElement.style.color = '#f59e0b';
    }
  }
}

// --- Update Current Signal Display ---
function updateCurrentSignal(bias, confidence) {
  const signalElement = document.getElementById('currentSignal');
  
  if (bias === 'BUY') {
    signalElement.className = 'current-signal signal-buy';
    signalElement.innerHTML = `üéØ BUY SIGNAL ACTIVE | Confidence: ${confidence}% | ${state.pair}`;
  } else if (bias === 'SELL') {
    signalElement.className = 'current-signal signal-sell';
    signalElement.innerHTML = `üéØ SELL SIGNAL ACTIVE | Confidence: ${confidence}% | ${state.pair}`;
  } else {
    signalElement.className = 'current-signal signal-none';
    signalElement.innerHTML = `üü° NO CURRENT SIGNAL - Waiting for perfect conditions...`;
  }
}

// --- Update Condition Display ---
function updateConditionStatus(conditions) {
  const conditionElement = document.getElementById('conditionStatus');
  let html = '';
  
  conditions.forEach(condition => {
    const statusClass = condition.met ? 'condition-met' : 'condition-failed';
    const icon = condition.met ? '‚úÖ' : '‚ùå';
    html += `<div class="${statusClass}">${icon} ${condition.name}</div>`;
  });
  
  conditionElement.innerHTML = html;
}

// --- EMA Calculation ---
function calcEMA(values, period) {
  if (!values || values.length < period) return [];
  try {
    let k = 2 / (period + 1);
    let ema = [values[0]];
    for (let i = 1; i < values.length; i++) {
      ema.push(values[i] * k + ema[i - 1] * (1 - k));
    }
    return ema;
  } catch (error) {
    console.error('EMA calculation error:', error);
    return [];
  }
}

// --- Fixed RSI Calculation ---
function calcRSI(values, period = 14) {
  if (!values || values.length < period + 1) return [];
  
  try {
    let gains = 0;
    let losses = 0;

    for (let i = 1; i <= period; i++) {
      const diff = values[i] - values[i - 1];
      gains += Math.max(diff, 0);
      losses += Math.max(-diff, 0);
    }

    let avgGain = gains / period;
    let avgLoss = losses / period;
    const rsi = new Array(period).fill(null);

    // Compute and append the first RSI value
    let firstRSI;
    if (avgLoss === 0) {
      firstRSI = 100;
    } else {
      const rs = avgGain / avgLoss;
      firstRSI = 100 - (100 / (1 + rs));
    }
    rsi.push(firstRSI);

    // Subsequent RSI values
    for (let i = period + 1; i < values.length; i++) {
      const diff = values[i] - values[i - 1];
      const currentGain = Math.max(diff, 0);
      const currentLoss = Math.max(-diff, 0);

      avgGain = (avgGain * (period - 1) + currentGain) / period;
      avgLoss = (avgLoss * (period - 1) + currentLoss) / period;

      let thisRSI;
      if (avgLoss === 0) {
        thisRSI = 100;
      } else {
        const rs = avgGain / avgLoss;
        thisRSI = 100 - (100 / (1 + rs));
      }
      rsi.push(thisRSI);
    }
    return rsi;
  } catch (error) {
    console.error('RSI calculation error:', error);
    return [];
  }
}

// --- Update Chart and Indicators ---
function updateChart() {
  if (state.candles.length > 0) {
    state.series.setData(state.candles);
    const closesAll = state.candles.map(x => x.close);
    state.ema = calcEMA(closesAll, 50);
    state.rsi = calcRSI(closesAll, 14);
    
    if (state.ema.length > 0) {
      const emaPlot = state.candles.slice(-state.ema.length).map((x, i) => ({
        time: x.time,
        value: state.ema[i]
      }));
      state.emaSeries.setData(emaPlot);
    }
  }
  
  if (state.candlesHTF.length > 0) {
    const closesHTFAll = state.candlesHTF.map(x => x.close);
    state.emaHTF = calcEMA(closesHTFAll, 50);
    state.rsiHTF = calcRSI(closesHTFAll, 14);
  }
  
  state.series.setMarkers(state.markers);
  updateTimeDisplay();
}

// --- Add signal ---
function addSignal(sig) {
  try {
    state.signals.push(sig);
    saveSignals();
    
    const marker = {
      time: state.candles[state.candles.length - 1].time,
      position: sig.bias === 'BUY' ? 'belowBar' : 'aboveBar',
      color: sig.bias === 'BUY' ? '#22c55e' : '#ef4444',
      shape: sig.bias === 'BUY' ? 'arrowUp' : 'arrowDown',
      text: sig.bias
    };
    state.markers.push(marker);
    
    addSignalToLog(sig);
    document.getElementById('signalCount').textContent = `(${state.signals.length})`;
    
    updateCurrentSignal(sig.bias, sig.confidence);
    
    console.log(`üéØ SIGNAL GENERATED: ${sig.bias} at ${sig.time}`);
  } catch (error) {
    console.error('Error adding signal:', error);
  }
}

// --- STRICT SMC Signal Detection for All Assets ---
function detectSMC() {
  try {
    if (!state.candles || state.candles.length < 35 || !state.candlesHTF || state.candlesHTF.length < 15) {
      console.log('‚ùå Insufficient data for SMC detection');
      updateConditionStatus([{ name: 'Minimum data (35 candles 5m, 15 candles 15m)', met: false }]);
      updateCurrentSignal(null, 0);
      return;
    }

    const conditions = [];
    let allConditionsMet = true;

    const last20 = state.candles.slice(-20);
    const currentClose = last20[last20.length - 1].close;
    const currentHigh = last20[last20.length - 1].high;
    const currentLow = last20[last20.length - 1].low;

    const recentHigh = Math.max(...last20.slice(-10).map(c => c.high));
    const recentLow = Math.min(...last20.slice(-10).map(c => c.low));
    const volatility = (recentHigh - recentLow) / recentLow;
    
    const properties = assetProperties[state.pair] || { volatility: 0.01 };
    const minVolatility = state.pair.includes('Volatility') ? 0.003 : 0.001;
    const hasVolatility = volatility > minVolatility;
    
    conditions.push({ name: `Minimum volatility (${(minVolatility*100).toFixed(2)}%): ${(volatility * 100).toFixed(2)}%`, met: hasVolatility });
    if (!hasVolatility) allConditionsMet = false;

    const highs = last20.map(c => c.high);
    const lows = last20.map(c => c.low);
    
    const swingHighs = [];
    const swingLows = [];
    
    for (let i = 1; i < highs.length - 1; i++) {
      if (highs[i] > highs[i-1] && highs[i] > highs[i+1]) {
        swingHighs.push(highs[i]);
      }
      if (lows[i] < lows[i-1] && lows[i] < lows[i+1]) {
        swingLows.push(lows[i]);
      }
    }

    const hasMarketStructure = swingHighs.length >= 1 && swingLows.length >= 1;
    conditions.push({ name: `Market structure (min 1 swing)`, met: hasMarketStructure });
    if (!hasMarketStructure) allConditionsMet = false;

    const lastHTF = state.candlesHTF.slice(-5);
    const closesHTF = lastHTF.map(c => c.close);
    const dirHTF = closesHTF[closesHTF.length - 1] > closesHTF[0] ? 'BUY' : 'SELL';
    
    const recent5m = last20.slice(-5);
    const dir5m = recent5m[recent5m.length - 1].close > recent5m[0].close ? 'BUY' : 'SELL';
    
    const timeframeAligned = dir5m === dirHTF;
    conditions.push({ name: `Multi-timeframe alignment (5m: ${dir5m}, 15m: ${dirHTF})`, met: timeframeAligned });
    if (!timeframeAligned) allConditionsMet = false;

    let emaConditionsMet = true;
    if (state.filter) {
      const emaNow = state.ema[state.ema.length - 1];
      const emaHTFNow = state.emaHTF[state.emaHTF.length - 1];
      const rsiNow = state.rsi[state.rsi.length - 1];
      const rsiHTFNow = state.rsiHTF[state.rsiHTF.length - 1];
      
      if (!emaNow || !emaHTFNow || !rsiNow || !rsiHTFNow) {
        emaConditionsMet = false;
      } else {
        const emaCondition = dir5m === 'BUY' ? 
          (currentClose > emaNow && currentClose > emaHTFNow) : 
          (currentClose < emaNow && currentClose < emaHTFNow);
        
        const rsiCondition = dir5m === 'BUY' ? 
          (rsiNow > 45 && rsiNow < 75 && rsiHTFNow > 45 && rsiHTFNow < 75) :
          (rsiNow < 55 && rsiNow > 25 && rsiHTFNow < 55 && rsiHTFNow > 25);
        
        emaConditionsMet = emaCondition && rsiCondition;
        
        conditions.push({ 
          name: `EMA alignment (Price ${dir5m === 'BUY' ? 'above' : 'below'} EMA)`, 
          met: emaCondition 
        });
        conditions.push({ 
          name: `RSI conditions (5m: ${rsiNow.toFixed(1)}, 15m: ${rsiHTFNow.toFixed(1)})`, 
          met: rsiCondition 
        });
      }
      
      if (!emaConditionsMet) allConditionsMet = false;
    }

    const range = recentHigh - recentLow;
    const retracementLevel = (currentClose - recentLow) / range;
    const validRetracement = retracementLevel >= 0.35 && retracementLevel <= 0.65;
    conditions.push({ name: `Valid retracement (${(retracementLevel * 100).toFixed(1)}% of range)`, met: validRetracement });
    if (!validRetracement) allConditionsMet = false;

    const prevSlice = last20.slice(-15, -5);
    const previousHigh = prevSlice.length > 0 ? Math.max(...prevSlice.map(c => c.high)) : currentHigh;
    const previousLow = prevSlice.length > 0 ? Math.min(...prevSlice.map(c => c.low)) : currentLow;
    
    let hasBreakout = false;
    let bias = null;
    let reason = '';
    
    if (dir5m === 'BUY' && currentHigh > previousHigh) {
      hasBreakout = true;
      bias = 'BUY';
      reason = 'Break of Structure + Bullish Momentum';
    } else if (dir5m === 'SELL' && currentLow < previousLow) {
      hasBreakout = true;
      bias = 'SELL';
      reason = 'Break of Structure + Bearish Momentum';
    }
    
    conditions.push({ name: `Breakout confirmation`, met: hasBreakout });
    if (!hasBreakout) allConditionsMet = false;

    updateConditionStatus(conditions);

    if (allConditionsMet && bias) {
      const properties = assetProperties[state.pair] || { volatility: 0.1 };
      const baseVolatility = properties.volatility;
      
      const sl = bias === 'BUY' ? recentLow - range * 0.15 : recentHigh + range * 0.15;
      const tp = bias === 'BUY' ? currentClose + range * 1.5 : currentClose - range * 1.5;
      
      let confidence = 70;
      if (volatility > baseVolatility * 0.8) confidence += 10;
      if (timeframeAligned) confidence += 10;
      if (validRetracement && retracementLevel >= 0.4 && retracementLevel <= 0.6) confidence += 10;
      
      const sig = {
        pair: state.pair,
        bias,
        entry: currentClose,
        tp: tp,
        sl: sl,
        reason: `${reason} + Multi-Timeframe${state.filter ? ' + EMA+RSI' : ''}`,
        confidence: Math.min(confidence, 95),
        time: new Date().toLocaleTimeString()
      };
      
      if (Date.now() - state.lastSignalTime > 90000) {
        state.lastSignalTime = Date.now();
        state.currentBias = bias;
        addSignal(sig);
        console.log('üéØ ALL CONDITIONS MET - SIGNAL GENERATED!', sig);
      } else {
        console.log('‚è≥ Signal cooldown active');
      }
    } else {
      console.log('‚ùå Conditions not met for signal generation');
      console.log('Failed conditions:', conditions.filter(c => !c.met).map(c => c.name));
      updateCurrentSignal(null, 0);
      state.currentBias = null;
    }
    
  } catch (error) {
    console.error('Error in SMC detection:', error);
    updateConditionStatus([{ name: 'Error in detection logic', met: false }]);
    updateCurrentSignal(null, 0);
  }
}

// --- Deriv WS Helper Functions ---
async function sendDerivRequest(request) {
  return new Promise((resolve, reject) => {
    const reqId = state.nextReqId++;
    state.pendingResponses[reqId] = { resolve, reject };
    state.wsDeriv.send(JSON.stringify({ ...request, req_id: reqId }));
    // Timeout after 10s
    setTimeout(() => {
      if (state.pendingResponses[reqId]) {
        delete state.pendingResponses[reqId];
        reject(new Error('Request timeout'));
      }
    }, 10000);
  });
}

function connectDerivWS() {
  const ws = new WebSocket('wss://ws.derivws.com/websockets/v3?app_id=1089'); // Demo public app_id
  
  ws.onopen = () => {
    console.log('Connected to Deriv WS');
  };
  
  ws.onmessage = (event) => {
    try {
      const msg = JSON.parse(event.data);
      const reqId = msg.req_id;
      if (reqId && state.pendingResponses[reqId]) {
        state.pendingResponses[reqId].resolve(msg);
        delete state.pendingResponses[reqId];
      }
      
      // Handle live candle updates
      if (msg.msg_type === 'candles' && msg.subscribe === 1 && msg.candle) {
        const candle = {
          time: msg.candle.epoch,
          open: parseFloat(msg.candle.open),
          high: parseFloat(msg.candle.high),
          low: parseFloat(msg.candle.low),
          close: parseFloat(msg.candle.close),
          volume: 0 // Not provided
        };
        
        if (msg.granularity === 300) {
          state.candles.push(candle);
          if (state.candles.length > 200) state.candles.shift();
        } else if (msg.granularity === 900) {
          state.candlesHTF.push(candle);
          if (state.candlesHTF.length > 100) state.candlesHTF.shift();
        }
        
        updateChart();
        
        if (state.auto && state.candles.length > 35 && state.candlesHTF.length > 15) {
          detectSMC();
        }
      }
    } catch (error) {
      console.error('Deriv WS message error:', error);
    }
  };
  
  ws.onclose = () => {
    console.log('Deriv WS closed');
  };
  
  ws.onerror = (error) => {
    console.error('Deriv WS error:', error);
  };
  
  return ws;
}

// --- Load Historical Data ---
async function loadHistoricalData(pair, timeframe, limit = 100) {
  try {
    document.getElementById('loadingIndicator').style.display = 'block';
    
    const isBinance = state.binancePairs.includes(pair);
    const isDeriv = state.derivPairs.includes(pair);
    
    if (isBinance) {
      const symbol = pair === 'BTCUSD' ? 'BTCUSDT' : pair.replace('/', '');
      const interval = timeframe === 5 ? '5m' : '15m';
      const url = `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
      const res = await fetch(url);
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const data = await res.json();
      const candles = data.map(k => ({
        time: Math.floor(k[0] / 1000),
        open: parseFloat(k[1]),
        high: parseFloat(k[2]),
        low: parseFloat(k[3]),
        close: parseFloat(k[4]),
        volume: parseFloat(k[5])
      }));
      console.log(`Loaded ${candles.length} real candles for ${pair} ${interval}`);
      document.getElementById('loadingIndicator').style.display = 'none';
      return candles;
    }
    
    if (isDeriv) {
      const symbol = getDerivSymbol(pair);
      const granularity = timeframe * 60; // seconds
      const request = {
        candles: symbol,
        granularity: granularity,
        count: limit,
        end: 'latest',
        style: 'candles',
        subscribe: 0
      };
      const response = await sendDerivRequest(request);
      if (response.candles) {
        const candles = response.candles.map(c => ({
          time: c.epoch,
          open: parseFloat(c.open),
          high: parseFloat(c.high),
          low: parseFloat(c.low),
          close: parseFloat(c.close),
          volume: 0
        })).reverse(); // Deriv returns oldest first
        console.log(`Loaded ${candles.length} Deriv candles for ${pair} ${timeframe}m`);
        document.getElementById('loadingIndicator').style.display = 'none';
        return candles;
      } else {
        throw new Error('No candles in response');
      }
    }
    
    // Simulation for unsupported pairs
    const candles = [];
    const properties = assetProperties[pair] || { basePrice: 1.0, volatility: 0.01, trendStrength: 0.001, decimals: 5 };
    const { basePrice, volatility, trendStrength, decimals } = properties;
    
    let currentTime = getCurrentCandleTime(timeframe) - (limit * timeframe * 60);
    let lastClose = basePrice;
    
    let trend = trendStrength;
    let jumpProbability = pair.includes('Jump') ? 0.1 : 0.02;
    let crashBoomProbability = (pair.includes('Boom') || pair.includes('Crash')) ? 0.05 : 0.01;
    let stepProbability = pair.includes('Step') ? 0.05 : 0.01; // Small steps for Step indices
    
    for (let i = 0; i < limit; i++) {
      let change;
      
      if (pair.includes('Boom') && Math.random() < crashBoomProbability) {
        change = volatility * 3 * lastClose;
      } else if (pair.includes('Crash') && Math.random() < crashBoomProbability) {
        change = -volatility * 3 * lastClose;
      } else if (pair.includes('Jump') && Math.random() < jumpProbability) {
        change = (Math.random() - 0.5) * volatility * 5 * lastClose;
      } else if (pair.includes('Step')) {
        // Fixed step size based on pair
        const stepSize = pair.includes('100') ? 0.1 : pair.includes('400') ? 0.4 : pair.includes('500') ? 0.5 : 0.1;
        change = (Math.random() > 0.5 ? stepSize : -stepSize) * lastClose * 0.01; // Scaled
      } else {
        change = (Math.random() - 0.5 + trend) * volatility * lastClose;
      }
      
      const open = lastClose;
      const close = open + change;
      const high = Math.max(open, close) + Math.random() * volatility * lastClose * 0.5;
      const low = Math.min(open, close) - Math.random() * volatility * lastClose * 0.5;
      
      candles.push({
        time: currentTime,
        open: parseFloat(open.toFixed(decimals)),
        high: parseFloat(high.toFixed(decimals)),
        low: parseFloat(low.toFixed(decimals)),
        close: parseFloat(close.toFixed(decimals)),
        volume: pair.includes('Index') ? 10000 + Math.random() * 50000 : 1000 + Math.random() * 5000
      });
      
      lastClose = close;
      currentTime += timeframe * 60;
    }
    
    document.getElementById('loadingIndicator').style.display = 'none';
    return candles;
    
  } catch (error) {
    console.error('Error loading historical data:', error);
    document.getElementById('loadingIndicator').style.display = 'none';
    return [];
  }
}

// --- Binance WS Connection ---
function connectBinanceWS(tf) {
  if (!state.binancePairs.includes(state.pair)) return null;
  
  const symbol = state.pair === 'BTCUSD' ? 'btcusdt' : state.pair.toLowerCase().replace('/', '');
  const interval = tf === 5 ? '5m' : '15m';
  const wsUrl = `wss://stream.binance.com:9443/ws/${symbol}@kline_${interval}`;
  
  const ws = new WebSocket(wsUrl);
  
  ws.onopen = () => {
    console.log(`Connected to ${interval} Binance WS for ${state.pair}`);
  };
  
  ws.onmessage = (event) => {
    try {
      const kline = JSON.parse(event.data);
      if (kline.k && kline.k.x) { // Candle closed
        const candle = {
          time: Math.floor(kline.k.t / 1000),
          open: parseFloat(kline.k.o),
          high: parseFloat(kline.k.h),
          low: parseFloat(kline.k.l),
          close: parseFloat(kline.k.c),
          volume: parseFloat(kline.k.v)
        };
        
        if (tf === 5) {
          state.candles.push(candle);
          if (state.candles.length > 200) state.candles.shift();
        } else {
          state.candlesHTF.push(candle);
          if (state.candlesHTF.length > 100) state.candlesHTF.shift();
        }
        
        updateChart();
        
        if (state.auto && state.candles.length > 35 && state.candlesHTF.length > 15) {
          detectSMC();
        }
      }
    } catch (error) {
      console.error('Binance WS message error:', error);
    }
  };
  
  ws.onclose = () => {
    console.log(`${interval} Binance WS closed for ${state.pair}`);
  };
  
  ws.onerror = (error) => {
    console.error(`${interval} Binance WS error for ${state.pair}:`, error);
  };
  
  return ws;
}

// --- Real-Time Synchronized Data Simulation (for unsupported pairs) ---
function startLiveDataSimulation() {
  if (state.liveUpdateInterval) {
    clearInterval(state.liveUpdateInterval);
  }
  
  if (state.timeSyncInterval) {
    clearInterval(state.timeSyncInterval);
  }
  
  state.timeSyncInterval = setInterval(updateTimeDisplay, 1000);
  
  state.liveUpdateInterval = setInterval(() => {
    if (state.candles.length > 0) {
      const now = getCurrentCandleTime(5);
      const lastCandle = state.candles[state.candles.length - 1];
      const properties = assetProperties[state.pair] || { volatility: 0.01, trendStrength: 0.001 };
      
      if (now > lastCandle.time) {
        let change;
        const volatility = properties.volatility;
        const trend = properties.trendStrength;
        
        if (state.pair.includes('Boom') && Math.random() < 0.03) {
          change = volatility * 2 * lastCandle.close;
        } else if (state.pair.includes('Crash') && Math.random() < 0.03) {
          change = -volatility * 2 * lastCandle.close;
        } else if (state.pair.includes('Jump') && Math.random() < 0.08) {
          change = (Math.random() - 0.5) * volatility * 4 * lastCandle.close;
        } else if (state.pair.includes('Step')) {
          const stepSize = state.pair.includes('100') ? 0.1 : state.pair.includes('400') ? 0.4 : state.pair.includes('500') ? 0.5 : 0.1;
          change = (Math.random() > 0.5 ? stepSize : -stepSize) * lastCandle.close * 0.01;
        } else {
          change = (Math.random() - 0.5 + trend) * volatility * lastCandle.close;
        }
        
        const newCandle = {
          time: now,
          open: lastCandle.close,
          close: lastCandle.close + change,
          high: Math.max(lastCandle.close, lastCandle.close + change) + Math.random() * volatility * lastCandle.close,
          low: Math.min(lastCandle.close, lastCandle.close + change) - Math.random() * volatility * lastCandle.close,
          volume: state.pair.includes('Index') ? 10000 + Math.random() * 50000 : 1000 + Math.random() * 5000
        };
        
        state.candles.push(newCandle);
        if (state.candles.length > 200) state.candles.shift();
        
        if (state.candles.length % 3 === 0 && state.candlesHTF.length > 0) {
          const lastHTF = state.candlesHTF[state.candlesHTF.length - 1];
          const recent5m = state.candles.slice(-3);
          
          const newHTFCandle = {
            time: getCurrentCandleTime(15),
            open: lastHTF.close,
            close: newCandle.close,
            high: Math.max(lastHTF.high, ...recent5m.map(c => c.high)),
            low: Math.min(lastHTF.low, ...recent5m.map(c => c.low)),
            volume: recent5m.reduce((sum, c) => sum + c.volume, 0)
          };
          
          state.candlesHTF.push(newHTFCandle);
          if (state.candlesHTF.length > 100) state.candlesHTF.shift();
        }
        
        updateChart();
        
        console.log(`üïí New 5m candle created at ${new Date(now * 1000).toLocaleTimeString()}`);
      }
    }
  }, 1000);
}

// --- Connect to Data Feeds ---
document.getElementById('connectFeed').onclick = async () => {
  try {
    const pair = document.getElementById('pairSelect').value;
    state.pair = pair;
    
    state.candles = [];
    state.candlesHTF = [];
    state.markers = [];
    state.signals = [];
    state.currentBias = null;
    state.pendingResponses = {};
    state.nextReqId = 1;
    document.getElementById('signalLog').innerHTML = '';
    document.getElementById('signalCount').textContent = '(0)';
    updateCurrentSignal(null, 0);
    
    document.getElementById('connectionStatus').textContent = 'Loading...';
    document.getElementById('connectionStatus').className = 'connecting';
    
    const historical5m = await loadHistoricalData(pair, 5, 100);
    const historical15m = await loadHistoricalData(pair, 15, 50);
    
    state.candles = historical5m;
    state.candlesHTF = historical15m;
    
    updateChart();
    
    loadSignals();
    
    const isBinance = state.binancePairs.includes(pair);
    const isDeriv = state.derivPairs.includes(pair);
    
    if (isBinance) {
      state.wsBinance5m = connectBinanceWS(5);
      state.wsBinance15m = connectBinanceWS(15);
      document.getElementById('feed5mStatus').textContent = 'üî¥ Live (Binance)';
      document.getElementById('feed15mStatus').textContent = 'üî¥ Live (Binance)';
      document.getElementById('feed5mStatus').className = 'connected';
      document.getElementById('feed15mStatus').className = 'connected';
      console.log(`Using Binance feeds for ${pair}`);
    } else if (isDeriv) {
      state.wsDeriv = connectDerivWS();
      // Wait for connection
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      // Subscribe to live candles
      const symbol = getDerivSymbol(pair);
      await sendDerivRequest({
        candles: symbol,
        granularity: 300,
        subscribe: 1
      });
      await sendDerivRequest({
        candles: symbol,
        granularity: 900,
        subscribe: 1
      });
      
      document.getElementById('feed5mStatus').textContent = 'üî¥ Live (Deriv)';
      document.getElementById('feed15mStatus').textContent = 'üî¥ Live (Deriv)';
      document.getElementById('feed5mStatus').className = 'connected';
      document.getElementById('feed15mStatus').className = 'connected';
      console.log(`Using Deriv feeds for ${pair}`);
    } else {
      startLiveDataSimulation();
      document.getElementById('feed5mStatus').textContent = 'üü¢ Simulated';
      document.getElementById('feed15mStatus').textContent = 'üü¢ Simulated';
      document.getElementById('feed5mStatus').className = 'connected';
      document.getElementById('feed15mStatus').className = 'connected';
      console.log(`Using simulated feeds for ${pair}`);
    }
    
    document.getElementById('connectionStatus').textContent = `Connected (${pair})`;
    document.getElementById('connectionStatus').className = 'connected';
    
  } catch (error) {
    console.error('Connection error:', error);
    document.getElementById('connectionStatus').textContent = 'Connection Failed';
    document.getElementById('connectionStatus').className = 'disconnected';
  }
};

// --- Disconnect feeds ---
document.getElementById('disconnectFeed').onclick = () => {
  if (state.liveUpdateInterval) {
    clearInterval(state.liveUpdateInterval);
    state.liveUpdateInterval = null;
  }
  if (state.timeSyncInterval) {
    clearInterval(state.timeSyncInterval);
    state.timeSyncInterval = null;
  }
  
  if (state.wsBinance5m) {
    state.wsBinance5m.close();
    state.wsBinance5m = null;
  }
  if (state.wsBinance15m) {
    state.wsBinance15m.close();
    state.wsBinance15m = null;
  }
  if (state.wsDeriv) {
    // Unsubscribe
    const symbol = getDerivSymbol(state.pair);
    sendDerivRequest({ candles: symbol, granularity: 300, subscribe: 0 }).catch(() => {});
    sendDerivRequest({ candles: symbol, granularity: 900, subscribe: 0 }).catch(() => {});
    state.wsDeriv.close();
    state.wsDeriv = null;
  }
  
  document.getElementById('connectionStatus').textContent = 'Disconnected';
  document.getElementById('connectionStatus').className = 'disconnected';
  document.getElementById('feed5mStatus').textContent = '‚ùå';
  document.getElementById('feed5mStatus').className = 'disconnected';
  document.getElementById('feed15mStatus').textContent = '‚ùå';
  document.getElementById('feed15mStatus').className = 'disconnected';
  updateCurrentSignal(null, 0);
  state.markers = [];
};

// --- Manual signal generation ---
document.getElementById('generateSignal').onclick = () => {
  console.log('Manual signal generation triggered');
  detectSMC();
};

// --- Clear log ---
document.getElementById('clearSignals').onclick = () => {
  document.getElementById('signalLog').innerHTML = '';
  state.signals = [];
  state.markers = [];
  document.getElementById('signalCount').textContent = '(0)';
  localStorage.removeItem('smcSignals');
  state.series.setMarkers([]);
};

// --- Auto Mode toggle ---
document.getElementById('autoMode').onchange = (e) => {
  state.auto = e.target.checked;
  console.log('Auto mode:', state.auto ? 'ON' : 'OFF');
};
document.getElementById('filterMode').onchange = (e) => {
  state.filter = e.target.checked;
  console.log('Filter mode:', state.filter ? 'ON' : 'OFF');
};

// --- Auto-connect on page load ---
window.addEventListener('load', () => {
  setTimeout(() => {
    document.getElementById('connectFeed').click();
  }, 1000);
});

// --- Cleanup on page unload ---
window.addEventListener('beforeunload', () => {
  if (state.liveUpdateInterval) clearInterval(state.liveUpdateInterval);
  if (state.timeSyncInterval) clearInterval(state.timeSyncInterval);
  if (state.wsBinance5m) state.wsBinance5m.close();
  if (state.wsBinance15m) state.wsBinance15m.close();
  if (state.wsDeriv) state.wsDeriv.close();
});
</script>
</body>
</html>
