<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>TradeSignal Pro - Stable Market Analysis</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html{height:100%}
body{font-family:system-ui,sans-serif;background:#0f172a;color:#f1f5f9;padding:16px;min-height:100%;-webkit-tap-highlight-color:transparent}
.container{max-width:100%;margin:0 auto;padding-bottom:20px}
.header{text-align:center;margin-bottom:16px}
h1{font-size:clamp(18px, 5vw, 22px);color:#3b82f6;margin-bottom:6px}
.risk-warning{background:#7f1d1d20;border:1px solid #ef444440;border-radius:10px;padding:10px;margin-bottom:16px;font-size:clamp(11px, 3vw, 12px);color:#fca5a5;text-align:center;line-height:1.4}
.card{background:#1e293b;border-radius:14px;padding:16px;margin-bottom:16px;box-shadow:0 4px 12px rgba(0,0,0,0.2)}
.form-group{margin-bottom:12px}
label{display:block;margin-bottom:4px;color:#cbd5e1;font-size:clamp(13px, 3.5vw, 14px)}
select{width:100%;padding:12px;background:#0f172a;border:1px solid #475569;border-radius:8px;color:white;font-size:clamp(14px, 4vw, 16px);appearance:none;-webkit-appearance:none;cursor:pointer}
select:focus{outline:none;border-color:#3b82f6}
.signal-box{padding:20px;text-align:center;border-radius:12px;font-size:clamp(20px, 8vw, 32px);font-weight:700;margin:16px 0;transition:all 0.5s ease;touch-action:manipulation}
.buy{background:linear-gradient(135deg,#052e16,#14532d);color:#22c55e;border:2px solid rgba(34,197,94,0.3)}
.sell{background:linear-gradient(135deg,#450a0a,#7f1d1d);color:#ef4444;border:2px solid rgba(239,68,68,0.3)}
.neutral{background:linear-gradient(135deg,#1e293b,#334155);color:#94a3b8;border:2px solid rgba(148,163,184,0.3)}
.strong-buy{background:linear-gradient(135deg,#064e3b,#047857);color:#34d399;border:2px solid rgba(52,211,153,0.4);animation:pulse-green 2s infinite}
.strong-sell{background:linear-gradient(135deg,#7c2d12,#c2410c);color:#fb923c;border:2px solid rgba(251,146,60,0.4);animation:pulse-red 2s infinite}
@keyframes pulse-green{0%,100%{box-shadow:0 0 20px rgba(52,211,153,0.3)}50%{box-shadow:0 0 30px rgba(52,211,153,0.6)}}
@keyframes pulse-red{0%,100%{box-shadow:0 0 20px rgba(251,146,60,0.3)}50%{box-shadow:0 0 30px rgba(251,146,60,0.6)}}
.status{text-align:center;font-size:clamp(12px, 3.5vw, 13px);color:#94a3b8;min-height:50px;line-height:1.4;padding:4px 0}
.footer{text-align:center;margin-top:20px;font-size:clamp(11px, 3vw, 12px);color:#64748b;line-height:1.4}
.indicators-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-top:16px}
.indicator{background:#0f172a;padding:10px;border-radius:8px;text-align:center}
.indicator-label{font-size:clamp(10px, 2.5vw, 11px);color:#94a3b8;margin-bottom:6px}
.indicator-value{font-size:clamp(13px, 4vw, 14px);font-weight:600}
.signal-stability{background:#0f172a;border-radius:10px;padding:12px;margin-top:12px}
.stability-bar{height:6px;background:#334155;border-radius:3px;margin-top:8px;overflow:hidden}
.stability-fill{height:100%;border-radius:3px;transition:width 1s ease}
.stability-high{background:linear-gradient(90deg,#10b981,#34d399)}
.stability-medium{background:linear-gradient(90deg,#f59e0b,#fbbf24)}
.stability-low{background:linear-gradient(90deg,#ef4444,#f87171)}
.confirmation-indicators{display:grid;grid-template-columns:repeat(4,1fr);gap:6px;margin-top:12px}
.confirmation-indicator{padding:8px;border-radius:6px;text-align:center;font-size:clamp(10px, 2.5vw, 11px)}
.confirmation-active{background:#14532d30;color:#22c55e;border:1px solid #22c55e30}
.confirmation-inactive{background:#33415530;color:#94a3b8;border:1px solid #47556930}

/* New Features Styles */
.session-info{display:flex;justify-content:space-between;margin-bottom:12px;padding:8px 12px;background:#0f172a;border-radius:8px;font-size:clamp(11px, 3vw, 12px)}
.session-timer{color:#60a5fa;font-weight:600}
.break-warning{color:#fbbf24;animation:pulse-warning 2s infinite}
.timeframe-grid{display:grid;grid-template-columns:repeat(5,1fr);gap:4px;margin:12px 0}
.timeframe-btn{padding:8px 4px;border-radius:6px;background:#0f172a;border:1px solid #334155;color:#cbd5e1;font-size:clamp(10px, 2.5vw, 11px);text-align:center;cursor:pointer;transition:all 0.2s;touch-action:manipulation}
.timeframe-btn:hover,.timeframe-btn:active{background:#1e40af}
.timeframe-btn.active{background:#3b82f6;color:white;border-color:#3b82f6;font-weight:600}
.multi-tf-indicator{background:#0f172a;padding:10px;border-radius:8px;margin-top:12px}
.multi-tf-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
.multi-tf-header h3{font-size:clamp(12px, 3vw, 13px);color:#cbd5e1}
.confluence-score{background:#3b82f6;color:white;padding:2px 8px;border-radius:12px;font-size:clamp(10px, 2.5vw, 11px);font-weight:600}
.multi-tf-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:6px}
.multi-tf-item{padding:8px;background:#1e293b;border-radius:6px;text-align:center}
.multi-tf-label{font-size:clamp(9px, 2.5vw, 10px);color:#94a3b8;margin-bottom:2px}
.multi-tf-value{font-size:clamp(11px, 3vw, 12px);font-weight:600}
.multi-tf-buy{color:#22c55e}
.multi-tf-sell{color:#ef4444}
.multi-tf-neutral{color:#94a3b8}
.break-alert{position:fixed;top:20px;left:50%;transform:translateX(-50%);background:#dc2626;color:white;padding:12px 20px;border-radius:10px;z-index:1000;box-shadow:0 4px 20px rgba(220,38,38,0.3);animation:slideDown 0.3s ease}
@keyframes slideDown{from{transform:translate(-50%,-20px);opacity:0}to{transform:translate(-50%,0);opacity:1}}
@keyframes pulse-warning{0%,100%{opacity:1}50%{opacity:0.7}}

/* Mobile-specific optimizations */
@media (max-width: 480px) {
    body{padding:12px}
    .card{padding:14px;border-radius:12px}
    .signal-box{padding:16px;margin:12px 0;font-size:24px}
    select{padding:14px}
    .timeframe-btn{padding:10px 4px}
    .confirmation-indicator{padding:10px 4px}
    .indicator{padding:12px 8px}
}

@media (max-width: 360px) {
    body{padding:10px}
    .card{padding:12px}
    .signal-box{font-size:20px}
    .timeframe-grid{grid-template-columns:repeat(3,1fr)}
    .multi-tf-grid{grid-template-columns:repeat(2,1fr)}
}

/* Prevent text selection on interactive elements */
.timeframe-btn, .signal-box{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
</style>
</head>
<body>
<div class="container">
  <!-- Session Timer -->
  <div class="session-info">
    <div>Session: <span id="sessionTimer" class="session-timer">00:00:00</span></div>
    <div id="breakWarning" class="break-warning" style="display:none;">‚ö† Take a break!</div>
  </div>
  
  <div class="header">
    <h1>TradeSignal Pro</h1>
    <div style="font-size:clamp(13px, 3.5vw, 14px);color:#94a3b8;">Stable Signal Analysis</div>
  </div>
  
  <div class="risk-warning">
    ‚ö† Educational Tool Only - Not financial advice. Use at your own risk.
  </div>
  
  <div class="card">
    <div class="form-group">
      <label>Market Pair</label>
      <select id="pair">
        <option value="EURUSD">EUR/USD</option>
        <option value="GBPUSD">GBP/USD</option>
        <option value="USDJPY">USD/JPY</option>
        <option value="XAUUSD">Gold (XAU/USD)</option>
        <option value="BTCUSD">Bitcoin (BTC/USD)</option>
        <option value="US30">US30 Index</option>
      </select>
    </div>
    
    <!-- Multi-Timeframe Selection -->
    <div class="form-group">
      <label>Primary Timeframe</label>
      <select id="timeframe">
        <option value="15m">15 Minutes</option>
        <option value="30m">30 Minutes</option>
        <option value="1h">1 Hour</option>
        <option value="4h">4 Hours</option>
        <option value="1d">1 Day</option>
      </select>
    </div>
    
    <!-- Multi-Timeframe Quick Select -->
    <div class="timeframe-grid">
      <div class="timeframe-btn active" data-tf="15m">15M</div>
      <div class="timeframe-btn" data-tf="30m">30M</div>
      <div class="timeframe-btn" data-tf="1h">1H</div>
      <div class="timeframe-btn" data-tf="4h">4H</div>
      <div class="timeframe-btn" data-tf="1d">1D</div>
    </div>
    
    <div id="signal" class="signal-box neutral">
      ANALYZING
    </div>
    
    <div id="status" class="status">
      Initializing stable signal analysis...
    </div>
    
    <!-- Multi-Timeframe Confluence Indicator -->
    <div class="multi-tf-indicator">
      <div class="multi-tf-header">
        <h3>Multi-Timeframe Analysis</h3>
        <div id="confluenceScore" class="confluence-score">-</div>
      </div>
      <div class="multi-tf-grid" id="multiTfGrid">
        <!-- Will be populated by JavaScript -->
      </div>
    </div>
    
    <div class="signal-stability">
      <div style="display:flex;justify-content:space-between;font-size:clamp(11px, 3vw, 12px)">
        <span>Signal Stability</span>
        <span id="stabilityValue">Calculating...</span>
      </div>
      <div class="stability-bar">
        <div id="stabilityFill" class="stability-fill" style="width:0%"></div>
      </div>
    </div>
    
    <div class="confirmation-indicators">
      <div id="confTrend" class="confirmation-indicator confirmation-inactive">TREND ‚úì</div>
      <div id="confRSI" class="confirmation-indicator confirmation-inactive">RSI ‚úì</div>
      <div id="confVol" class="confirmation-indicator confirmation-inactive">VOL ‚úì</div>
      <div id="confMomentum" class="confirmation-indicator confirmation-inactive">MOM ‚úì</div>
    </div>
    
    <div class="indicators-grid">
      <div class="indicator">
        <div class="indicator-label">RSI (14)</div>
        <div id="rsiValue" class="indicator-value">-</div>
      </div>
      <div class="indicator">
        <div class="indicator-label">Trend</div>
        <div id="trendValue" class="indicator-value">-</div>
      </div>
      <div class="indicator">
        <div class="indicator-label">Strength</div>
        <div id="strengthValue" class="indicator-value">-</div>
      </div>
    </div>
  </div>
  
  <div class="footer">
    TradeSignal Pro v3.1 | Enhanced with Session Timer & Multi-TF<br>
    <div style="margin-top:8px;font-size:clamp(10px, 2.5vw, 11px);color:#64748b;">
      ‚ö† Educational Tool Only | Optimized for Mobile
    </div>
  </div>
</div>

<script>
// ==================== SESSION TIMER ====================
class SessionTimer {
  constructor() {
    this.startTime = Date.now();
    this.breakIntervals = [1800000, 3600000, 7200000]; // 30min, 1hr, 2hr
    this.nextBreakIndex = 0;
    this.breakAlertShown = false;
  }
  
  getElapsedTime() {
    return Date.now() - this.startTime;
  }
  
  formatTime(ms) {
    const hours = Math.floor(ms / 3600000);
    const minutes = Math.floor((ms % 3600000) / 60000);
    const seconds = Math.floor((ms % 60000) / 1000);
    
    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
  }
  
  checkBreakTime() {
    const elapsed = this.getElapsedTime();
    
    if (this.nextBreakIndex < this.breakIntervals.length && 
        elapsed >= this.breakIntervals[this.nextBreakIndex] && 
        !this.breakAlertShown) {
      
      this.showBreakAlert();
      this.nextBreakIndex++;
      this.breakAlertShown = true;
      
      // Reset alert after 30 seconds
      setTimeout(() => {
        this.breakAlertShown = false;
        document.getElementById('breakWarning').style.display = 'none';
      }, 30000);
      
      return true;
    }
    
    // Check if approaching break time (5 minutes before)
    if (this.nextBreakIndex < this.breakIntervals.length) {
      const nextBreak = this.breakIntervals[this.nextBreakIndex];
      const timeToBreak = nextBreak - elapsed;
      
      if (timeToBreak > 0 && timeToBreak <= 300000) { // 5 minutes
        document.getElementById('breakWarning').style.display = 'block';
        document.getElementById('breakWarning').textContent = `Break in ${Math.ceil(timeToBreak / 60000)}min`;
      } else {
        document.getElementById('breakWarning').style.display = 'none';
      }
    }
    
    return false;
  }
  
  showBreakAlert() {
    const alertDiv = document.createElement('div');
    alertDiv.className = 'break-alert';
    alertDiv.innerHTML = `
      ‚ö† Session Break Recommended<br>
      <small>You've been trading for ${this.nextBreakIndex === 1 ? '30 minutes' : this.nextBreakIndex === 2 ? '1 hour' : '2 hours'}</small>
    `;
    document.body.appendChild(alertDiv);
    
    setTimeout(() => {
      alertDiv.remove();
    }, 5000);
  }
  
  updateDisplay() {
    const elapsed = this.getElapsedTime();
    document.getElementById('sessionTimer').textContent = this.formatTime(elapsed);
    this.checkBreakTime();
  }
}

// ==================== MULTI-TIMEFRAME ANALYSIS ====================
class MultiTimeframeAnalyzer {
  constructor() {
    this.timeframes = ['15m', '30m', '1h', '4h', '1d'];
    this.timeframeData = {};
    
    // Initialize data for all timeframes
    this.timeframes.forEach(tf => {
      this.timeframeData[tf] = {
        signal: 'NEUTRAL',
        rsi: 50,
        trend: 'NEUTRAL',
        confidence: 50
      };
    });
  }
  
  generateTimeframeData(pair, primaryTF) {
    // Generate different signals for each timeframe
    const pairVolatility = signalEngine.marketData[pair].volatility;
    
    this.timeframes.forEach(tf => {
      const basePrice = signalEngine.marketData[pair].price;
      
      // Different behavior based on timeframe
      let volatilityMultiplier = 1;
      switch(tf) {
        case '15m': volatilityMultiplier = 0.8; break;
        case '30m': volatilityMultiplier = 0.9; break;
        case '1h': volatilityMultiplier = 1.0; break;
        case '4h': volatilityMultiplier = 1.2; break;
        case '1d': volatilityMultiplier = 1.5; break;
      }
      
      // Simulate different RSI values per timeframe
      const baseRSI = signalEngine.marketData[pair].rsi;
      const rsiVariation = (Math.random() - 0.5) * 20;
      const timeframeRSI = Math.max(0, Math.min(100, baseRSI + rsiVariation));
      
      // Determine signal based on RSI and volatility
      let signal = 'NEUTRAL';
      let confidence = 50;
      
      if (timeframeRSI > 70) {
        signal = 'SELL';
        confidence = 60 + (timeframeRSI - 70) * 2;
      } else if (timeframeRSI < 30) {
        signal = 'BUY';
        confidence = 60 + (30 - timeframeRSI) * 2;
      } else if (timeframeRSI > 55 && timeframeRSI < 70) {
        signal = Math.random() > 0.3 ? 'BUY' : 'NEUTRAL';
        confidence = 40 + (timeframeRSI - 55);
      } else if (timeframeRSI > 30 && timeframeRSI < 45) {
        signal = Math.random() > 0.3 ? 'SELL' : 'NEUTRAL';
        confidence = 40 + (45 - timeframeRSI);
      }
      
      // Adjust confidence based on timeframe (higher timeframes = more reliable)
      if (tf === '4h' || tf === '1d') {
        confidence *= 1.2;
      }
      
      // Trend determination
      let trend = 'NEUTRAL';
      if (timeframeRSI > 60) trend = 'BULLISH';
      if (timeframeRSI < 40) trend = 'BEARISH';
      
      this.timeframeData[tf] = {
        signal,
        rsi: Math.round(timeframeRSI * 10) / 10,
        trend,
        confidence: Math.min(100, Math.round(confidence))
      };
    });
    
    return this.timeframeData;
  }
  
  calculateConfluence() {
    const signals = {};
    let totalWeight = 0;
    let weightedSum = 0;
    
    this.timeframes.forEach((tf, index) => {
      const data = this.timeframeData[tf];
      const weight = this.getTimeframeWeight(tf);
      
      if (!signals[data.signal]) {
        signals[data.signal] = 0;
      }
      signals[data.signal] += weight;
      totalWeight += weight;
      
      // Use confidence in weighted calculation
      weightedSum += (data.confidence / 100) * weight;
    });
    
    // Determine primary signal (most weighted)
    let primarySignal = 'NEUTRAL';
    let maxWeight = 0;
    
    Object.keys(signals).forEach(signal => {
      if (signals[signal] > maxWeight) {
        maxWeight = signals[signal];
        primarySignal = signal;
      }
    });
    
    // Calculate confluence score (0-100)
    const confluenceScore = Math.round((weightedSum / totalWeight) * 100);
    
    // Adjust based on signal agreement
    const agreement = maxWeight / totalWeight;
    const adjustedScore = Math.round(confluenceScore * agreement);
    
    return {
      primarySignal,
      confluenceScore: adjustedScore,
      signals,
      agreement: Math.round(agreement * 100)
    };
  }
  
  getTimeframeWeight(tf) {
    const weights = {
      '15m': 0.8,
      '30m': 1.0,
      '1h': 1.2,
      '4h': 1.5,
      '1d': 1.8
    };
    return weights[tf] || 1.0;
  }
}

// ==================== ENHANCED STABLE SIGNAL ENGINE ====================
class StableSignalEngine {
  constructor() {
    this.currentSignal = 'NEUTRAL';
    this.signalHistory = [];
    this.confirmations = [];
    this.marketState = {};
    this.stabilityScore = 0;
    this.consecutiveSignals = 0;
    this.lastSignalChange = Date.now();
    
    // Initialize session timer
    this.sessionTimer = new SessionTimer();
    
    // Initialize multi-timeframe analyzer
    this.multiTF = new MultiTimeframeAnalyzer();
    
    this.initializeMarketData();
    
    this.STABILITY_THRESHOLDS = {
      HIGH: 75,
      MEDIUM: 60,
      LOW: 40
    };
    
    this.MIN_CONFIRMATIONS = 3;
    this.MIN_HOLD_TIME = 10000;
    this.MAX_CONSECUTIVE = 5;
  }
  
  initializeMarketData() {
    this.marketData = {
      EURUSD: { price: 1.08542, trend: 'NEUTRAL', rsi: 50, volatility: 0.8 },
      GBPUSD: { price: 1.26580, trend: 'NEUTRAL', rsi: 50, volatility: 0.9 },
      USDJPY: { price: 150.325, trend: 'NEUTRAL', rsi: 50, volatility: 1.2 },
      XAUUSD: { price: 2185.42, trend: 'NEUTRAL', rsi: 50, volatility: 1.5 },
      BTCUSD: { price: 68420.50, trend: 'NEUTRAL', rsi: 50, volatility: 2.0 },
      US30: { price: 39245.75, trend: 'NEUTRAL', rsi: 50, volatility: 1.8 }
    };
    
    Object.keys(this.marketData).forEach(pair => {
      this.marketData[pair].priceHistory = Array(50).fill(this.marketData[pair].price);
      this.marketData[pair].rsiHistory = Array(50).fill(50);
      this.marketData[pair].signalHistory = [];
      this.marketData[pair].trendStrength = 0;
    });
  }
  
  calculateStableRSI(prices) {
    if (prices.length < 30) return 50;
    
    const period = 14;
    let gains = 0;
    let losses = 0;
    
    for (let i = prices.length - period; i < prices.length - 1; i++) {
      const change = prices[i + 1] - prices[i];
      if (change > 0) {
        gains += change;
      } else {
        losses -= change;
      }
    }
    
    const avgGain = gains / period;
    const avgLoss = losses / period || 1;
    const rs = avgGain / avgLoss;
    let rsi = 100 - (100 / (1 + rs));
    
    const prevRSI = prices.rsi || 50;
    rsi = (prevRSI * 0.3) + (rsi * 0.7);
    
    return Math.max(0, Math.min(100, rsi));
  }
  
  determineStableTrend(prices) {
    if (prices.length < 20) return { direction: 'NEUTRAL', strength: 0 };
    
    const shortTerm = prices.slice(-10);
    const mediumTerm = prices.slice(-20);
    
    const shortAvg = shortTerm.reduce((a, b) => a + b, 0) / shortTerm.length;
    const mediumAvg = mediumTerm.reduce((a, b) => a + b, 0) / mediumTerm.length;
    
    const shortSlope = (shortTerm[shortTerm.length - 1] - shortTerm[0]) / shortTerm.length;
    const mediumSlope = (mediumTerm[mediumTerm.length - 1] - mediumTerm[0]) / mediumTerm.length;
    
    let direction = 'NEUTRAL';
    let strength = 0;
    
    if (shortSlope > 0 && mediumSlope > 0) {
      direction = 'BULLISH';
      strength = Math.abs(shortSlope + mediumSlope) * 1000;
    } else if (shortSlope < 0 && mediumSlope < 0) {
      direction = 'BEARISH';
      strength = Math.abs(shortSlope + mediumSlope) * 1000;
    }
    
    strength = Math.min(100, Math.max(0, strength));
    
    return { direction, strength };
  }
  
  checkConfirmations(pairData, rsi, trend) {
    const confirmations = [];
    
    const trendConfirmation = (
      (trend.direction === 'BULLISH' && rsi > 45 && rsi < 70) ||
      (trend.direction === 'BEARISH' && rsi > 30 && rsi < 55)
    ) && trend.strength > 40;
    
    confirmations.push({
      name: 'TREND',
      active: trendConfirmation,
      weight: 30
    });
    
    const rsiConfirmation = (
      (rsi < 35) ||
      (rsi > 65) ||
      (rsi > 50 && rsi < 65 && trend.direction === 'BULLISH') ||
      (rsi > 35 && rsi < 50 && trend.direction === 'BEARISH')
    );
    
    confirmations.push({
      name: 'RSI',
      active: rsiConfirmation,
      weight: 25
    });
    
    const volatility = this.calculateVolatility(pairData.priceHistory);
    const volConfirmation = volatility < 2.0;
    
    confirmations.push({
      name: 'VOL',
      active: volConfirmation,
      weight: 20
    });
    
    const momentum = this.calculateMomentum(pairData.priceHistory);
    const momConfirmation = Math.abs(momentum) > 0.1;
    
    confirmations.push({
      name: 'MOMENTUM',
      active: momConfirmation,
      weight: 25
    });
    
    return confirmations;
  }
  
  calculateVolatility(prices) {
    if (prices.length < 20) return 1;
    
    const returns = [];
    for (let i = 1; i < prices.length; i++) {
      returns.push((prices[i] - prices[i-1]) / prices[i-1]);
    }
    
    const mean = returns.reduce((a, b) => a + b, 0) / returns.length;
    const variance = returns.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / returns.length;
    
    return Math.sqrt(variance) * 100;
  }
  
  calculateMomentum(prices) {
    if (prices.length < 10) return 0;
    
    const shortPeriod = 5;
    const longPeriod = 10;
    
    const shortAvg = prices.slice(-shortPeriod).reduce((a, b) => a + b, 0) / shortPeriod;
    const longAvg = prices.slice(-longPeriod).reduce((a, b) => a + b, 0) / longPeriod;
    
    return ((shortAvg - longAvg) / longAvg) * 100;
  }
  
  generateStableSignal(pair, timeframe) {
    const pairData = this.marketData[pair];
    
    this.simulateMarketMovement(pair);
    
    const rsi = this.calculateStableRSI(pairData.priceHistory);
    const trend = this.determineStableTrend(pairData.priceHistory);
    const confirmations = this.checkConfirmations(pairData, rsi, trend);
    
    pairData.rsi = rsi;
    pairData.trend = trend.direction;
    pairData.trendStrength = trend.strength;
    
    const activeConfirmations = confirmations.filter(c => c.active);
    const totalWeight = confirmations.reduce((sum, c) => sum + c.weight, 0);
    const activeWeight = activeConfirmations.reduce((sum, c) => sum + c.weight, 0);
    
    this.stabilityScore = Math.round((activeWeight / totalWeight) * 100);
    this.confirmations = confirmations;
    
    let preliminarySignal = 'NEUTRAL';
    let signalStrength = 'WEAK';
    
    // Integrate multi-timeframe analysis
    const multiTFData = this.multiTF.generateTimeframeData(pair, timeframe);
    const confluence = this.multiTF.calculateConfluence();
    
    // Factor in multi-timeframe confluence
    const adjustedStability = Math.min(100, this.stabilityScore + (confluence.confluenceScore * 0.3));
    
    if (adjustedStability >= this.STABILITY_THRESHOLDS.HIGH) {
      signalStrength = 'STRONG';
      
      if (trend.direction === 'BULLISH' && rsi > 50 && rsi < 70) {
        preliminarySignal = 'BUY';
      } else if (trend.direction === 'BEARISH' && rsi > 30 && rsi < 50) {
        preliminarySignal = 'SELL';
      } else if (rsi < 30) {
        preliminarySignal = 'BUY';
      } else if (rsi > 70) {
        preliminarySignal = 'SELL';
      }
    } else if (adjustedStability >= this.STABILITY_THRESHOLDS.MEDIUM) {
      signalStrength = 'MEDIUM';
      
      if (trend.direction === 'BULLISH' && rsi > 55 && rsi < 65) {
        preliminarySignal = 'BUY';
      } else if (trend.direction === 'BEARISH' && rsi > 35 && rsi < 45) {
        preliminarySignal = 'SELL';
      }
    }
    
    // Consider multi-timeframe confluence
    if (confluence.primarySignal !== 'NEUTRAL' && confluence.agreement > 60) {
      if (confluence.primarySignal !== preliminarySignal && adjustedStability >= 70) {
        preliminarySignal = confluence.primarySignal;
        signalStrength = 'STRONG';
      }
    }
    
    const finalSignal = this.applyStabilizationFilters(preliminarySignal, signalStrength);
    
    return {
      signal: finalSignal,
      rsi,
      trend: trend.direction,
      trendStrength: trend.strength,
      stability: adjustedStability,
      confirmations,
      signalStrength,
      price: pairData.price,
      multiTFData,
      confluence
    };
  }
  
  applyStabilizationFilters(newSignal, signalStrength) {
    const now = Date.now();
    const timeSinceChange = now - this.lastSignalChange;
    
    if (timeSinceChange < this.MIN_HOLD_TIME && this.currentSignal !== 'NEUTRAL') {
      return this.currentSignal;
    }
    
    if (this.stabilityScore < this.STABILITY_THRESHOLDS.MEDIUM && newSignal !== 'NEUTRAL') {
      return 'NEUTRAL';
    }
    
    if (newSignal === this.currentSignal && newSignal !== 'NEUTRAL') {
      this.consecutiveSignals++;
      if (this.consecutiveSignals > this.MAX_CONSECUTIVE) {
        this.consecutiveSignals = 0;
        return 'NEUTRAL';
      }
    } else {
      this.consecutiveSignals = 1;
    }
    
    if (signalStrength === 'STRONG' && this.stabilityScore >= this.STABILITY_THRESHOLDS.HIGH) {
      this.lastSignalChange = now;
      this.currentSignal = newSignal;
      return newSignal;
    }
    
    if (signalStrength === 'MEDIUM' && this.currentSignal === 'NEUTRAL') {
      this.lastSignalChange = now;
      this.currentSignal = newSignal;
      return newSignal;
    }
    
    return this.currentSignal;
  }
  
  simulateMarketMovement(pair) {
    const data = this.marketData[pair];
    
    const volatility = data.volatility * 0.001;
    const randomMove = (Math.random() - 0.5) * 2 * volatility;
    
    let drift = 0;
    if (data.trend === 'BULLISH') drift = volatility * 0.1;
    if (data.trend === 'BEARISH') drift = -volatility * 0.1;
    
    data.price = data.price * (1 + randomMove + drift);
    data.priceHistory.push(data.price);
    if (data.priceHistory.length > 100) data.priceHistory.shift();
    
    data.rsiHistory.push(data.rsi);
    if (data.rsiHistory.length > 100) data.rsiHistory.shift();
  }
}

// ==================== APPLICATION INITIALIZATION ====================
const signalEngine = new StableSignalEngine();

function updateMultiTFDisplay(multiTFData, confluence) {
  const grid = document.getElementById('multiTfGrid');
  grid.innerHTML = '';
  
  Object.keys(multiTFData).forEach(tf => {
    const data = multiTFData[tf];
    const div = document.createElement('div');
    div.className = 'multi-tf-item';
    
    const signalClass = `multi-tf-${data.signal.toLowerCase()}`;
    
    div.innerHTML = `
      <div class="multi-tf-label">${tf}</div>
      <div class="multi-tf-value ${signalClass}">${data.signal}</div>
      <div class="multi-tf-label" style="margin-top:2px">RSI: ${data.rsi}</div>
    `;
    
    grid.appendChild(div);
  });
  
  document.getElementById('confluenceScore').textContent = `${confluence.confluenceScore}%`;
  
  // Color code confluence score
  const confluenceScoreElement = document.getElementById('confluenceScore');
  if (confluence.confluenceScore >= 75) {
    confluenceScoreElement.style.background = '#10b981';
  } else if (confluence.confluenceScore >= 60) {
    confluenceScoreElement.style.background = '#f59e0b';
  } else {
    confluenceScoreElement.style.background = '#ef4444';
  }
}

function updateUI() {
  const pair = document.getElementById('pair').value;
  const timeframe = document.getElementById('timeframe').value;
  const analysis = signalEngine.generateStableSignal(pair, timeframe);
  
  // Update signal display
  const signalBox = document.getElementById('signal');
  signalBox.textContent = analysis.signal;
  
  let signalClass = analysis.signal.toLowerCase();
  if (analysis.signalStrength === 'STRONG') {
    signalClass = analysis.signal === 'BUY' ? 'strong-buy' : 
                  analysis.signal === 'SELL' ? 'strong-sell' : 'neutral';
  }
  signalBox.className = `signal-box ${signalClass}`;
  
  // Update status
  const priceFormat = pair.includes('XAU') ? 2 : 
                     pair.includes('BTC') ? 2 : 
                     pair.includes('US30') ? 2 :
                     pair.includes('USDJPY') ? 3 : 5;
  
  const trendText = analysis.trend === 'BULLISH' ? 'üìà Bullish' : 
                   analysis.trend === 'BEARISH' ? 'üìâ Bearish' : '‚û°Ô∏è Neutral';
  
  document.getElementById('status').innerHTML = `
    ${pair} @ ${analysis.price.toFixed(priceFormat)}<br>
    ${trendText} (${analysis.trendStrength.toFixed(0)}%) | 
    Stability: ${analysis.stability}%
  `;
  
  // Update stability indicator
  document.getElementById('stabilityValue').textContent = `${analysis.stability}%`;
  const stabilityFill = document.getElementById('stabilityFill');
  stabilityFill.style.width = `${analysis.stability}%`;
  
  stabilityFill.className = 'stability-fill ';
  if (analysis.stability >= 75) {
    stabilityFill.classList.add('stability-high');
  } else if (analysis.stability >= 60) {
    stabilityFill.classList.add('stability-medium');
  } else {
    stabilityFill.classList.add('stability-low');
  }
  
  // Update confirmation indicators
  analysis.confirmations.forEach((conf, index) => {
    const indicator = document.getElementById(`conf${conf.name}`);
    if (indicator) {
      indicator.className = `confirmation-indicator ${conf.active ? 'confirmation-active' : 'confirmation-inactive'}`;
      indicator.textContent = `${conf.name} ${conf.active ? '‚úì' : '‚úó'}`;
    }
  });
  
  // Update indicator values
  document.getElementById('rsiValue').textContent = analysis.rsi.toFixed(1);
  const rsiColor = analysis.rsi > 70 ? '#ef4444' : analysis.rsi < 30 ? '#22c55e' : '#facc15';
  document.getElementById('rsiValue').style.color = rsiColor;
  
  document.getElementById('trendValue').textContent = analysis.trend;
  const trendColor = analysis.trend === 'BULLISH' ? '#22c55e' : 
                     analysis.trend === 'BEARISH' ? '#ef4444' : '#94a3b8';
  document.getElementById('trendValue').style.color = trendColor;
  
  document.getElementById('strengthValue').textContent = analysis.signalStrength;
  const strengthColor = analysis.signalStrength === 'STRONG' ? '#22c55e' : 
                        analysis.signalStrength === 'MEDIUM' ? '#facc15' : '#ef4444';
  document.getElementById('strengthValue').style.color = strengthColor;
  
  // Update multi-timeframe display
  updateMultiTFDisplay(analysis.multiTFData, analysis.confluence);
  
  // Update session timer
  signalEngine.sessionTimer.updateDisplay();
}

// ==================== EVENT HANDLERS ====================
document.getElementById('pair').addEventListener('change', updateUI);
document.getElementById('timeframe').addEventListener('change', updateUI);

// Multi-timeframe button handlers
document.querySelectorAll('.timeframe-btn').forEach(btn => {
  btn.addEventListener('click', function() {
    const tf = this.getAttribute('data-tf');
    
    // Update visual state
    document.querySelectorAll('.timeframe-btn').forEach(b => {
      b.classList.remove('active');
    });
    this.classList.add('active');
    
    // Update dropdown
    document.getElementById('timeframe').value = tf;
    
    // Update UI
    updateUI();
  });
});

// Touch event handlers for better mobile experience
document.querySelectorAll('select').forEach(select => {
  select.addEventListener('touchstart', function(e) {
    // Prevent double-tap zoom
    e.preventDefault();
  }, { passive: false });
});

// Prevent pull-to-refresh on mobile
let touchStartY = 0;
document.addEventListener('touchstart', e => {
  touchStartY = e.touches[0].clientY;
}, { passive: true });

document.addEventListener('touchmove', e => {
  const touchY = e.touches[0].clientY;
  const touchDiff = touchStartY - touchY;
  
  // If at top of page and pulling down, prevent default
  if (window.scrollY === 0 && touchDiff < 0) {
    e.preventDefault();
  }
}, { passive: false });

// Initial update
setTimeout(updateUI, 500);

// Regular updates
setInterval(updateUI, 3000);

// Update session timer every second
setInterval(() => {
  signalEngine.sessionTimer.updateDisplay();
}, 1000);

// Show initialization status
document.getElementById('status').textContent = "Initializing enhanced signal engine...";
</script>
</body>
</html>
