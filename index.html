<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Bekenet AI Signals ‚Äî Robust & Colorful</title>
<style>
/* 1. COLORFUL & CLEAN CSS */
:root{
  --bg:#081329; /* Very dark blue */
  --panel:#0f2240; /* Slightly lighter panel */
  --muted:#a3c5ff; /* Brightened muted text */
  --accent:#00ccff; /* Vibrant Cyan for focus */
  --good:#00e676; /* Vibrant Green */
  --bad:#ff3d71; /* Vibrant Pink-Red */
  --wait:#f2c94c; /* Gold/Yellow for wait */
  --card: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.01));
  --radius:12px;
}
html,body{height:100%;margin:0;background:var(--bg);font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;color:#e6eef8}
.wrap{max-width:1200px;margin:20px auto;padding:15px}
.header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:15px;border-bottom: 2px solid rgba(255,255,255,0.05);padding-bottom: 10px;}
.hleft{display:flex;flex-direction:column}
.hleft h1{margin:0;font-size:24px;color:var(--accent);}
.hleft .small{font-size:14px;}
.controls{display:flex;gap:15px;align-items:center;flex-wrap:wrap}
.card{background:var(--card);padding:15px;border-radius:var(--radius);box-shadow:0 8px 30px rgba(0,0,0,0.5);border:1px solid rgba(255,255,255,0.06)}
.row{display:flex;gap:15px}
.col{display:flex;flex-direction:column;gap:15px}
.param-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:10px}
.param-group label {font-size:12px;color:var(--muted);display:block;margin-bottom:4px;}
.param-group input, .param-group select {
    background: var(--panel);
    border: 1px solid rgba(255, 255, 255, 0.1);
    padding: 8px;
    border-radius: 8px;
    color: #e6eef8;
    width: 100%;
    box-sizing: border-box;
}
.small{font-size:13px;color:var(--muted)}
.muted{color:var(--muted)}
.btn{background:var(--accent);border:none;padding:10px 15px;border-radius:8px;color:#0f2240;cursor:pointer;font-weight:700;transition: all 0.2s;}
.btn:hover{filter:brightness(1.1);}
.btn.secondary{background:var(--panel);color:var(--muted);border:1px solid rgba(255,255,255,0.1);}
.canvasWrap{height:150px;border-radius:8px;overflow:hidden;background:var(--panel);}
.canvas{width:100%;height:100%;display:block}
.pairsList{display:flex;flex-direction:column;gap:10px;max-height: 250px; overflow-y: auto;}
.pairRow{display:flex;justify-content:space-between;align-items:center;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.05);background:rgba(255,255,255,0.01);cursor:pointer;transition: all 0.2s;}
.pairRow:hover{background:rgba(255,255,255,0.03);}
.badge{padding:8px 12px;border-radius:6px;font-weight:700;font-size:14px;min-width: 60px; text-align: center;}
.buy{background:rgba(0,230,118,0.2);color:var(--good)}
.sell{background:rgba(255,61,113,0.2);color:var(--bad)}
.wait{background:rgba(242,201,76,0.15);color:var(--wait)}
.explain{font-size:12px;color:var(--muted);margin-top:6px}
.log{max-height:220px;overflow-y:auto;padding:10px;border-radius:8px;background:var(--panel);font-family:monospace;font-size:11px;border:1px solid rgba(255,255,255,0.06);}
.log::-webkit-scrollbar {width: 6px;}
.log::-webkit-scrollbar-thumb {background: rgba(255, 255, 255, 0.2); border-radius: 3px;}
@media(max-width:980px){ .row{flex-direction:column} .param-grid{grid-template-columns:repeat(2,1fr)} .canvasWrap{height:160px}}
</style>
</head>
<body>
<div class="wrap">
  <div class="header">
    <div class="hleft">
      <h1>üí∞ Bekenet AI Signals Command Center</h1>
      <div class="small muted">Robust ‚Ä¢ Colorful ‚Ä¢ Non-Noisy Trade Management</div>
    </div>
    <div class="controls">
      <div class="small muted">Update Frequency: <span style="font-weight:bold; color:var(--accent)">30s</span></div>
      <button id="refreshNow" class="btn secondary">‚ö° Refresh Now</button>
    </div>
  </div>

  <div class="row">
    <div style="flex:1" class="col">
      
      <div class="card">
        <div style="display:flex;justify-content:space-between;align-items:flex-end;gap:12px;margin-bottom:10px;">
            <div style="font-weight:700; color:var(--accent);">Asset Watchlist</div>
            <div style="display:flex;gap:8px;align-items:center">
                <input id="addPairInput" placeholder="BTC/USDT" style="width:100px;"/>
                <button id="addPairBtn" class="btn secondary">Add</button>
            </div>
        </div>
        <div class="pairsList" id="pairsContainer"></div>
        <div style="margin-top:10px;display:flex;justify-content:space-between;align-items:center">
          <div class="small muted">Click a pair to view its chart/context.</div>
          <button id="clearPairs" class="btn secondary" style="background:rgba(255,61,113,0.15)">Reset Pairs</button>
        </div>
      </div>

      <div class="card">
        <div style="font-weight:700; margin-bottom: 10px;">Visual Context: <span id="selectedPair" style="color:var(--accent)">‚Äî</span></div>
        <div class="canvasWrap">
          <canvas id="miniChart" class="canvas"></canvas>
        </div>
        <div style="display:flex;justify-content:space-between;align-items:center;margin-top:10px">
          <div><div class="small muted">Current Price</div><div id="selectedPrice" style="font-weight:700">‚Äî</div></div>
          <div class="param-group"><label for="tf">Timeframe</label><select id="tf"><option value="1m">1m</option><option value="5m">5m</option><option value="15m">15m</option></select></div>
          <div class="param-group"><label for="entryMode">Strategy Mode</label><select id="entryMode"><option value="smart">Smart</option><option value="aggressive">Aggressive</option><option value="conservative">Conservative</option></select></div>
          <div><button id="loadDefaults" class="btn secondary">Reset Params</button></div>
        </div>

        <div style="font-weight:700; margin-top: 15px; color:var(--accent); border-top: 1px solid rgba(255,255,255,0.05); padding-top: 10px;">Signal Parameters</div>
        <div class="param-grid">
          <div class="param-group"><label>EMA Fast</label><input id="emaFast" type="number" value="50" /></div>
          <div class="param-group"><label>EMA Slow</label><input id="emaSlow" type="number" value="200" /></div>
          <div class="param-group"><label>RSI Period</label><input id="rsiPeriod" type="number" value="14" /></div>
          <div class="param-group"><label>RSI Buy Level</label><input id="rsiBuy" type="number" value="35" /></div>
          <div class="param-group"><label>RSI Sell Level</label><input id="rsiSell" type="number" value="65" /></div>
          <div class="param-group"><label>S/R Lookback</label><input id="srLookback" type="number" value="200" /></div>
        </div>
        <div class="small muted" style="margin-top:10px;">* Signals are non-repainting and evaluated on **closed candles** only.</div>
      </div>
    </div>

    <div style="width:380px" class="col">
      
      <div class="card" style="border: 2px solid var(--accent);">
        <div style="font-weight:700; color:var(--accent);">üõ†Ô∏è Trade Management Panel</div>
        <div id="exitHints" class="small muted" style="padding-top: 5px;">No open trades or selected pair.</div>
      </div>

      <div class="card">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div style="font-weight:700; color:var(--good);">üì¢ Live Signals (Actionable)</div>
          <div class="small muted">TF: <span id="currentTfDisplay">‚Äî</span></div>
        </div>
        <div id="liveList" style="margin-top:10px;display:flex;flex-direction:column;gap:8px"></div>
      </div>

      <div class="card">
        <div style="font-weight:700">üìú System Log</div>
        <div id="log" class="log">Ready.</div>
      </div>
    </div>
  </div>
</div>

<script>
/*
  Bekenet-style AI Signal ‚Äî Single-file
  - Robust (No Repaint, State Persistent)
  - Non-Noisy (Trade Management Panel)
  - Colorful (High Contrast Dark Theme)
*/

// ---------- Utilities ----------
const $ = id => document.getElementById(id);
const sleep = ms => new Promise(r => setTimeout(r, ms));
function nowISO(){ return new Date().toLocaleTimeString('en-US'); }
function log(msg){ $('log').innerText = nowISO() + ' ‚Ä¢ ' + msg + '\n' + $('log').innerText; }

// Local Storage Keys
const PAIRS_KEY = 'bekenet_pairs';
const STATE_KEY = 'bekenet_state';
const PARAMS_KEY = 'bekenet_params';

// ---------- Default pairs & State ----------
const DEFAULT_PAIRS = ['EUR/USD','GBP/USD','USD/JPY','XAU/USD','BTC/USDT'];
const DEFAULT_PARAMS = {
    emaFast: 50, emaSlow: 200, rsiPeriod: 14, rsiBuy: 35, rsiSell: 65, srLookback: 200,
    entryMode: 'smart', tf: '1m'
};
let pairs = [...DEFAULT_PAIRS];
const state = {}; // per-pair state and candles


// ---------- Persistence Functions üíæ ----------
function saveParams() {
    const params = {
        emaFast: +$('emaFast').value, emaSlow: +$('emaSlow').value, rsiPeriod: +$('rsiPeriod').value,
        rsiBuy: +$('rsiBuy').value, rsiSell: +$('rsiSell').value, srLookback: +$('srLookback').value,
        entryMode: $('entryMode').value, tf: $('tf').value
    };
    localStorage.setItem(PARAMS_KEY, JSON.stringify(params));
    $('currentTfDisplay').innerText = params.tf;
}

function loadParams() {
    const savedParams = localStorage.getItem(PARAMS_KEY);
    const params = savedParams ? JSON.parse(savedParams) : DEFAULT_PARAMS;

    $('emaFast').value = params.emaFast;
    $('emaSlow').value = params.emaSlow;
    $('rsiPeriod').value = params.rsiPeriod;
    $('rsiBuy').value = params.rsiBuy;
    $('rsiSell').value = params.rsiSell;
    $('srLookback').value = params.srLookback;
    $('entryMode').value = params.entryMode;
    $('tf').value = params.tf;
    $('currentTfDisplay').innerText = params.tf;
}

// Save the current state to localStorage
function saveState() {
  localStorage.setItem(PAIRS_KEY, JSON.stringify(pairs));
  const serializableState = {};
  for(const p in state){
    serializableState[p] = {
      lastSignal: state[p].lastSignal,
      openPosition: state[p].openPosition,
      lastEvaluated: state[p].lastEvaluated,
      exitHint: state[p].exitHint
    };
  }
  localStorage.setItem(STATE_KEY, JSON.stringify(serializableState));
  saveParams();
}

// Load state from localStorage
function loadState() {
  loadParams();

  const savedPairs = localStorage.getItem(PAIRS_KEY);
  if(savedPairs) {
    try {
      pairs = JSON.parse(savedPairs);
    } catch (e) { pairs = [...DEFAULT_PAIRS]; }
  }

  const savedState = localStorage.getItem(STATE_KEY);
  if(savedState) {
    try {
      const loadedState = JSON.parse(savedState);
      for (const p of pairs) {
        state[p] = state[p] || {candles:[], lastSignal:null, openPosition:null, lastEvaluated:0, exitHint:null};
        if(loadedState[p]) {
          state[p].lastSignal = loadedState[p].lastSignal;
          state[p].openPosition = loadedState[p].openPosition;
          state[p].lastEvaluated = loadedState[p].lastEvaluated;
          state[p].exitHint = loadedState[p].exitHint;
        }
      }
    } catch (e) { log('Error loading trade state, resetting.'); }
  }
}
// ---------------------------------------------


// ---------- Config & UI elements ----------
const refreshInterval = 30 * 1000; // 30s
const miniCanvas = $('miniChart');
const miniCtx = miniCanvas.getContext('2d');
function resizeCanvas(){ miniCanvas.width = miniCanvas.clientWidth * devicePixelRatio; miniCanvas.height = miniCanvas.clientHeight * devicePixelRatio; miniCtx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0); }
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

$('addPairBtn').addEventListener('click', ()=>{ const v=$('addPairInput').value.trim().toUpperCase(); if(v){ addPair(v); $('addPairInput').value=''; }});
$('clearPairs').addEventListener('click', ()=>{ 
  pairs = [...DEFAULT_PAIRS]; 
  initPairs(); 
  log('Pairs reset to default watchlist.');
  saveState(); 
});
$('refreshNow').addEventListener('click', fetchAllOnce);

// Event listeners for saving parameter changes
['emaFast', 'emaSlow', 'rsiPeriod', 'rsiBuy', 'rsiSell', 'srLookback', 'entryMode', 'tf'].forEach(id => {
    $(id).addEventListener('change', saveParams);
});

// Load Defaults button handler
$('loadDefaults').addEventListener('click', () => {
    localStorage.removeItem(PARAMS_KEY);
    loadParams();
    log('Parameters reset to default values.');
    // Re-evaluate current signals with new params on next tick
});


// initialize UI
function renderPairsUI(){
  const container = $('pairsContainer'); container.innerHTML='';
  pairs.forEach(p=>{
    const div = document.createElement('div'); div.className='pairRow';
    div.onclick = ()=> selectPair(p); // Make the entire row clickable
    const left = document.createElement('div'); 
    left.innerHTML = `<div style="font-weight:700; color:var(--muted)">${p}</div><div class="small muted" id="info-${p}">‚Äî</div>`;
    
    const right = document.createElement('div');
    const badge = document.createElement('span'); badge.id = `badge-${p}`; badge.className='badge wait'; badge.innerText='WAIT';
    const btnRem = document.createElement('button'); btnRem.className='btn secondary'; btnRem.innerText='Remove'; 
    btnRem.style.marginLeft = '10px'; btnRem.style.padding = '5px 10px';
    btnRem.onclick=(e)=> {e.stopPropagation(); removePair(p);}; // Stop propagation to avoid selecting the pair on removal
    
    right.appendChild(badge); right.appendChild(btnRem);
    div.appendChild(left); div.appendChild(right);
    container.appendChild(div);
  });
}
function addPair(p){ 
  if(!pairs.includes(p)){ 
    pairs.push(p); 
    initPairs(); 
    log('Added pair '+p);
    saveState(); 
  } 
}
function removePair(p){ 
  pairs = pairs.filter(x=>x!==p); 
  initPairs(); 
  log('Removed pair '+p); 
  saveState(); 
  if($('selectedPair').innerText === p) selectPair(pairs.length > 0 ? pairs[0] : '‚Äî');
}
function selectPair(p){ $('selectedPair').innerText = p; renderMini(p); }
// initial fill
function initPairs(){ 
  renderPairsUI(); 
  pairs.forEach(p=>{ 
    state[p] = state[p] || {candles:[], lastSignal:null, openPosition:null, lastEvaluated:0, exitHint:null}; 
  }); 
  renderLiveList(); 
  saveState(); 
}


// ---------- Indicator helpers (same as original) ----------
function ema(values, period){
  const out = []; const k = 2/(period+1);
  let prev = null;
  for(let i=0;i<values.length;i++){
    if(i===0){ prev = values[0]; out.push(prev); continue; }
    if(prev===null) prev = values[i];
    prev = (values[i]-prev)*k + prev;
    out.push(prev);
  }
  return out;
}
function sma(values, period){
  const out=[]; let sum=0;
  for(let i=0;i<values.length;i++){
    sum += values[i];
    if(i>=period) sum -= values[i-period];
    out.push(i>=period-1 ? sum/period : null);
  }
  return out;
}
function rsi(values, period){
  const out=[]; let gains=0, losses=0;
  for(let i=1;i<values.length;i++){
    const d = values[i]-values[i-1];
    if(i<=period){ if(d>0) gains += d; else losses += Math.abs(Math.min(d,0)); if(i===period){ let ag=gains/period, al=losses/period; let rs=ag/(al||1e-9); out[period] = 100 - (100/(1+rs)); var prevGain=ag, prevLoss=al; } else out.push(null); }
    else{ const gain = Math.max(values[i]-values[i-1],0); const loss = Math.max(values[i-1]-values[i],0); prevGain=(prevGain*(period-1)+gain)/period; prevLoss=(prevLoss*(period-1)+loss)/period; const rs = prevGain/(prevLoss||1e-9); out.push(100 - (100/(100/(prevLoss||1e-9)))); }
  }
  while(out.length < values.length) out.unshift(null);
  return out;
}
function atr(highs,lows,closes,period){
  const trs = [];
  for(let i=0;i<highs.length;i++){
    if(i===0) trs.push(highs[i]-lows[i]);
    else trs.push(Math.max(highs[i]-lows[i], Math.abs(highs[i]-closes[i-1]), Math.abs(lows[i]-closes[i-1])));
  }
  return sma(trs, period);
}
// detect S/R as local peaks/troughs (simple)
function detectSR(candles, lookback){
  const sup=[], res=[];
  const n=candles.length;
  for(let i=2;i<n-2;i++){
    if(candles[i].l < candles[i-1].l && candles[i].l < candles[i+1].l) sup.push(candles[i].l);
    if(candles[i].h > candles[i-1].h && candles[i].h > candles[i+1].h) res.push(candles[i].h);
  }
  // cluster
  const cluster = (arr,tol=0.0025)=>{ arr.sort((a,b)=>a-b); const out=[]; arr.forEach(v=>{ if(out.length===0) out.push(v); else{ const last=out[out.length-1]; if(Math.abs(last-v)/last < tol) out[out.length-1]=(last+v)/2; else out.push(v);} }); return out; };
  return {supports: cluster(sup.slice(-lookback)), resistances: cluster(res.slice(-lookback))};
}

// ---------- Data fetchers (similar to original, simplified) ----------
async function fetchBinanceKlines(symbol, interval, limit=200){
  const url = `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
  const r = await fetch(url);
  if(!r.ok) throw new Error('Binance fetch failed');
  const j = await r.json();
  return j.map(x=>({t:+x[0],o:+x[1],h:+x[2],l:+x[3],c:+x[4],v:+x[5]}));
}
async function fetchForexQuote(pair){
  const url = `https://api.exchangerate.host/latest?base=${pair.split('/')[0]}&symbols=${pair.split('/')[1]}`;
  const r = await fetch(url);
  if(!r.ok) throw new Error('Forex quote fetch failed');
  const j = await r.json();
  const rate = j.rates && j.rates[pair.split('/')[1]] ? j.rates[pair.split('/')[1]] : null;
  if(!rate) throw new Error('No rate returned for '+pair);
  return {t: Date.now(), price: +rate};
}

function timeframeToMs(tf){
  if(tf==='1m') return 60*1000;
  if(tf==='5m') return 5*60*1000;
  if(tf==='15m') return 15*60*1000;
  return 60*1000;
}

function addQuoteToCandle(store, quote, tf){
  const ms = timeframeToMs(tf);
  const t0 = Math.floor(quote.t / ms) * ms;
  let last = store.candles.length ? store.candles[store.candles.length-1] : null;
  if(!last || last.t !== t0){
    const newc = {t:t0,o:quote.price,h:quote.price,l:quote.price,c:quote.price,v:quote.volume||0};
    store.candles.push(newc);
    if(store.candles.length > 500) store.candles.shift();
  } else {
    last.h = Math.max(last.h, quote.price);
    last.l = Math.min(last.l, quote.price);
    last.c = quote.price;
    last.v = (last.v || 0) + (quote.volume||0);
  }
}

// ---------- Decision engine (same as original logic) ----------
function evaluateOnClosedCandle(candles, params, mode){
  if(candles.length < Math.max(params.emaSlow, params.rsiPeriod, 10)) return {side:'WAIT', reason:['Insufficient data (initial load)']};
  const closes = candles.map(c=>c.c);
  const highs = candles.map(c=>c.h);
  const lows = candles.map(c=>c.l);
  const emaF = ema(closes, params.emaFast);
  const emaS = ema(closes, params.emaSlow);
  const rsiArr = rsi(closes, params.rsiPeriod);
  const atrArr = atr(highs,lows,closes, 14); 
  const i = candles.length - 1;
  const price = closes[i];
  const emaFast = emaF[i], emaSlow = emaS[i], rsiVal = rsiArr[i], atrVal = atrArr[i];
  const sr = detectSR(candles, params.srLookback);
  const nearSupport = sr.supports.some(s => Math.abs((price - s)/price) < 0.0035);
  const nearResist  = sr.resistances.some(s => Math.abs((price - s)/price) < 0.0035);
  const look = Math.min(60, candles.length-1); 
  const slice = candles.slice(candles.length-1-look);
  let maxH = -Infinity, minL = Infinity;
  slice.forEach(x=>{ if(x.h>maxH) maxH=x.h; if(x.l<minL) minL=x.l; });
  const fib38 = maxH - (maxH-minL)*0.382;
  const fib61 = maxH - (maxH-minL)*0.618;
  const nearFib = (price >= Math.min(fib38,fib61) && price <= Math.max(fib38,fib61));
  const momLen = 8;
  const mom = (closes[i] - closes[Math.max(0,i-momLen)]) / Math.max(1e-9, closes[Math.max(0,i-momLen)]);
  const bullish = emaFast > emaSlow;
  const bearish = emaFast < emaSlow;

  let side='WAIT', reasons=[];
  if(mode==='aggressive'){
    if(bullish){ side='BUY'; reasons.push('EMA Crossover Up'); }
    if(bearish){ side='SELL'; reasons.push('EMA Crossover Down'); }
  } else if(mode==='conservative'){
    if(rsiVal !== null && rsiVal < params.rsiBuy && nearSupport && mom > 0){ side='BUY'; reasons.push('RSI Low + Support + Momentum'); }
    if(rsiVal !== null && rsiVal > params.rsiSell && nearResist && mom < 0){ side='SELL'; reasons.push('RSI High + Resistance + Momentum'); }
  } else { // smart
    if(bullish && rsiVal !== null && rsiVal < params.rsiBuy && (nearFib || nearSupport) && mom > 0){ side='BUY'; reasons.push('Smart: EMA, RSI, Fib/SR, Momentum'); }
    else if(bearish && rsiVal !== null && rsiVal > params.rsiSell && (nearFib || nearResist) && mom < 0){ side='SELL'; reasons.push('Smart: EMA, RSI, Fib/SR, Momentum'); }
    else {
      if(bullish && (nearSupport || nearFib)) { side='BUY'; reasons.push('EMA Trend Up + Partial Confirmation'); }
      if(bearish && (nearResist || nearFib)) { side='SELL'; reasons.push('EMA Trend Down + Partial Confirmation'); }
    }
  }
  if(side==='BUY' && rsiVal !== null && rsiVal > 90){ side='WAIT'; reasons.push('RSI Extreme High - Pause'); }
  if(side==='SELL' && rsiVal !== null && rsiVal < 10){ side='WAIT'; reasons.push('RSI Extreme Low - Pause'); }

  return {side, reasons, context:{price, emaFast, emaSlow, rsiVal, atrVal, nearSupport, nearResist, nearFib, mom, fib38, fib61}, sr};
}

// ---------- UI rendering helpers ----------
function renderExitHints(pair) {
    const hintsEl = $('exitHints');
    const st = state[pair];
    if (!st || !st.lastSignal || !st.lastSignal.context) {
        hintsEl.innerHTML = `<div class="small muted">Select a pair and wait for the first data fetch to get market context.</div>`;
        return;
    }
    
    const ctx = st.lastSignal.context;
    const atr = ctx.atrVal ? ctx.atrVal.toFixed(6) : '‚Äî';
    const hasPosition = !!st.openPosition;
    
    let html = `
        <div style="font-weight:700; color:var(--muted); margin-bottom: 8px;">Market Context (${$('tf').value})</div>
        <div class="small muted">
            <span style="color:${ctx.nearSupport ? 'var(--good)' : 'var(--muted)'}; font-weight:700;">Support Near: ${ctx.nearSupport ? 'YES' : 'No'}</span> | 
            <span style="color:${ctx.nearResist ? 'var(--bad)' : 'var(--muted)'}; font-weight:700;">Resistance Near: ${ctx.nearResist ? 'YES' : 'No'}</span>
            <br>
            ‚Ä¢ **Current ATR (14)**: <span style="color:var(--wait)">${atr}</span><br>
            ‚Ä¢ **RSI (14)**: ${ctx.rsiVal ? ctx.rsiVal.toFixed(2) : '‚Äî'}
        </div>
    `;

    if (hasPosition) {
        const pos = st.openPosition;
        html += `<div style="margin-top: 15px; padding: 10px; border: 2px solid ${pos.side === 'BUY' ? 'var(--good)' : 'var(--bad)'}; border-radius: 8px; background: rgba(0,0,0,0.2);">
            <div style="color: ${pos.side === 'BUY' ? 'var(--good)' : 'var(--bad)'}; font-weight: 700; font-size: 16px; display:flex; justify-content: space-between;">
                <span>üéØ ACTIVE ${pos.side} @ ${pos.entry.toFixed(6)}</span>
                <span>${st.exitHint ? 'üö® EXIT HINT' : 'üü¢ OPEN'}</span>
            </div>
            <div class="small" style="margin-top:8px; line-height: 1.6;">
                ‚Ä¢ **Suggested SL**: <span style="color:var(--bad);">${pos.sl ? pos.sl.toFixed(6) : '‚Äî'}</span> (1.5x ATR)<br>
                ‚Ä¢ **Suggested TP**: <span style="color:var(--good);">${pos.tp ? pos.tp.toFixed(6) : '‚Äî'}</span> (2.5x ATR)
            </div>
            ${st.exitHint ? `<div style="color:var(--bad); margin-top: 8px; font-weight: 700;">**EXIT REASON**: ${st.exitHint}</div>` : ''}
            <div class="small muted" style="margin-top: 8px;">Entry Reason: ${pos.reason}</div>
        </div>`;
    } else {
        html += `<div style="margin-top: 15px;" class="small muted">No active trade to manage. Waiting for a new signal to trigger on closed candle.</div>`;
    }
    
    hintsEl.innerHTML = html;
}

function updateLiveList(){
  const container = $('liveList'); container.innerHTML='';
  pairs.forEach(p=>{
    const st = state[p] || {candles:[], lastSignal:null, openPosition:null, lastEvaluated:0};
    const div = document.createElement('div');
    div.className = 'pairRow';
    div.onclick = ()=> selectPair(p);

    const left = document.createElement('div'); 
    let infoText = 'Price: ‚Äî';
    if(st.candles.length > 0) infoText = 'Price: ' + st.candles[st.candles.length-1].c.toFixed(6);
    left.innerHTML = `<div style="font-weight:700; color:var(--muted)">${p}</div><div class="small muted" id="info-${p}">${infoText}</div>`;

    const right = document.createElement('div'); right.style.display='flex'; right.style.gap='8px'; right.style.alignItems='center';
    
    let signalSide = 'WAIT';
    let signalText = 'Waiting for Candle Close';
    
    if(st.lastSignal){
        signalSide = st.lastSignal.side;
        signalText = st.openPosition ? `Position Open @ ${st.openPosition.entry.toFixed(6)}` : st.lastSignal.reasons[0];
    }
    
    const sig = document.createElement('span'); 
    sig.className=`badge ${signalSide.toLowerCase()}`; 
    sig.innerText=signalSide;
    
    const hint = document.createElement('div'); 
    hint.className='small muted'; 
    hint.innerText=signalText;

    right.appendChild(sig); right.appendChild(hint);
    div.appendChild(left); div.appendChild(right);
    container.appendChild(div);
  });
}

// render mini chart for selected pair (simplified visual context)
function renderMini(pair){
  const st = state[pair]; 
  const currentPair = $('selectedPair').innerText;
  
  // Update chart only if the selected pair matches the one being rendered
  if(pair === currentPair){
    if(!st || !st.candles || st.candles.length===0) { 
        miniCtx.clearRect(0,0,miniCanvas.width,miniCanvas.height); 
        $('selectedPrice').innerText='Price: ‚Äî'; 
        renderExitHints(pair);
        return; 
    }
    const candles = st.candles.slice(-100);
    const w = miniCanvas.clientWidth, h = miniCanvas.clientHeight;
    miniCtx.clearRect(0,0,miniCanvas.width,miniCanvas.height);
    let min=Infinity,max=-Infinity; candles.forEach(c=>{ min=Math.min(min,c.l); max=Math.max(max,c.h); });
    const pad = (max-min)*0.06; min-=pad; max+=pad;
    const N=candles.length; 
    const scaleY = h / (max - min);
    const scaleX = w / N;
    
    // Draw the zero line for perspective (EMA Cross if slow EMA is flat)
    if(st.lastSignal && st.lastSignal.context.emaSlow) {
        const emaS_val = st.lastSignal.context.emaSlow;
        const yEma = h - ((emaS_val - min) * scaleY);
        miniCtx.beginPath();
        miniCtx.moveTo(0, yEma);
        miniCtx.lineTo(w, yEma);
        miniCtx.strokeStyle = 'rgba(0, 204, 255, 0.4)';
        miniCtx.lineWidth = 1;
        miniCtx.setLineDash([5, 5]);
        miniCtx.stroke();
        miniCtx.setLineDash([]);
    }

    for(let i=0;i<N;i++){
      const c=candles[i]; 
      const x = i * scaleX;
      
      const yOpen = h - ((c.o-min) * scaleY);
      const yClose = h - ((c.c-min) * scaleY);
      const yHigh = h - ((c.h-min) * scaleY);
      const yLow = h - ((c.l-min) * scaleY);
      
      const isBullish = c.c>=c.o; 
      const color = isBullish ? 'var(--good)' : 'var(--bad)';
      
      // Wick
      miniCtx.beginPath(); miniCtx.moveTo(x + scaleX/2, yHigh); miniCtx.lineTo(x + scaleX/2, yLow); 
      miniCtx.lineWidth=1; miniCtx.strokeStyle=color; miniCtx.stroke();
      
      // Body
      miniCtx.fillStyle = color;
      miniCtx.fillRect(x + scaleX*0.1, Math.min(yOpen,yClose), scaleX*0.8, Math.max(1, Math.abs(yOpen-yClose)));
    }
    const last = candles[candles.length-1]; $('selectedPrice').innerText = 'Price: ' + last.c.toFixed(6);
  }
  
  renderExitHints(pair);
}

// ---------- Signal lifecycle and exit logic ----------
function processClosedCandleFor(pair){
  const st = state[pair]; if(!st) return;
  const params = {
    emaFast: +$('emaFast').value,
    emaSlow: +$('emaSlow').value,
    rsiPeriod: +$('rsiPeriod').value,
    rsiBuy: +$('rsiBuy').value,
    rsiSell: +$('rsiSell').value,
    srLookback: +$('srLookback').value
  };
  const mode = $('entryMode').value;
  const lastCandle = st.candles[st.candles.length-1];
  if(!lastCandle) return;
  if(st.lastEvaluated === lastCandle.t) return; 
  
  const result = evaluateOnClosedCandle(st.candles, params, mode);
  st.lastSignal = result;
  st.lastEvaluated = lastCandle.t;
  
  st.exitHint = null; // Reset exit hint for fresh evaluation

  if(st.openPosition){
    const open = st.openPosition;
    const ctx = result.context;
    let exitReason = null;
    
    // 1. Signal reversal
    if(result.side && result.side !== 'WAIT' && result.side !== open.side){
      exitReason = `Opposite ${result.side} signal triggered`;
    }
    // 2. EMA trend break
    if(!exitReason && ((open.side==='BUY' && ctx.emaFast < ctx.emaSlow) || (open.side==='SELL' && ctx.emaFast > ctx.emaSlow))){
      exitReason = 'EMA trend reversed';
    }
    // 3. RSI extreme
    if(!exitReason){
      if(open.side==='BUY' && ctx.rsiVal && ctx.rsiVal > 75) exitReason = 'RSI Overbought Alert';
      if(open.side==='SELL' && ctx.rsiVal && ctx.rsiVal < 25) exitReason = 'RSI Oversold Alert';
    }
    // 4. S/R or TP target reached
    if(!exitReason){
      if(open.side==='BUY' && ctx.nearResist) exitReason = 'Price reached nearby resistance';
      if(open.side==='SELL' && ctx.nearSupport) exitReason = 'Price reached nearby support';
    }

    if(exitReason){
      st.exitHint = exitReason;
      log(`Exit HINT for ${pair}: ${exitReason}`);
    } 

  } else {
    // New Signal logic
    if(result.side === 'BUY' || result.side === 'SELL'){
      if(result.reasons && result.reasons.length > 0){
        const entry = result.context.price;
        const side = result.side;
        const atrVal = result.context.atrVal;
        
        // ATR-based SL/TP (Advisory for Trade Management Panel)
        const sl_dist = atrVal * 1.5;
        const tp_dist = atrVal * 2.5;
        const sl = (side === 'BUY') ? entry - sl_dist : entry + sl_dist;
        const tp = (side === 'BUY') ? entry + tp_dist : entry - tp_dist;

        st.openPosition = {
            side, entry, entryIndex: st.candles.length-1, 
            reason: result.reasons.join('; '), t: Date.now(),
            atrVal: atrVal, sl: sl, tp: tp
        };
        log(`üì¢ NEW ${side} SIGNAL on ${pair} at ${entry.toFixed(6)} (${mode} mode)`);
      }
    }
  }
  
  updateLiveList();
  const selected = $('selectedPair').innerText;
  if(selected === pair) renderMini(pair);
  
  saveState(); 
}

// ---------- Main fetch loop ----------
async function fetchForPair(pair){
  try {
    const tf = $('tf').value;
    const ms = timeframeToMs(tf);
    const isCrypto = pair.replace('/','').toUpperCase().endsWith('USDT') || pair.toUpperCase().includes('BTC') || pair.toUpperCase().includes('ETH');
    
    state[pair] = state[pair] || {candles:[], lastSignal:null, openPosition:null, lastEvaluated:0, exitHint:null};

    if(isCrypto){
      let bsymbol = pair.replace('/','').toUpperCase();
      if(bsymbol.endsWith('USD') && !bsymbol.endsWith('USDT')) bsymbol = bsymbol.replace('USD','USDT');
      const interval = tf; 
      const klines = await fetchBinanceKlines(bsymbol, interval, 500);
      state[pair].candles = klines.map(k=>({t:k.t,o:k.o,h:k.h,l:k.l,c:k.c,v:k.v}));
    } else {
      // For Forex/Metals (using live quote fallback for simplicity/speed)
      const quote = await fetchForexQuote(pair);
      addQuoteToCandle(state[pair], {t: quote.t, price: quote.price}, tf);
      
      // To simulate historical data for indicators (if no AlphaVantage key is provided, this data is often insufficient)
      if(state[pair].candles.length < 50){
        log(`[${pair}] Initializing candle history. Signals may be unreliable until more data is collected.`);
      }
    }
    
    const now = Date.now();
    const ms_tf = timeframeToMs(tf);
    const lastCandle = state[pair].candles[state[pair].candles.length-1];
    if(!lastCandle){ log(`[${pair}] No candles fetched.`); return; }
    
    // Check if the last candle is closed
    if(lastCandle.t + ms_tf <= now){
      processClosedCandleFor(pair);
    } else {
      // Update real-time price info on the pair list (intra-candle)
      if(state[pair].candles.length>0){
        const last = state[pair].candles[state[pair].candles.length-1];
        const infoEl = document.getElementById('info-'+pair);
        if(infoEl) infoEl.innerText = 'Price: '+last.c.toFixed(6)+' (intra)';
      }
    }

  } catch(err){
    log(`[${pair}] Fetch error: ${err.message}`);
    console.error(err);
  }
}

async function fetchAllOnce(){
  const copy = [...pairs];
  for(let i=0;i<copy.length;i++){
    const p = copy[i];
    await fetchForPair(p);
    await sleep(200);
  }
  const selected = $('selectedPair').innerText || pairs[0];
  if(selected) renderMini(selected);
  updateLiveList(); // Final update after all pairs are processed
}

// continuous loop
let running = true;
async function runLoop(){
  while(running){
    try {
      await fetchAllOnce();
    } catch(e){ console.error(e); }
    await sleep(refreshInterval);
  }
}

// ---------- Initialization ----------
(function init(){
  loadState();

  initPairs();
  const initialPair = $('selectedPair').innerText === '‚Äî' && pairs.length > 0 ? pairs[0] : $('selectedPair').innerText;
  selectPair(initialPair); 
  
  runLoop();
  log('System Initialized. Starting main loop.');
})();

</script>
</body>
</html>
