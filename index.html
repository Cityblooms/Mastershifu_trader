//+------------------------------------------------------------------+
//|                      InstitutionalProTrader.mq5                 |
//|                   Professional Grade v6.0 Enhanced             |
//|             Advanced Analytics & Adaptive Strategies           |
//+------------------------------------------------------------------+
#property copyright "Institutional Pro Trader v6.0"
#property version   "6.0"
#property description "Professional Trading System with Advanced Analytics & Adaptive Strategies"
#property indicator_chart_window
#property strict

//--- Includes
#include <Trade/Trade.mq5>
#include <Trade/AccountInfo.mqh>
#include <Trade/PositionInfo.mqh>
#include <Trade/SymbolInfo.mqh>
#include <Arrays/ArrayDouble.mqh>

//--- Input Parameters
input group "=== CORE TRADING SETTINGS ==="
input double LotSize          = 0.1;          // Fixed lot size
input bool   UseAutoLot       = true;         // Use automatic position sizing
input double RiskPercent      = 1.0;          // Risk per trade (%)
input int    MaxOrders        = 1;            // Maximum simultaneous trades
input int    MagicNumber      = 202406;       // Magic number
input double RiskRewardRatio  = 3.0;          // Risk:Reward ratio

input group "=== STRATEGY PRESETS ==="
input ENUM_STRATEGY_MODE StrategyMode = STRATEGY_BALANCED; // Trading strategy mode
input bool   UseAdaptiveMarketMode = true;    // Adapt to market conditions
input bool   EnableStrategyOptimizer = false; // Auto-optimize parameters

input group "=== PATTERN RECOGNITION ==="
input string IndicatorName    = "#4X Bheurekso Pattern.ex5"; // Pattern indicator
input bool   UseMultiPattern  = true;         // Combine multiple patterns
input bool   UseVolumeConfirmation = true;    // Volume-based confirmation
input int    PatternStrengthThreshold = 70;   // Minimum pattern strength (%)

input group "=== ADVANCED RISK MANAGEMENT ==="
input bool   UseDynamicRisk    = true;        // Adjust risk based on market
input double MaxDailyRisk      = 5.0;         // Maximum daily risk (%)
input bool   UseCorrelationProtection = true; // Protect against correlated pairs
input int    MaxDailyTrades    = 10;          // Maximum trades per day
input bool   UseDrawdownProtection = true;    // Emergency stop on drawdown
input double MaxDrawdownPercent = 15.0;       // Maximum allowed drawdown (%)

input group "=== PERFORMANCE ANALYTICS ==="
input bool   EnableLiveMetrics = true;        // Real-time performance tracking
input bool   ShowAdvancedStats = true;        // Display advanced statistics
input bool   LogTradeAnalytics = true;        // Log detailed trade analytics

//--- Enumerations
enum ENUM_STRATEGY_MODE {
    STRATEGY_CONSERVATIVE,    // Low risk, high confirmation
    STRATEGY_BALANCED,        // Balanced risk/reward
    STRATEGY_AGGRESSIVE,      // High risk, quick entries
    STRATEGY_SCALPING,        // Quick trades, small profits
    STRATEGY_SWING            // Longer term, larger moves
};

enum ENUM_MARKET_REGIME {
    MARKET_TRENDING,          // Strong directional movement
    MARKET_RANGING,           // Sideways consolidation
    MARKET_VOLATILE,          // High volatility
    MARKET_CALM               // Low volatility
};

//--- Global Variables
CTrade        trade;
CAccountInfo  account;
CPositionInfo position;
CSymbolInfo   symbol;

//--- Dashboard & Analytics
string dashboardName = "IPTv6_Dashboard_";
int panelWidth = 320;
int panelHeight = 280;

//--- Performance Tracking
struct TradeMetrics {
    int totalTrades;
    int winningTrades;
    int losingTrades;
    double totalProfit;
    double largestWin;
    double largestLoss;
    double winRate;
    double profitFactor;
    double averageWin;
    double averageLoss;
    double expectancy;
    datetime sessionStart;
    int tradesToday;
    double dailyProfit;
};

struct MarketAnalytics {
    ENUM_MARKET_REGIME currentRegime;
    double volatilityIndex;
    double trendStrength;
    double marketBias;
    bool highImpactTime;
    double atrRatio;
    double volumeProfile;
};

//--- Strategy Variables
TradeMetrics metrics;
MarketAnalytics market;
double dailyRiskUsed = 0.0;
int tradesToday = 0;
datetime lastTradeTime = 0;
double sessionStartBalance = 0.0;

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit() {
    // Initialize trading system
    if(!InitializeTradingSystem()) {
        Print("Error: Trading system initialization failed");
        return INIT_FAILED;
    }
    
    // Initialize analytics
    InitializeAnalytics();
    
    // Apply strategy preset
    ApplyStrategyPreset(StrategyMode);
    
    // Create advanced dashboard
    CreateAdvancedDashboard();
    
    Print("=== Institutional Pro Trader v6.0 Initialized ===");
    Print("Strategy Mode: ", EnumToString(StrategyMode));
    Print("Market Adaptation: ", UseAdaptiveMarketMode ? "Enabled" : "Disabled");
    Print("Advanced Analytics: ", EnableLiveMetrics ? "Enabled" : "Disabled");
    
    return INIT_SUCCEEDED;
}

//+------------------------------------------------------------------+
//| Initialize trading system                                       |
//+------------------------------------------------------------------+
bool InitializeTradingSystem() {
    symbol.Name(Symbol());
    symbol.Refresh();
    
    if(!symbol.Name()) {
        Print("Error: Symbol initialization failed");
        return false;
    }
    
    trade.SetExpertMagicNumber(MagicNumber);
    trade.SetDeviationInPoints(3);
    trade.SetAsyncMode(true);
    
    sessionStartBalance = account.Balance();
    
    return true;
}

//+------------------------------------------------------------------+
//| Initialize analytics system                                     |
//+------------------------------------------------------------------+
void InitializeAnalytics() {
    // Initialize metrics
    metrics.totalTrades = 0;
    metrics.winningTrades = 0;
    metrics.losingTrades = 0;
    metrics.totalProfit = 0.0;
    metrics.largestWin = 0.0;
    metrics.largestLoss = 0.0;
    metrics.winRate = 0.0;
    metrics.profitFactor = 0.0;
    metrics.sessionStart = TimeCurrent();
    metrics.tradesToday = 0;
    metrics.dailyProfit = 0.0;
    
    // Initialize market analytics
    market.currentRegime = MARKET_CALM;
    market.volatilityIndex = 0.0;
    market.trendStrength = 0.0;
    market.marketBias = 0.0;
    market.highImpactTime = false;
    market.atrRatio = 0.0;
    market.volumeProfile = 0.0;
}

//+------------------------------------------------------------------+
//| Apply strategy preset                                           |
//+------------------------------------------------------------------+
void ApplyStrategyPreset(ENUM_STRATEGY_MODE mode) {
    switch(mode) {
        case STRATEGY_CONSERVATIVE:
            RiskPercent = 0.5;
            RiskRewardRatio = 3.0;
            PatternStrengthThreshold = 80;
            MaxDailyTrades = 5;
            break;
            
        case STRATEGY_BALANCED:
            RiskPercent = 1.0;
            RiskRewardRatio = 2.5;
            PatternStrengthThreshold = 70;
            MaxDailyTrades = 10;
            break;
            
        case STRATEGY_AGGRESSIVE:
            RiskPercent = 2.0;
            RiskRewardRatio = 2.0;
            PatternStrengthThreshold = 60;
            MaxDailyTrades = 15;
            break;
            
        case STRATEGY_SCALPING:
            RiskPercent = 0.3;
            RiskRewardRatio = 1.5;
            PatternStrengthThreshold = 65;
            MaxDailyTrades = 20;
            break;
            
        case STRATEGY_SWING:
            RiskPercent = 1.5;
            RiskRewardRatio = 3.0;
            PatternStrengthThreshold = 75;
            MaxDailyTrades = 8;
            break;
    }
    
    Print("Strategy preset applied: ", EnumToString(mode));
}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick() {
    // Update market data
    symbol.Refresh();
    
    // Update market analytics
    UpdateMarketAnalytics();
    
    // Update dashboard
    UpdateAdvancedDashboard();
    
    // Check emergency conditions
    if(CheckEmergencyConditions()) {
        return;
    }
    
    // Process trading on new bar
    if(IsNewBar()) {
        // Update daily metrics
        UpdateDailyMetrics();
        
        // Adaptive strategy adjustment
        if(UseAdaptiveMarketMode) {
            AdaptiveStrategyAdjustment();
        }
        
        // Check trading conditions
        if(CheckEnhancedTradingConditions()) {
            ExecuteAdaptiveTradingStrategy();
        }
        
        // Manage positions with adaptive logic
        ManageAdaptivePositions();
    }
}

//+------------------------------------------------------------------+
//| Update market analytics                                         |
//+------------------------------------------------------------------+
void UpdateMarketAnalytics() {
    // Calculate volatility index (normalized ATR)
    double atr = iATR(Symbol(), PERIOD_H1, 14, 0);
    double atrPercent = (atr / symbol.Bid()) * 100;
    market.volatilityIndex = atrPercent;
    
    // Calculate trend strength
    market.trendStrength = CalculateTrendStrength();
    
    // Determine market regime
    market.currentRegime = DetermineMarketRegime();
    
    // Calculate market bias
    market.marketBias = CalculateMarketBias();
    
    // Check for high-impact news times
    market.highImpactTime = IsHighImpactTime();
    
    // Update volume profile
    market.volumeProfile = CalculateVolumeProfile();
    
    // Update ATR ratio
    market.atrRatio = CalculateAtrRatio();
}

//+------------------------------------------------------------------+
//| Calculate trend strength                                        |
//+------------------------------------------------------------------+
double CalculateTrendStrength() {
    double maFast = iMA(Symbol(), PERIOD_H1, 8, 0, MODE_SMA, PRICE_CLOSE, 0);
    double maSlow = iMA(Symbol(), PERIOD_H1, 21, 0, MODE_SMA, PRICE_CLOSE, 0);
    double maDiff = MathAbs(maFast - maSlow) / symbol.Point();
    
    // Normalize to 0-100 scale
    double strength = (maDiff / 50.0) * 100.0;
    return MathMin(MathMax(strength, 0.0), 100.0);
}

//+------------------------------------------------------------------+
//| Determine market regime                                         |
//+------------------------------------------------------------------+
ENUM_MARKET_REGIME DetermineMarketRegime() {
    double volatility = market.volatilityIndex;
    double trendStr = market.trendStrength;
    
    if(volatility > 0.8 && trendStr > 60.0) {
        return MARKET_TRENDING;
    } else if(volatility > 1.0) {
        return MARKET_VOLATILE;
    } else if(trendStr < 30.0 && volatility < 0.5) {
        return MARKET_RANGING;
    } else {
        return MARKET_CALM;
    }
}

//+------------------------------------------------------------------+
//| Calculate market bias                                           |
//+------------------------------------------------------------------+
double CalculateMarketBias() {
    // Use multiple timeframes for bias calculation
    double biasM15 = CalculateBiasForTimeframe(PERIOD_M15);
    double biasH1 = CalculateBiasForTimeframe(PERIOD_H1);
    double biasH4 = CalculateBiasForTimeframe(PERIOD_H4);
    
    // Weighted average (more weight to higher timeframes)
    return (biasM15 * 0.2 + biasH1 * 0.3 + biasH4 * 0.5);
}

//+------------------------------------------------------------------+
//| Calculate bias for specific timeframe                           |
//+------------------------------------------------------------------+
double CalculateBiasForTimeframe(ENUM_TIMEFRAMES tf) {
    double maFast = iMA(Symbol(), tf, 8, 0, MODE_SMA, PRICE_CLOSE, 0);
    double maSlow = iMA(Symbol(), tf, 21, 0, MODE_SMA, PRICE_CLOSE, 0);
    double rsi = iRSI(Symbol(), tf, 14, PRICE_CLOSE, 0);
    
    double bias = 0.0;
    if(maFast > maSlow) bias += 0.5;
    if(rsi > 50) bias += 0.3;
    if(symbol.Bid() > maSlow) bias += 0.2;
    
    return bias;
}

//+------------------------------------------------------------------+
//| Check emergency conditions                                      |
//+------------------------------------------------------------------+
bool CheckEmergencyConditions() {
    // Check drawdown protection
    if(UseDrawdownProtection) {
        double currentBalance = account.Balance();
        double drawdownPercent = ((sessionStartBalance - currentBalance) / sessionStartBalance) * 100.0;
        
        if(drawdownPercent >= MaxDrawdownPercent) {
            CloseAllPositions();
            Print("EMERGENCY: Maximum drawdown reached! All positions closed.");
            return true;
        }
    }
    
    // Check daily risk limit
    if(dailyRiskUsed >= MaxDailyRisk) {
        Print("WARNING: Daily risk limit reached. Trading paused.");
        return true;
    }
    
    // Check daily trade limit
    if(tradesToday >= MaxDailyTrades) {
        Print("WARNING: Daily trade limit reached. Trading paused.");
        return true;
    }
    
    return false;
}

//+------------------------------------------------------------------+
//| Adaptive strategy adjustment                                    |
//+------------------------------------------------------------------+
void AdaptiveStrategyAdjustment() {
    switch(market.currentRegime) {
        case MARKET_TRENDING:
            // Increase position sizes in trends
            if(RiskPercent < 2.0) RiskPercent *= 1.2;
            break;
            
        case MARKET_VOLATILE:
            // Reduce risk in high volatility
            RiskPercent *= 0.7;
            break;
            
        case MARKET_RANGING:
            // Use smaller positions in ranges
            RiskPercent *= 0.8;
            break;
            
        case MARKET_CALM:
            // Normal risk in calm markets
            break;
    }
    
    // Ensure risk stays within bounds
    RiskPercent = MathMin(MathMax(RiskPercent, 0.1), 5.0);
}

//+------------------------------------------------------------------+
//| Enhanced trading conditions check                               |
//+------------------------------------------------------------------+
bool CheckEnhancedTradingConditions() {
    // Basic checks
    if(CountOpenPositions() >= MaxOrders) return false;
    if(symbol.Spread() > 50 * symbol.Point()) return false;
    
    // Market regime filters
    if(market.currentRegime == MARKET_VOLATILE && !IsStrategyCompatible(STRATEGY_AGGRESSIVE)) {
        return false;
    }
    
    // Time filters
    if(market.highImpactTime) {
        Print("High impact time detected - trading paused");
        return false;
    }
    
    // Volume confirmation
    if(UseVolumeConfirmation && !CheckVolumeConfirmation()) {
        return false;
    }
    
    return true;
}

//+------------------------------------------------------------------+
//| Execute adaptive trading strategy                               |
//+------------------------------------------------------------------+
void ExecuteAdaptiveTradingStrategy() {
    // Get enhanced signal with market context
    TradingSignal signal = GenerateEnhancedSignal();
    
    if(signal.confidence >= (PatternStrengthThreshold / 100.0)) {
        // Adjust position size based on market conditions
        double adjustedLotSize = CalculateAdaptiveLotSize(signal);
        
        // Execute trade with enhanced risk management
        ExecuteTradeWithAdaptiveRisk(signal, adjustedLotSize);
        
        // Update metrics
        UpdateTradeMetrics();
    }
}

//+------------------------------------------------------------------+
//| Calculate adaptive lot size                                     |
//+------------------------------------------------------------------+
double CalculateAdaptiveLotSize(TradingSignal &signal) {
    double baseLotSize = CalculateLotSize();
    
    // Adjust based on market regime
    double adjustmentFactor = 1.0;
    
    switch(market.currentRegime) {
        case MARKET_TRENDING:
            adjustmentFactor = 1.2; // Increase in trends
            break;
        case MARKET_VOLATILE:
            adjustmentFactor = 0.7; // Decrease in high volatility
            break;
        case MARKET_RANGING:
            adjustmentFactor = 0.8; // Slight decrease in ranges
            break;
        case MARKET_CALM:
            adjustmentFactor = 1.0; // Normal in calm markets
            break;
    }
    
    // Adjust based on signal confidence
    adjustmentFactor *= signal.confidence;
    
    // Adjust based on time of day
    if(IsHighImpactTime()) {
        adjustmentFactor *= 0.5;
    }
    
    double adjustedLotSize = baseLotSize * adjustmentFactor;
    return MathMin(adjustedLotSize, symbol.LotsMax());
}

//+------------------------------------------------------------------+
//| Enhanced position management                                    |
//+------------------------------------------------------------------+
void ManageAdaptivePositions() {
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(PositionGetInteger(POSITION_MAGIC) == MagicNumber && 
           PositionGetString(POSITION_SYMBOL) == symbol.Name()) {
            
            // Adaptive trailing stop
            ApplyAdaptiveTrailingStop(ticket);
            
            // Dynamic breakeven
            ApplyDynamicBreakeven(ticket);
            
            // Partial profit taking
            if(ShouldTakePartialProfit(ticket)) {
                TakePartialProfit(ticket);
            }
        }
    }
}

//+------------------------------------------------------------------+
//| Apply adaptive trailing stop                                    |
//+------------------------------------------------------------------+
void ApplyAdaptiveTrailingStop(ulong ticket) {
    if(!PositionSelectByTicket(ticket)) return;
    
    double currentSL = PositionGetDouble(POSITION_SL);
    double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
    double currentPrice = PositionGetDouble(POSITION_PRICE_CURRENT);
    ENUM_POSITION_TYPE type = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
    
    double risk = MathAbs(openPrice - currentSL);
    double profit = MathAbs(currentPrice - openPrice);
    
    // Adaptive trail start based on market volatility
    double trailStartRR = market.volatilityIndex > 1.0 ? 2.0 : 1.5;
    
    if(profit < risk * trailStartRR) return;
    
    // Adaptive trail distance based on ATR
    double atr = iATR(symbol.Name(), Period(), 14, 0);
    double trailDistance = atr * 0.5; // 0.5 ATR trailing stop
    
    double newSL = 0;
    if(type == POSITION_TYPE_BUY) {
        newSL = currentPrice - trailDistance;
        if(newSL > currentSL) {
            trade.PositionModify(ticket, newSL, PositionGetDouble(POSITION_TP));
        }
    } else {
        newSL = currentPrice + trailDistance;
        if(newSL < currentSL) {
            trade.PositionModify(ticket, newSL, PositionGetDouble(POSITION_TP));
        }
    }
}

//+------------------------------------------------------------------+
//| Take partial profits                                            |
//+------------------------------------------------------------------+
bool ShouldTakePartialProfit(ulong ticket) {
    if(!PositionSelectByTicket(ticket)) return false;
    
    double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
    double currentPrice = PositionGetDouble(POSITION_PRICE_CURRENT);
    double tpPrice = PositionGetDouble(POSITION_TP);
    
    double profit = MathAbs(currentPrice - openPrice);
    double totalPotential = MathAbs(tpPrice - openPrice);
    
    // Take partial at 50% of target
    return (profit >= totalPotential * 0.5);
}

void TakePartialProfit(ulong ticket) {
    if(!PositionSelectByTicket(ticket)) return;
    
    double currentVolume = PositionGetDouble(POSITION_VOLUME);
    if(currentVolume > symbol.LotsMin() * 2) {
        double closeVolume = currentVolume * 0.5; // Close 50%
        trade.PositionClosePartial(ticket, closeVolume);
        Print("Partial profit taken: ", closeVolume, " lots");
    }
}

//+------------------------------------------------------------------+
//| Update performance metrics                                      |
//+------------------------------------------------------------------+
void UpdateTradeMetrics() {
    // This would be called when trades are opened/closed
    // Implementation would track all trade statistics
}

void UpdateDailyMetrics() {
    MqlDateTime today;
    TimeCurrent(today);
    today.hour = 0;
    today.min = 0;
    today.sec = 0;
    
    datetime startOfDay = StructToTime(today);
    
    // Reset daily metrics if new day
    if(metrics.sessionStart < startOfDay) {
        metrics.tradesToday = 0;
        metrics.dailyProfit = 0.0;
        dailyRiskUsed = 0.0;
        metrics.sessionStart = TimeCurrent();
    }
}

//+------------------------------------------------------------------+
//| Create advanced dashboard                                       |
//+------------------------------------------------------------------+
void CreateAdvancedDashboard() {
    // Main panel
    CreatePanel("MainPanel", 5, 20, panelWidth, panelHeight, clrDarkSlateGray, clrDimGray, true);
    
    // Title section
    CreateLabel("Title", 15, 25, "INSTITUTIONAL PRO TRADER v6.0", 11, clrGold, CORNER_LEFT_UPPER);
    CreateLabel("SubTitle", 15, 45, "Advanced Analytics Edition", 8, clrSilver, CORNER_LEFT_UPPER);
    
    // Strategy section
    CreateLabel("StrategyLabel", 15, 70, "STRATEGY:", 9, clrWhite, CORNER_LEFT_UPPER);
    CreateLabel("StrategyValue", 85, 70, EnumToString(StrategyMode), 9, clrYellow, CORNER_LEFT_UPPER);
    
    CreateLabel("RegimeLabel", 15, 90, "MARKET REGIME:", 9, clrWhite, CORNER_LEFT_UPPER);
    CreateLabel("RegimeValue", 120, 90, "ANALYZING", 9, clrLime, CORNER_LEFT_UPPER);
    
    // Performance section
    CreateLabel("WinRateLabel", 15, 115, "WIN RATE:", 9, clrWhite, CORNER_LEFT_UPPER);
    CreateLabel("WinRateValue", 85, 115, "0.0%", 9, clrWhite, CORNER_LEFT_UPPER);
    
    CreateLabel("ProfitLabel", 15, 135, "DAILY P/L:", 9, clrWhite, CORNER_LEFT_UPPER);
    CreateLabel("ProfitValue", 85, 135, "0.00", 9, clrLime, CORNER_LEFT_UPPER);
    
    // Market analytics section
    CreateLabel("VolatilityLabel", 15, 160, "VOLATILITY:", 9, clrWhite, CORNER_LEFT_UPPER);
    CreateLabel("VolatilityValue", 85, 160, "0.0", 9, clrWhite, CORNER_LEFT_UPPER);
    
    CreateLabel("TrendLabel", 15, 180, "TREND STR:", 9, clrWhite, CORNER_LEFT_UPPER);
    CreateLabel("TrendValue", 85, 180, "0.0", 9, clrWhite, CORNER_LEFT_UPPER);
    
    // Risk management section
    CreateLabel("RiskLabel", 15, 205, "RISK USED:", 9, clrWhite, CORNER_LEFT_UPPER);
    CreateLabel("RiskValue", 85, 205, "0.0%", 9, clrWhite, CORNER_LEFT_UPPER);
    
    CreateLabel("TradesLabel", 15, 225, "TRADES TODAY:", 9, clrWhite, CORNER_LEFT_UPPER);
    CreateLabel("TradesValue", 105, 225, "0/"+string(MaxDailyTrades), 9, clrWhite, CORNER_LEFT_UPPER);
    
    // Status section
    CreateLabel("StatusLabel", 15, 250, "STATUS:", 9, clrWhite, CORNER_LEFT_UPPER);
    CreateLabel("StatusValue", 65, 250, "ANALYZING", 9, clrLime, CORNER_LEFT_UPPER);
}

//+------------------------------------------------------------------+
//| Update advanced dashboard                                       |
//+------------------------------------------------------------------+
void UpdateAdvancedDashboard() {
    // Update strategy info
    ObjectSetString(0, dashboardName+"StrategyValue", OBJPROP_TEXT, EnumToString(StrategyMode));
    ObjectSetString(0, dashboardName+"RegimeValue", OBJPROP_TEXT, EnumToString(market.currentRegime));
    
    // Update performance
    ObjectSetString(0, dashboardName+"WinRateValue", OBJPROP_TEXT, DoubleToString(metrics.winRate, 1)+"%");
    
    string profitText = DoubleToString(metrics.dailyProfit, 2);
    color profitColor = metrics.dailyProfit >= 0 ? clrLime : clrRed;
    ObjectSetString(0, dashboardName+"ProfitValue", OBJPROP_TEXT, profitText);
    ObjectSetInteger(0, dashboardName+"ProfitValue", OBJPROP_COLOR, profitColor);
    
    // Update market analytics
    ObjectSetString(0, dashboardName+"VolatilityValue", OBJPROP_TEXT, DoubleToString(market.volatilityIndex, 2)+"%");
    ObjectSetString(0, dashboardName+"TrendValue", OBJPROP_TEXT, DoubleToString(market.trendStrength, 1));
    
    // Update risk management
    ObjectSetString(0, dashboardName+"RiskValue", OBJPROP_TEXT, DoubleToString(dailyRiskUsed, 1)+"%");
    ObjectSetString(0, dashboardName+"TradesValue", OBJPROP_TEXT, string(tradesToday)+"/"+string(MaxDailyTrades));
    
    // Update status
    string status = CheckEmergencyConditions() ? "PAUSED" : "ACTIVE";
    color statusColor = CheckEmergencyConditions() ? clrOrange : clrLime;
    ObjectSetString(0, dashboardName+"StatusValue", OBJPROP_TEXT, status);
    ObjectSetInteger(0, dashboardName+"StatusValue", OBJPROP_COLOR, statusColor);
}

//+------------------------------------------------------------------+
//| Utility Functions                                               |
//+------------------------------------------------------------------+
bool IsNewBar() {
    static datetime lastBar = 0;
    datetime currentBar = iTime(Symbol(), Period(), 0);
    if(currentBar != lastBar) {
        lastBar = currentBar;
        return true;
    }
    return false;
}

int CountOpenPositions() {
    int count = 0;
    for(int i = 0; i < PositionsTotal(); i++) {
        if(PositionGetTicket(i)) {
            if(PositionGetInteger(POSITION_MAGIC) == MagicNumber && 
               PositionGetString(POSITION_SYMBOL) == Symbol()) {
                count++;
            }
        }
    }
    return count;
}

void CloseAllPositions() {
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(PositionGetInteger(POSITION_MAGIC) == MagicNumber) {
            trade.PositionClose(ticket);
        }
    }
}

bool IsHighImpactTime() {
    // Simplified implementation - in production, integrate with economic calendar
    MqlDateTime timeNow;
    TimeCurrent(timeNow);
    
    // Example: Avoid London/New York overlap (13:00-16:00 GMT)
    if(timeNow.hour >= 13 && timeNow.hour < 16) {
        return true;
    }
    
    return false;
}

bool IsStrategyCompatible(ENUM_STRATEGY_MODE mode) {
    // Check if current market regime is compatible with strategy
    switch(market.currentRegime) {
        case MARKET_VOLATILE:
            return (mode == STRATEGY_AGGRESSIVE || mode == STRATEGY_SCALPING);
        case MARKET_TRENDING:
            return (mode == STRATEGY_SWING || mode == STRATEGY_BALANCED);
        case MARKET_RANGING:
            return (mode == STRATEGY_SCALPING || mode == STRATEGY_CONSERVATIVE);
        default:
            return true;
    }
}

bool CheckVolumeConfirmation() {
    long currentVolume = iVolume(Symbol(), Period(), 0);
    long avgVolume = 0;
    
    for(int i = 1; i <= 20; i++) {
        avgVolume += iVolume(Symbol(), Period(), i);
    }
    avgVolume /= 20;
    
    return currentVolume > avgVolume * 1.2;
}

double CalculateVolumeProfile() {
    // Simplified volume profile calculation
    long totalVolume = 0;
    for(int i = 0; i < 50; i++) {
        totalVolume += iVolume(Symbol(), Period(), i);
    }
    return (double)totalVolume / 50.0;
}

double CalculateAtrRatio() {
    double atrCurrent = iATR(Symbol(), Period(), 14, 0);
    double atrDaily = iATR(Symbol(), PERIOD_D1, 14, 0);
    
    if(atrDaily > 0) {
        return atrCurrent / atrDaily;
    }
    return 1.0;
}

//+------------------------------------------------------------------+
//| Placeholder structures for complete implementation              |
//+------------------------------------------------------------------+
struct TradingSignal {
    string direction;
    double confidence;
    double entry;
    double sl;
    double tp;
    string pattern;
};

TradingSignal GenerateEnhancedSignal() {
    TradingSignal signal;
    // Implementation would generate signals based on pattern recognition
    signal.direction = "NONE";
    signal.confidence = 0.0;
    return signal;
}

void ExecuteTradeWithAdaptiveRisk(TradingSignal signal, double lotSize) {
    // Implementation would execute trades with enhanced risk management
}

void ApplyDynamicBreakeven(ulong ticket) {
    // Implementation would apply dynamic breakeven logic
}

//+------------------------------------------------------------------+
//| Dashboard helper functions                                      |
//+------------------------------------------------------------------+
void CreatePanel(string name, int x, int y, int width, int height, color bgColor, color borderColor, bool back=false) {
    name = dashboardName + name;
    if(ObjectFind(0, name) < 0) {
        ObjectCreate(0, name, OBJ_RECTANGLE_LABEL, 0, 0, 0);
        ObjectSetInteger(0, name, OBJPROP_XDISTANCE, x);
        ObjectSetInteger(0, name, OBJPROP_YDISTANCE, y);
        ObjectSetInteger(0, name, OBJPROP_XSIZE, width);
        ObjectSetInteger(0, name, OBJPROP_YSIZE, height);
        ObjectSetInteger(0, name, OBJPROP_BGCOLOR, bgColor);
        ObjectSetInteger(0, name, OBJPROP_BORDER_COLOR, borderColor);
        ObjectSetInteger(0, name, OBJPROP_BACK, back);
        ObjectSetInteger(0, name, OBJPROP_SELECTABLE, false);
    }
}

void CreateLabel(string name, int x, int y, string text, int fontSize, color textColor, int corner=CORNER_LEFT_UPPER) {
    name = dashboardName + name;
    if(ObjectFind(0, name) < 0) {
        ObjectCreate(0, name, OBJ_LABEL, 0, 0, 0);
        ObjectSetInteger(0, name, OBJPROP_XDISTANCE, x);
        ObjectSetInteger(0, name, OBJPROP_YDISTANCE, y);
        ObjectSetString(0, name, OBJPROP_TEXT, text);
        ObjectSetInteger(0, name, OBJPROP_COLOR, textColor);
        ObjectSetInteger(0, name, OBJPROP_FONTSIZE, fontSize);
        ObjectSetInteger(0, name, OBJPROP_CORNER, corner);
        ObjectSetInteger(0, name, OBJPROP_SELECTABLE, false);
    }
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                               |
//+------------------------------------------------------------------+
void OnDeinit(const int reason) {
    ObjectsDeleteAll(0, dashboardName);
    
    // Log final performance metrics
    if(LogTradeAnalytics) {
        Print("=== Session Performance Summary ===");
        Print("Total Trades: ", metrics.totalTrades);
        Print("Win Rate: ", DoubleToString(metrics.winRate, 1), "%");
        Print("Total Profit: ", DoubleToString(metrics.totalProfit, 2));
        Print("Profit Factor: ", DoubleToString(metrics.profitFactor, 2));
    }
    
    Print("Institutional Pro Trader v6.0 shutdown complete");
}
//+------------------------------------------------------------------+
