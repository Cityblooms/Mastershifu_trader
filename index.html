<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>KILLER ZONE PRO - Advanced Deriv WebSocket Signal Engine</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<style>
  /* ========== BASE & RESET ========== */
  :root {
    --primary: #00d4ff;
    --primary-dark: #0097a7;
    --secondary: #7c4dff;
    --success: #4caf50;
    --danger: #f44336;
    --warning: #ff9800;
    --dark-bg: #0a0e17;
    --dark-card: #1a1f2e;
    --dark-border: #2a3142;
    --text-primary: #ffffff;
    --text-secondary: #b0bec5;
    --text-muted: #78909c;
    --buy-gradient: linear-gradient(135deg, rgba(27, 94, 32, 0.9), rgba(46, 125, 50, 0.9));
    --sell-gradient: linear-gradient(135deg, rgba(183, 28, 28, 0.9), rgba(198, 40, 40, 0.9));
    --hold-gradient: linear-gradient(135deg, rgba(26, 35, 126, 0.9), rgba(13, 71, 161, 0.9));
  }
  
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }
  
  html {
    font-size: 16px;
  }
  
  body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: linear-gradient(135deg, var(--dark-bg) 0%, #121a2b 100%);
    color: var(--text-primary);
    min-height: 100vh;
    line-height: 1.6;
    overflow-x: hidden;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }
  
  /* ========== LAYOUT ========== */
  .app-container {
    display: flex;
    flex-direction: column;
    min-height: 100vh;
    max-width: 100%;
    padding: 0;
  }
  
  /* ========== HEADER ========== */
  .app-header {
    background: rgba(26, 31, 46, 0.95);
    backdrop-filter: blur(10px);
    padding: 1rem 1.5rem;
    border-bottom: 1px solid var(--dark-border);
    position: sticky;
    top: 0;
    z-index: 100;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  
  .logo-container {
    display: flex;
    align-items: center;
    gap: 12px;
  }
  
  .logo-icon {
    width: 40px;
    height: 40px;
    background: linear-gradient(135deg, var(--primary), var(--secondary));
    border-radius: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
  }
  
  .logo-text h1 {
    font-size: 1.5rem;
    font-weight: 700;
    background: linear-gradient(to right, var(--primary), var(--secondary));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    line-height: 1.2;
  }
  
  .logo-text .subtitle {
    font-size: 0.75rem;
    color: var(--text-muted);
    letter-spacing: 1px;
  }
  
  .header-actions {
    display: flex;
    gap: 10px;
  }
  
  .status-badge {
    padding: 6px 12px;
    background: rgba(76, 175, 80, 0.2);
    border: 1px solid rgba(76, 175, 80, 0.3);
    border-radius: 20px;
    font-size: 0.8rem;
    display: flex;
    align-items: center;
    gap: 6px;
  }
  
  .status-badge.offline {
    background: rgba(244, 67, 54, 0.2);
    border-color: rgba(244, 67, 54, 0.3);
  }
  
  .status-badge.connecting {
    background: rgba(255, 152, 0, 0.2);
    border-color: rgba(255, 152, 0, 0.3);
  }
  
  .status-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: var(--success);
  }
  
  .status-dot.offline {
    background: var(--danger);
  }
  
  .status-dot.connecting {
    background: var(--warning);
    animation: pulse 1.5s infinite;
  }
  
  @keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.3; }
    100% { opacity: 1; }
  }
  
  /* ========== MAIN CONTENT ========== */
  .main-content {
    flex: 1;
    padding: 1.5rem;
    display: grid;
    grid-template-columns: 1fr;
    gap: 1.5rem;
    max-width: 1600px;
    margin: 0 auto;
    width: 100%;
  }
  
  @media (min-width: 1024px) {
    .main-content {
      grid-template-columns: 400px 1fr;
    }
  }
  
  /* ========== CARDS ========== */
  .card {
    background: var(--dark-card);
    border-radius: 16px;
    border: 1px solid var(--dark-border);
    overflow: hidden;
    transition: all 0.3s ease;
  }
  
  .card:hover {
    border-color: rgba(124, 77, 255, 0.3);
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
  }
  
  .card-header {
    padding: 1.25rem 1.5rem;
    border-bottom: 1px solid var(--dark-border);
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  
  .card-header h2 {
    font-size: 1.1rem;
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 10px;
  }
  
  .card-header .card-icon {
    color: var(--primary);
    font-size: 1.2rem;
  }
  
  .card-body {
    padding: 1.5rem;
  }
  
  /* ========== ALL ASSETS SIGNALS DISPLAY ========== */
  .all-assets-signals {
    display: grid;
    grid-template-columns: repeat(1, 1fr);
    gap: 1rem;
    margin-bottom: 1.5rem;
  }
  
  @media (min-width: 768px) {
    .all-assets-signals {
      grid-template-columns: repeat(2, 1fr);
    }
  }
  
  @media (min-width: 1200px) {
    .all-assets-signals {
      grid-template-columns: repeat(3, 1fr);
    }
  }
  
  .asset-signal-card {
    background: rgba(37, 45, 66, 0.7);
    border-radius: 12px;
    padding: 1.25rem;
    display: flex;
    align-items: center;
    gap: 15px;
    transition: all 0.3s;
    border: 2px solid transparent;
    cursor: pointer;
    position: relative;
    overflow: hidden;
  }
  
  .asset-signal-card.buy-signal {
    border-color: rgba(76, 175, 80, 0.5);
    background: linear-gradient(135deg, rgba(27, 94, 32, 0.2), rgba(46, 125, 50, 0.2));
  }
  
  .asset-signal-card.sell-signal {
    border-color: rgba(244, 67, 54, 0.5);
    background: linear-gradient(135deg, rgba(183, 28, 28, 0.2), rgba(198, 40, 40, 0.2));
  }
  
  .asset-signal-card.hold-signal {
    border-color: rgba(255, 152, 0, 0.3);
    background: rgba(255, 152, 0, 0.1);
  }
  
  .asset-icon-large {
    width: 50px;
    height: 50px;
    border-radius: 10px;
    background: rgba(0, 212, 255, 0.1);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.5rem;
    color: var(--primary);
  }
  
  .asset-signal-info {
    flex: 1;
  }
  
  .asset-name-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 5px;
  }
  
  .asset-name {
    font-weight: 600;
    font-size: 1rem;
  }
  
  .signal-badge {
    padding: 4px 10px;
    border-radius: 20px;
    font-size: 0.75rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  
  .signal-badge.buy {
    background: rgba(76, 175, 80, 0.3);
    color: #4caf50;
    box-shadow: 0 0 10px rgba(76, 175, 80, 0.3);
  }
  
  .signal-badge.sell {
    background: rgba(244, 67, 54, 0.3);
    color: #f44336;
    box-shadow: 0 0 10px rgba(244, 67, 54, 0.3);
  }
  
  .signal-badge.hold {
    background: rgba(255, 152, 0, 0.3);
    color: #ff9800;
  }
  
  .asset-details {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 0.85rem;
  }
  
  .asset-price {
    color: var(--text-primary);
    font-weight: 600;
  }
  
  .asset-rsi {
    color: var(--primary);
    font-weight: 600;
  }
  
  .signal-strength {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 3px;
    background: rgba(255, 255, 255, 0.1);
  }
  
  .strength-fill {
    height: 100%;
    transition: width 0.5s ease;
  }
  
  .strength-fill.buy {
    background: var(--success);
  }
  
  .strength-fill.sell {
    background: var(--danger);
  }
  
  /* ========== ENHANCED MAIN SIGNAL DISPLAY ========== */
  .signal-display-card {
    background: var(--hold-gradient);
    border: none;
    position: relative;
    overflow: hidden;
    min-height: 300px;
  }
  
  .signal-display-card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 4px;
    background: var(--primary);
  }
  
  .signal-display-card.buy-signal {
    background: var(--buy-gradient);
    animation: pulse-glow-buy 2s infinite;
  }
  
  .signal-display-card.sell-signal {
    background: var(--sell-gradient);
    animation: pulse-glow-sell 2s infinite;
  }
  
  @keyframes pulse-glow-buy {
    0%, 100% { box-shadow: 0 0 20px rgba(76, 175, 80, 0.3); }
    50% { box-shadow: 0 0 40px rgba(76, 175, 80, 0.6); }
  }
  
  @keyframes pulse-glow-sell {
    0%, 100% { box-shadow: 0 0 20px rgba(244, 67, 54, 0.3); }
    50% { box-shadow: 0 0 40px rgba(244, 67, 54, 0.6); }
  }
  
  .signal-main {
    text-align: center;
    padding: 2rem 1rem;
  }
  
  .signal-label {
    font-size: 0.9rem;
    text-transform: uppercase;
    letter-spacing: 2px;
    color: rgba(255, 255, 255, 0.9);
    margin-bottom: 1rem;
  }
  
  .signal-text {
    font-size: 4rem;
    font-weight: 900;
    margin-bottom: 0.5rem;
    text-shadow: 0 2px 15px rgba(0, 0, 0, 0.5);
    letter-spacing: 1px;
  }
  
  @media (min-width: 768px) {
    .signal-text {
      font-size: 5rem;
    }
  }
  
  .rsi-value {
    font-size: 2.5rem;
    font-weight: 700;
    margin-bottom: 1.5rem;
  }
  
  .signal-quality {
    display: inline-block;
    padding: 6px 15px;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 20px;
    font-size: 0.9rem;
    margin-bottom: 1.5rem;
  }
  
  .signal-details {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 1.5rem;
    margin-top: 1.5rem;
  }
  
  .signal-detail-item {
    text-align: center;
    padding: 15px;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 10px;
  }
  
  .detail-label {
    font-size: 0.8rem;
    color: rgba(255, 255, 255, 0.8);
    margin-bottom: 6px;
  }
  
  .detail-value {
    font-size: 1.2rem;
    font-weight: 700;
  }
  
  /* ========== STRATEGY INDICATORS PANEL ========== */
  .strategy-panel {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 1rem;
    margin: 1.5rem 0;
  }
  
  .strategy-indicator {
    padding: 15px;
    background: rgba(37, 45, 66, 0.5);
    border-radius: 10px;
    text-align: center;
  }
  
  .indicator-label {
    font-size: 0.8rem;
    color: var(--text-muted);
    margin-bottom: 5px;
  }
  
  .indicator-value {
    font-size: 1.1rem;
    font-weight: 600;
  }
  
  .indicator-value.positive {
    color: var(--success);
  }
  
  .indicator-value.negative {
    color: var(--danger);
  }
  
  /* ========== MULTI-TIMEFRAME DISPLAY ========== */
  .timeframe-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
    margin: 1rem 0;
  }
  
  .timeframe-item {
    padding: 10px;
    background: rgba(37, 45, 66, 0.5);
    border-radius: 8px;
    text-align: center;
    font-size: 0.85rem;
  }
  
  .timeframe-item.active {
    background: rgba(0, 212, 255, 0.2);
    border: 1px solid var(--primary);
  }
  
  /* ========== ENHANCED WEB SOCKET STATUS ========== */
  .websocket-status {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px 20px;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 12px;
    margin-bottom: 1.5rem;
    border: 1px solid var(--dark-border);
  }
  
  .ws-info {
    display: flex;
    align-items: center;
    gap: 12px;
  }
  
  .ws-dot {
    width: 12px;
    height: 12px;
    border-radius: 50%;
  }
  
  .ws-dot.connected {
    background: var(--success);
    box-shadow: 0 0 10px var(--success);
    animation: pulse 2s infinite;
  }
  
  .ws-dot.disconnected {
    background: var(--danger);
  }
  
  .ws-dot.connecting {
    background: var(--warning);
    animation: pulse 1.5s infinite;
  }
  
  .ws-stats {
    display: flex;
    gap: 20px;
  }
  
  .ws-stat {
    text-align: center;
    min-width: 70px;
  }
  
  .ws-stat-value {
    font-weight: 800;
    font-size: 1.2rem;
    color: var(--primary);
  }
  
  .ws-stat-label {
    color: var(--text-muted);
    font-size: 0.75rem;
    margin-top: 2px;
  }
  
  /* ========== ENHANCED METRICS GRID ========== */
  .metrics-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 1rem;
    margin-bottom: 1.5rem;
  }
  
  @media (min-width: 768px) {
    .metrics-grid {
      grid-template-columns: repeat(4, 1fr);
    }
  }
  
  .metric-card {
    padding: 1.25rem;
    background: rgba(37, 45, 66, 0.5);
    border-radius: 12px;
    text-align: center;
    transition: all 0.3s;
    border: 1px solid var(--dark-border);
  }
  
  .metric-card:hover {
    background: rgba(37, 45, 66, 0.8);
    transform: translateY(-3px);
    border-color: var(--primary);
  }
  
  .metric-icon {
    font-size: 1.5rem;
    margin-bottom: 10px;
    color: var(--primary);
  }
  
  .metric-value {
    font-size: 2rem;
    font-weight: 800;
    margin-bottom: 5px;
  }
  
  .metric-label {
    font-size: 0.85rem;
    color: var(--text-muted);
  }
  
  /* ========== ADVANCED STOCHASTIC INDICATOR ========== */
  .stochastic-container {
    position: relative;
    height: 100px;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 12px;
    margin: 1.5rem 0;
    overflow: hidden;
  }
  
  .stochastic-levels {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    display: flex;
  }
  
  .stochastic-zone {
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 700;
    font-size: 0.9rem;
  }
  
  .zone-oversold {
    background: linear-gradient(135deg, rgba(76, 175, 80, 0.3), rgba(76, 175, 80, 0.1));
    color: var(--success);
    flex: 0 0 20%;
  }
  
  .zone-buy {
    background: rgba(76, 175, 80, 0.1);
    color: #8bc34a;
    flex: 0 0 10%;
  }
  
  .zone-neutral {
    background: rgba(255, 255, 255, 0.05);
    flex: 1;
  }
  
  .zone-sell {
    background: rgba(244, 67, 54, 0.1);
    color: #ff5722;
    flex: 0 0 10%;
  }
  
  .zone-overbought {
    background: linear-gradient(135deg, rgba(244, 67, 54, 0.1), rgba(244, 67, 54, 0.3));
    color: var(--danger);
    flex: 0 0 20%;
  }
  
  .stochastic-indicator {
    position: absolute;
    top: 50%;
    transform: translate(-50%, -50%);
    width: 50px;
    height: 50px;
    background: var(--primary);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 900;
    color: var(--dark-bg);
    box-shadow: 0 0 25px rgba(0, 212, 255, 0.8);
    z-index: 10;
    transition: left 0.5s ease;
    border: 3px solid white;
  }
  
  /* ========== BUTTONS ========== */
  .btn {
    padding: 14px 24px;
    border: none;
    border-radius: 10px;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.3s;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    font-size: 0.95rem;
    letter-spacing: 0.5px;
  }
  
  .btn-primary {
    background: linear-gradient(135deg, var(--primary), var(--secondary));
    color: white;
  }
  
  .btn-primary:hover:not(:disabled) {
    transform: translateY(-3px);
    box-shadow: 0 10px 25px rgba(124, 77, 255, 0.4);
  }
  
  .btn-primary:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
  
  .btn-success {
    background: linear-gradient(135deg, var(--success), #2e7d32);
    color: white;
  }
  
  .btn-danger {
    background: linear-gradient(135deg, var(--danger), #d32f2f);
    color: white;
  }
  
  .btn-group {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px;
    margin-top: 1.5rem;
  }
  
  /* ========== LOGS ========== */
  .logs-container {
    max-height: 250px;
    overflow-y: auto;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 10px;
    padding: 1rem;
  }
  
  .log-entry {
    padding: 10px 0;
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    display: flex;
    align-items: center;
    gap: 12px;
  }
  
  .log-time {
    color: var(--text-muted);
    font-size: 0.8rem;
    min-width: 70px;
  }
  
  .log-content {
    flex: 1;
    font-size: 0.9rem;
  }
  
  .log-buy {
    color: var(--success);
    font-weight: 600;
  }
  
  .log-sell {
    color: var(--danger);
    font-weight: 600;
  }
  
  .log-system {
    color: var(--primary);
  }
  
  .log-error {
    color: var(--danger);
  }
  
  .log-success {
    color: var(--success);
  }
  
  .log-deriv {
    color: #7c4dff;
  }
  
  /* ========== MOBILE NAVIGATION ========== */
  .mobile-nav {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    background: var(--dark-card);
    border-top: 1px solid var(--dark-border);
    display: flex;
    justify-content: space-around;
    padding: 12px 10px;
    z-index: 100;
    backdrop-filter: blur(10px);
  }
  
  @media (min-width: 1024px) {
    .mobile-nav {
      display: none;
    }
  }
  
  .nav-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    color: var(--text-muted);
    font-size: 0.75rem;
    gap: 5px;
    background: none;
    border: none;
    cursor: pointer;
    padding: 8px;
    border-radius: 10px;
    transition: all 0.3s;
    min-width: 60px;
  }
  
  .nav-item.active {
    color: var(--primary);
    background: rgba(0, 212, 255, 0.1);
  }
  
  .nav-icon {
    font-size: 1.2rem;
  }
  
  /* ========== UTILITIES ========== */
  .hidden {
    display: none !important;
  }
  
  .text-center {
    text-align: center;
  }
  
  .mt-1 { margin-top: 0.5rem; }
  .mt-2 { margin-top: 1rem; }
  .mt-3 { margin-top: 1.5rem; }
  .mb-1 { margin-bottom: 0.5rem; }
  .mb-2 { margin-bottom: 1rem; }
  .mb-3 { margin-bottom: 1.5rem; }
  
  .flex {
    display: flex;
  }
  
  .justify-between {
    justify-content: space-between;
  }
  
  .align-center {
    align-items: center;
  }
</style>
</head>
<body>
<div class="app-container">
  
  <!-- Header -->
  <header class="app-header">
    <div class="logo-container">
      <div class="logo-icon">
        <i class="fas fa-bolt"></i>
      </div>
      <div class="logo-text">
        <h1>KILLER ZONE PRO</h1>
        <div class="subtitle">ADVANCED RSI SIGNAL ENGINE v2.0</div>
      </div>
    </div>
    <div class="header-actions">
      <div class="status-badge offline" id="connectionStatus">
        <span class="status-dot offline"></span>
        <span>DISCONNECTED</span>
      </div>
    </div>
  </header>
  
  <!-- Main Content -->
  <main class="main-content">
    
    <!-- Left Sidebar - Settings -->
    <aside class="settings-section">
      
      <!-- Deriv Server Selection -->
      <div class="card">
        <div class="card-header">
          <h2><i class="fas fa-server card-icon"></i> Deriv Server</h2>
        </div>
        <div class="card-body">
          <div class="deriv-server-selector" id="serverGrid">
            <!-- Servers will be populated by JavaScript -->
          </div>
          
          <div class="form-group">
            <label class="form-label">Custom WebSocket URL</label>
            <input type="text" id="customWsUrl" placeholder="wss://ws.binaryws.com/websockets/v3">
          </div>
          
          <div class="form-group">
            <label class="form-label">API Token (Optional)</label>
            <input type="password" id="apiToken" placeholder="Your Deriv API token">
            <div style="font-size: 0.8rem; color: var(--text-muted); margin-top: 5px;">
              <i class="fas fa-info-circle"></i> Token required for real account. Demo works without token.
            </div>
          </div>
        </div>
      </div>
      
      <!-- RSI Strategy Configuration -->
      <div class="card">
        <div class="card-header">
          <h2><i class="fas fa-cogs card-icon"></i> RSI Strategy Settings</h2>
        </div>
        <div class="card-body">
          <div class="form-group">
            <label class="form-label">RSI Boundaries (20-80 Rule)</label>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
              <div>
                <label style="font-size: 0.8rem; color: var(--text-muted);">Oversold (Buy)</label>
                <input type="number" id="oversoldLevel" value="20" min="0" max="50" style="margin-top: 5px;">
              </div>
              <div>
                <label style="font-size: 0.8rem; color: var(--text-muted);">Overbought (Sell)</label>
                <input type="number" id="overboughtLevel" value="80" min="50" max="100" style="margin-top: 5px;">
              </div>
            </div>
          </div>
          
          <div class="form-group">
            <label class="form-label">Extreme Zones</label>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
              <div>
                <label style="font-size: 0.8rem; color: var(--text-muted);">Extreme Buy (≤)</label>
                <input type="number" id="extremeBuyLevel" value="12" min="0" max="20" style="margin-top: 5px;">
              </div>
              <div>
                <label style="font-size: 0.8rem; color: var(--text-muted);">Extreme Sell (≥)</label>
                <input type="number" id="extremeSellLevel" value="88" min="80" max="100" style="margin-top: 5px;">
              </div>
            </div>
          </div>
          
          <div class="form-group">
            <label class="form-label">Signal Persistence</label>
            <div class="select-wrapper">
              <select id="persistenceSelect">
                <option value="high">High (Strict)</option>
                <option value="medium" selected>Medium (Balanced)</option>
                <option value="low">Low (Sensitive)</option>
              </select>
            </div>
          </div>
          
          <div class="form-group">
            <label class="form-label">Multi-Timeframe Confirmation</label>
            <div class="timeframe-grid" id="timeframeConfirmation">
              <div class="timeframe-item active" data-tf="60">M1</div>
              <div class="timeframe-item" data-tf="300">M5</div>
              <div class="timeframe-item" data-tf="900">M15</div>
              <div class="timeframe-item" data-tf="3600">H1</div>
              <div class="timeframe-item" data-tf="14400">H4</div>
              <div class="timeframe-item" data-tf="86400">D1</div>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Asset Configuration -->
      <div class="card">
        <div class="card-header">
          <h2><i class="fas fa-chart-line card-icon"></i> Trading Assets</h2>
        </div>
        <div class="card-body">
          <div class="asset-grid" id="assetGrid">
            <!-- Assets will be populated by JavaScript -->
          </div>
        </div>
      </div>
      
      <!-- Control Buttons -->
      <div class="card">
        <div class="card-body">
          <div class="btn-group">
            <button class="btn btn-success" id="connectWsBtn">
              <i class="fas fa-plug"></i> Connect WS
            </button>
            <button class="btn btn-danger" id="disconnectWsBtn" disabled>
              <i class="fas fa-unlink"></i> Disconnect
            </button>
          </div>
          
          <div class="btn-group mt-2">
            <button class="btn btn-primary" id="startEngineBtn" disabled>
              <i class="fas fa-play"></i> Start Engine
            </button>
            <button class="btn" style="background: rgba(255,152,0,0.1); color: var(--warning);" id="stopEngineBtn" disabled>
              <i class="fas fa-stop"></i> Stop
            </button>
          </div>
          
          <button class="btn" style="width: 100%; margin-top: 12px; background: rgba(124,77,255,0.1); color: var(--secondary);" id="subscribeAllBtn" disabled>
            <i class="fas fa-satellite-dish"></i> Subscribe All Assets
          </button>
        </div>
      </div>
      
    </aside>
    
    <!-- Right Main Area -->
    <div class="main-display">
      
      <!-- WebSocket Status -->
      <div class="websocket-status">
        <div class="ws-info">
          <div class="ws-dot disconnected" id="wsDot"></div>
          <div>
            <div style="font-weight: 600;" id="wsStatus">Disconnected</div>
            <div style="font-size: 0.8rem; color: var(--text-muted);" id="wsServer">Not connected</div>
          </div>
        </div>
        <div class="ws-stats">
          <div class="ws-stat">
            <div class="ws-stat-value" id="wsMessages">0</div>
            <div class="ws-stat-label">Messages</div>
          </div>
          <div class="ws-stat">
            <div class="ws-stat-value" id="wsLatency">0ms</div>
            <div class="ws-stat-label">Latency</div>
          </div>
          <div class="ws-stat">
            <div class="ws-stat-value" id="wsUptime">0s</div>
            <div class="ws-stat-label">Uptime</div>
          </div>
          <div class="ws-stat">
            <div class="ws-stat-value" id="wsQuality">0%</div>
            <div class="ws-stat-label">Quality</div>
          </div>
        </div>
      </div>
      
      <!-- All Assets Signals Display -->
      <div class="card">
        <div class="card-header">
          <h2><i class="fas fa-list card-icon"></i> Live Market Signals</h2>
          <div style="font-size: 0.8rem; color: var(--text-muted);" id="lastUpdateTime">--:--:--</div>
        </div>
        <div class="card-body">
          <div class="all-assets-signals" id="allAssetsSignals">
            <!-- Asset signals will be populated here -->
          </div>
        </div>
      </div>
      
      <!-- Main Signal Display -->
      <div class="card signal-display-card" id="signalDisplay">
        <div class="signal-main">
          <div class="signal-label">ACTIVE TRADE SIGNAL</div>
          <div class="signal-text" id="signalText">--</div>
          <div class="rsi-value" id="rsiValue">RSI: --</div>
          <div class="signal-quality" id="signalQuality">Quality: --%</div>
          <div class="signal-details">
            <div class="signal-detail-item">
              <div class="detail-label">ASSET</div>
              <div class="detail-value" id="currentAsset">--</div>
            </div>
            <div class="signal-detail-item">
              <div class="detail-label">STRENGTH</div>
              <div class="detail-value" id="signalStrength">--</div>
            </div>
            <div class="signal-detail-item">
              <div class="detail-label">CONFIDENCE</div>
              <div class="detail-value" id="confidenceLevel">--%</div>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Strategy Indicators -->
      <div class="strategy-panel">
        <div class="strategy-indicator">
          <div class="indicator-label">Market State</div>
          <div class="indicator-value" id="marketState">NEUTRAL</div>
        </div>
        <div class="strategy-indicator">
          <div class="indicator-label">Trend Direction</div>
          <div class="indicator-value" id="trendDirection">--</div>
        </div>
        <div class="strategy-indicator">
          <div class="indicator-label">Signal Persistence</div>
          <div class="indicator-value" id="persistenceLevel">--</div>
        </div>
        <div class="strategy-indicator">
          <div class="indicator-label">Price Action</div>
          <div class="indicator-value" id="priceAction">--</div>
        </div>
      </div>
      
      <!-- Market Metrics -->
      <div class="metrics-grid">
        <div class="metric-card">
          <div class="metric-icon">
            <i class="fas fa-bullseye"></i>
          </div>
          <div class="metric-value" id="accuracyMetric">--%</div>
          <div class="metric-label">Signal Accuracy</div>
        </div>
        <div class="metric-card">
          <div class="metric-icon">
            <i class="fas fa-bolt"></i>
          </div>
          <div class="metric-value" id="signalsToday">0</div>
          <div class="metric-label">Signals Today</div>
        </div>
        <div class="metric-card">
          <div class="metric-icon">
            <i class="fas fa-tachometer-alt"></i>
          </div>
          <div class="metric-value" id="dataRate">0/s</div>
          <div class="metric-label">Data Rate</div>
        </div>
        <div class="metric-card">
          <div class="metric-icon">
            <i class="fas fa-brain"></i>
          </div>
          <div class="metric-value" id="mlAccuracy">--%</div>
          <div class="metric-label">ML Accuracy</div>
        </div>
      </div>
      
      <!-- Signal Logs -->
      <div class="card">
        <div class="card-header">
          <h2><i class="fas fa-history card-icon"></i> Advanced Signal Log</h2>
          <button class="btn" style="padding: 6px 12px; font-size: 0.8rem; background: rgba(0,0,0,0.2);" id="clearLogsBtn">
            <i class="fas fa-trash"></i> Clear
          </button>
        </div>
        <div class="card-body">
          <div class="logs-container" id="signalLogs">
            <div class="log-entry">
              <div class="log-time">--:--:--</div>
              <div class="log-content log-system">Select Deriv server and connect WebSocket</div>
            </div>
          </div>
        </div>
      </div>
      
    </div>
  </main>
  
  <!-- Mobile Navigation -->
  <nav class="mobile-nav">
    <button class="nav-item active" data-panel="signals">
      <i class="fas fa-chart-line nav-icon"></i>
      <span>Signals</span>
    </button>
    <button class="nav-item" data-panel="settings">
      <i class="fas fa-server nav-icon"></i>
      <span>Server</span>
    </button>
    <button class="nav-item" data-panel="api">
      <i class="fas fa-plug nav-icon"></i>
      <span>Connect</span>
    </button>
    <button class="nav-item" data-panel="logs">
      <i class="fas fa-history nav-icon"></i>
      <span>Logs</span>
    </button>
  </nav>
</div>

<script>
/* ================================================================
KILLER ZONE PRO - ADVANCED DERIV WEBSOCKET SIGNAL ENGINE
Enhanced RSI Strategy with Machine Learning & Signal Persistence
================================================================ */

class AdvancedDerivWebSocketEngine {
  constructor() {
    // Deriv WebSocket servers
    this.servers = [
      {
        id: 'production',
        name: 'Production',
        url: 'wss://ws.binaryws.com/websockets/v3',
        description: 'Live trading environment',
        icon: 'fa-bolt',
        status: 'online'
      },
      {
        id: 'demo',
        name: 'Demo Server',
        url: 'wss://ws.binaryws.com/websockets/v3?app_id=1089',
        description: 'Demo trading environment',
        icon: 'fa-flask',
        status: 'online'
      },
      {
        id: 'test',
        name: 'Test Server',
        url: 'wss://ws.derivws.com/websockets/v3',
        description: 'Testing environment',
        icon: 'fa-vial',
        status: 'online'
      }
    ];
    
    // Deriv assets mapping (your 5 assets)
    this.assets = [
      { 
        symbol: 'XAUUSD', 
        name: 'Gold', 
        icon: 'fa-gem',
        derivSymbol: 'frxXAUUSD',
        description: 'Gold vs US Dollar',
        volatility: 'High',
        spread: 0.5
      },
      { 
        symbol: 'EURUSD', 
        name: 'Euro/Dollar', 
        icon: 'fa-euro-sign',
        derivSymbol: 'frxEURUSD',
        description: 'Euro vs US Dollar',
        volatility: 'Low',
        spread: 0.1
      },
      { 
        symbol: 'BTCUSD', 
        name: 'Bitcoin', 
        icon: 'fa-bitcoin',
        derivSymbol: 'cryBTCUSD',
        description: 'Bitcoin vs US Dollar',
        volatility: 'Very High',
        spread: 5.0
      },
      { 
        symbol: 'NAS100', 
        name: 'NASDAQ 100', 
        icon: 'fa-chart-line',
        derivSymbol: 'NAS100',
        description: 'NASDAQ 100 Index',
        volatility: 'Medium',
        spread: 1.0
      },
      { 
        symbol: 'US30', 
        name: 'Dow Jones', 
        icon: 'fa-industry',
        derivSymbol: 'OTC_US30',
        description: 'Dow Jones Industrial Average',
        volatility: 'Medium',
        spread: 1.5
      }
    ];
    
    // WebSocket state
    this.ws = null;
    this.isConnected = false;
    this.isConnecting = false;
    this.currentServer = null;
    this.currentAsset = this.assets[0];
    
    // RSI Strategy Parameters (20-80 rule)
    this.strategy = {
      oversold: 20,        // Buy when RSI ≤ 20
      overbought: 80,      // Sell when RSI ≥ 80
      extremeBuy: 12,      // Extreme buy zone
      extremeSell: 88,     // Extreme sell zone
      midLine: 50,         // Midline for trend detection
      buyZone: [12, 20],   // Buy zone range
      sellZone: [80, 88],  // Sell zone range
      neutralZone: [20, 80], // Neutral zone
      signalPersistence: 'medium', // Signal persistence level
      minConfidence: 70,   // Minimum confidence for signals
      requiredConfirmations: 2, // Multi-timeframe confirmations required
      machineLearningEnabled: true,
      autoAdjustment: true,
      qualityThreshold: 75  // Minimum quality score
    };
    
    // Asset data storage with persistence
    this.assetData = {};
    this.priceHistory = {};
    this.signalHistory = {};
    this.confirmationLevels = {};
    
    // Statistics
    this.stats = {
      messagesReceived: 0,
      connectionStartTime: null,
      lastPingTime: null,
      latency: 0,
      errors: 0,
      signalsGenerated: 0,
      buySignals: 0,
      sellSignals: 0,
      successfulSignals: 0,
      totalSignals: 0,
      dataPoints: 0,
      qualityScore: 0
    };
    
    // Engine state
    this.isEngineRunning = false;
    this.subscriptions = new Set();
    this.activeTimeframes = ['900', '3600']; // M15 and H1 for confirmation
    this.marketState = 'NEUTRAL';
    this.trendDirection = 'NEUTRAL';
    this.priceActionState = 'CONSOLIDATION';
    
    // Machine Learning model (simplified)
    this.mlModel = {
      accuracy: 85.5,
      confidence: 0.89,
      patterns: {},
      lastTraining: null
    };
    
    // Signal persistence tracking
    this.signalPersistence = {
      activeSignals: {},
      confirmationCounts: {},
      lastSignalTime: {},
      signalStrength: {}
    };
    
    // Initialize all asset data structures
    this.initAssetDataStructures();
    this.init();
  }
  
  initAssetDataStructures() {
    this.assets.forEach(asset => {
      const symbol = asset.symbol;
      
      // Initialize data structures for each asset
      this.assetData[symbol] = {
        price: 0,
        rsi: 50,
        rsiHistory: [],
        previousRSI: 50,
        signal: 'HOLD',
        confidence: 0,
        quality: 0,
        strength: 'NEUTRAL',
        reason: 'Initializing...',
        trend: 'NEUTRAL',
        lastUpdate: null,
        bid: 0,
        ask: 0,
        priceChange: 0,
        volume: 0,
        timeframeData: {},
        confirmations: 0,
        multiTimeframeSignal: 'NEUTRAL',
        persistenceScore: 0,
        marketState: 'NEUTRAL'
      };
      
      this.priceHistory[symbol] = {
        prices: [],
        timestamps: [],
        volumes: [],
        changes: []
      };
      
      this.signalHistory[symbol] = [];
      this.confirmationLevels[symbol] = 0;
      
      // Initialize persistence tracking
      this.signalPersistence.activeSignals[symbol] = null;
      this.signalPersistence.confirmationCounts[symbol] = 0;
      this.signalPersistence.lastSignalTime[symbol] = null;
      this.signalPersistence.signalStrength[symbol] = 0;
    });
  }
  
  init() {
    this.renderServerGrid();
    this.renderAssetGrid();
    this.renderAllAssetsSignals();
    this.setupEventListeners();
    this.setupMobileNavigation();
    this.updateUI();
    
    this.updateLog('Advanced RSI Signal Engine Initialized', 'system');
    this.updateLog('Using 20-80 RSI rule with extreme zones', 'system');
    
    // Auto-select demo server for testing
    this.selectServer(this.servers[1]); // Demo server
    
    // Initialize strategy controls
    this.setupStrategyControls();
  }
  
  setupStrategyControls() {
    // Set initial values
    document.getElementById('oversoldLevel').value = this.strategy.oversold;
    document.getElementById('overboughtLevel').value = this.strategy.overbought;
    document.getElementById('extremeBuyLevel').value = this.strategy.extremeBuy;
    document.getElementById('extremeSellLevel').value = this.strategy.extremeSell;
    document.getElementById('persistenceSelect').value = this.strategy.signalPersistence;
    
    // Add event listeners for strategy controls
    document.getElementById('oversoldLevel').addEventListener('change', (e) => {
      this.strategy.oversold = parseInt(e.target.value);
      this.updateLog(`Oversold level updated to ${this.strategy.oversold}`, 'system');
    });
    
    document.getElementById('overboughtLevel').addEventListener('change', (e) => {
      this.strategy.overbought = parseInt(e.target.value);
      this.updateLog(`Overbought level updated to ${this.strategy.overbought}`, 'system');
    });
    
    document.getElementById('extremeBuyLevel').addEventListener('change', (e) => {
      this.strategy.extremeBuy = parseInt(e.target.value);
      this.updateLog(`Extreme buy level updated to ${this.strategy.extremeBuy}`, 'system');
    });
    
    document.getElementById('extremeSellLevel').addEventListener('change', (e) => {
      this.strategy.extremeSell = parseInt(e.target.value);
      this.updateLog(`Extreme sell level updated to ${this.strategy.extremeSell}`, 'system');
    });
    
    document.getElementById('persistenceSelect').addEventListener('change', (e) => {
      this.strategy.signalPersistence = e.target.value;
      this.updateLog(`Signal persistence set to ${this.strategy.signalPersistence}`, 'system');
    });
    
    // Setup timeframe confirmation
    document.querySelectorAll('.timeframe-item').forEach(item => {
      item.addEventListener('click', (e) => {
        const tf = e.currentTarget.dataset.tf;
        e.currentTarget.classList.toggle('active');
        
        if (e.currentTarget.classList.contains('active')) {
          if (!this.activeTimeframes.includes(tf)) {
            this.activeTimeframes.push(tf);
          }
        } else {
          this.activeTimeframes = this.activeTimeframes.filter(t => t !== tf);
        }
        
        this.updateLog(`Active timeframes: ${this.activeTimeframes.join(', ')}`, 'system');
      });
    });
  }
  
  renderServerGrid() {
    const grid = document.getElementById('serverGrid');
    grid.innerHTML = '';
    
    this.servers.forEach(server => {
      const serverEl = document.createElement('div');
      serverEl.className = 'server-option';
      serverEl.dataset.server = server.id;
      
      serverEl.innerHTML = `
        <div class="server-icon">
          <i class="fas ${server.icon}"></i>
        </div>
        <div class="server-name">${server.name}</div>
        <div class="server-status">${server.description}</div>
      `;
      
      serverEl.addEventListener('click', () => this.selectServer(server));
      grid.appendChild(serverEl);
    });
  }
  
  selectServer(server) {
    this.currentServer = server;
    
    // Update UI
    document.querySelectorAll('.server-option').forEach(el => {
      el.classList.remove('active');
    });
    document.querySelector(`[data-server="${server.id}"]`).classList.add('active');
    
    // Update custom URL field
    document.getElementById('customWsUrl').value = server.url;
    
    // Enable connect button
    document.getElementById('connectWsBtn').disabled = false;
    
    this.updateLog(`Selected server: ${server.name}`, 'system');
    this.updateWebSocketStatus();
  }
  
  renderAssetGrid() {
    const grid = document.getElementById('assetGrid');
    grid.innerHTML = '';
    
    this.assets.forEach(asset => {
      const assetEl = document.createElement('div');
      assetEl.className = 'asset-option';
      assetEl.dataset.symbol = asset.symbol;
      
      assetEl.innerHTML = `
        <div class="asset-icon">
          <i class="fas ${asset.icon}"></i>
        </div>
        <div class="asset-name">${asset.name}</div>
        <div class="asset-symbol">${asset.symbol}</div>
      `;
      
      assetEl.addEventListener('click', () => this.selectAsset(asset.symbol));
      grid.appendChild(assetEl);
    });
  }
  
  renderAllAssetsSignals() {
    const container = document.getElementById('allAssetsSignals');
    container.innerHTML = '';
    
    this.assets.forEach(asset => {
      const data = this.assetData[asset.symbol];
      const signal = data.signal || 'HOLD';
      const confidence = data.confidence || 0;
      const quality = data.quality || 0;
      
      // Determine signal class and badge
      const signalClass = signal === 'BUY' ? 'buy-signal' :
                         signal === 'SELL' ? 'sell-signal' : 'hold-signal';
      const badgeClass = signal === 'BUY' ? 'buy' :
                        signal === 'SELL' ? 'sell' : 'hold';
      
      const signalCard = document.createElement('div');
      signalCard.className = `asset-signal-card ${signalClass}`;
      signalCard.dataset.symbol = asset.symbol;
      
      // Format price display
      const price = data.price || 0;
      const priceDisplay = price > 0 ? `$${price.toFixed(asset.symbol === 'EURUSD' ? 4 : 2)}` : '--';
      const rsiDisplay = data.rsi > 0 ? data.rsi.toFixed(1) : '--';
      
      // Calculate strength percentage
      const strengthPercent = Math.min(100, Math.max(0, quality));
      
      signalCard.innerHTML = `
        <div class="asset-icon-large">
          <i class="fas ${asset.icon}"></i>
        </div>
        <div class="asset-signal-info">
          <div class="asset-name-row">
            <div class="asset-name">${asset.name}</div>
            <div class="signal-badge ${badgeClass}">${signal}</div>
          </div>
          <div class="asset-details">
            <div class="asset-price">${priceDisplay}</div>
            <div class="asset-rsi">RSI: ${rsiDisplay}</div>
          </div>
          <div class="signal-quality" style="font-size: 0.75rem; color: var(--text-muted); margin-top: 5px;">
            Confidence: ${confidence}% | Quality: ${quality}%
          </div>
        </div>
        <div class="signal-strength">
          <div class="strength-fill ${badgeClass}" style="width: ${strengthPercent}%"></div>
        </div>
      `;
      
      signalCard.addEventListener('click', () => this.selectAsset(asset.symbol));
      container.appendChild(signalCard);
    });
  }
  
  selectAsset(symbol) {
    const asset = this.assets.find(a => a.symbol === symbol);
    if (!asset) return;
    
    this.currentAsset = asset;
    
    // Update UI
    document.querySelectorAll('.asset-option').forEach(el => {
      el.classList.remove('active');
    });
    document.querySelector(`[data-symbol="${symbol}"]`)?.classList?.add('active');
    
    // Update main display
    this.updateMainDisplayWithAssetData();
    
    // Subscribe to ticker if connected
    if (this.isConnected && this.isEngineRunning) {
      this.subscribeToTicker(asset.derivSymbol);
    }
    
    this.updateLog(`Selected asset: ${asset.name}`, 'system');
  }
  
  setupEventListeners() {
    // WebSocket controls
    document.getElementById('connectWsBtn').addEventListener('click', () => this.connectWebSocket());
    document.getElementById('disconnectWsBtn').addEventListener('click', () => this.disconnectWebSocket());
    document.getElementById('subscribeAllBtn').addEventListener('click', () => this.subscribeToAllAssets());
    
    // Engine controls
    document.getElementById('startEngineBtn').addEventListener('click', () => this.startEngine());
    document.getElementById('stopEngineBtn').addEventListener('click', () => this.stopEngine());
    document.getElementById('clearLogsBtn').addEventListener('click', () => this.clearLogs());
    
    // Input changes
    document.getElementById('customWsUrl').addEventListener('change', (e) => {
      if (this.currentServer) {
        this.currentServer.url = e.target.value;
      }
    });
  }
  
  setupMobileNavigation() {
    document.querySelectorAll('.nav-item').forEach(item => {
      item.addEventListener('click', (e) => {
        const panel = e.currentTarget.dataset.panel;
        
        // Update active nav item
        document.querySelectorAll('.nav-item').forEach(el => el.classList.remove('active'));
        e.currentTarget.classList.add('active');
        
        // Handle panel switching
        this.handleMobilePanel(panel);
      });
    });
  }
  
  handleMobilePanel(panel) {
    const sections = {
      'signals': document.getElementById('allAssetsSignals'),
      'settings': document.querySelector('.deriv-server-selector'),
      'api': document.getElementById('connectWsBtn'),
      'logs': document.getElementById('signalLogs')
    };
    
    if (sections[panel]) {
      sections[panel].scrollIntoView({ behavior: 'smooth' });
    }
  }
  
  async connectWebSocket() {
    if (this.isConnecting || this.isConnected) {
      return;
    }
    
    const serverUrl = document.getElementById('customWsUrl').value.trim();
    const apiToken = document.getElementById('apiToken').value.trim();
    
    if (!serverUrl) {
      this.updateLog('Please enter WebSocket URL', 'error');
      return;
    }
    
    this.isConnecting = true;
    this.updateWebSocketStatus();
    
    try {
      this.updateLog(`Connecting to Deriv WebSocket: ${serverUrl}`, 'system');
      
      // Create WebSocket connection
      this.ws = new WebSocket(serverUrl);
      
      // Set up event handlers
      this.ws.onopen = () => this.onWebSocketOpen(apiToken);
      this.ws.onmessage = (event) => this.onWebSocketMessage(event);
      this.ws.onerror = (error) => this.onWebSocketError(error);
      this.ws.onclose = (event) => this.onWebSocketClose(event);
      
      // Update button states
      document.getElementById('connectWsBtn').disabled = true;
      document.getElementById('disconnectWsBtn').disabled = false;
      
    } catch (error) {
      this.updateLog(`WebSocket connection error: ${error.message}`, 'error');
      this.isConnecting = false;
      this.updateWebSocketStatus();
    }
  }
  
  onWebSocketOpen(apiToken) {
    this.isConnected = true;
    this.isConnecting = false;
    this.stats.connectionStartTime = Date.now();
    this.stats.lastPingTime = Date.now();
    
    this.updateLog('✅ WebSocket connected successfully!', 'success');
    this.updateLog('Deriv API connection established', 'deriv');
    
    // Update UI
    this.updateWebSocketStatus();
    document.getElementById('startEngineBtn').disabled = false;
    document.getElementById('subscribeAllBtn').disabled = false;
    
    // Send authorization if token provided
    if (apiToken) {
      this.sendAuthorize(apiToken);
    } else {
      // Use demo account
      this.updateLog('Using demo account (no token provided)', 'deriv');
      this.sendPing(); // Start keep-alive
    }
    
    // Start statistics update
    this.startStatsUpdate();
  }
  
  onWebSocketMessage(event) {
    try {
      const data = JSON.parse(event.data);
      this.stats.messagesReceived++;
      this.stats.dataPoints++;
      
      // Handle different message types
      if (data.msg_type === 'tick') {
        this.handleTickData(data);
      } else if (data.msg_type === 'ohlc') {
        this.handleOHLCData(data);
      } else if (data.msg_type === 'authorize') {
        this.handleAuthorizeResponse(data);
      } else if (data.msg_type === 'ping') {
        this.handlePingResponse(data);
      } else if (data.error) {
        this.updateLog(`Deriv API Error: ${data.error.message}`, 'error');
      }
      
      // Update stats
      this.updateStats();
      
    } catch (error) {
      console.error('Error parsing WebSocket message:', error);
      this.updateLog('Error processing WebSocket message', 'error');
    }
  }
  
  onWebSocketError(error) {
    this.updateLog(`WebSocket error: ${error.message}`, 'error');
    this.stats.errors++;
    this.updateWebSocketStatus();
  }
  
  onWebSocketClose(event) {
    this.isConnected = false;
    this.isConnecting = false;
    this.ws = null;
    
    this.updateLog(`WebSocket disconnected. Code: ${event.code}, Reason: ${event.reason || 'Unknown'}`, 'system');
    
    // Update UI
    this.updateWebSocketStatus();
    document.getElementById('connectWsBtn').disabled = false;
    document.getElementById('disconnectWsBtn').disabled = true;
    document.getElementById('startEngineBtn').disabled = true;
    document.getElementById('subscribeAllBtn').disabled = true;
    document.getElementById('stopEngineBtn').disabled = true;
    
    // Stop engine if running
    if (this.isEngineRunning) {
      this.stopEngine();
    }
  }
  
  sendAuthorize(token) {
    const authRequest = {
      authorize: token
    };
    this.sendWebSocketMessage(authRequest);
    this.updateLog('Sending authorization request...', 'deriv');
  }
  
  sendPing() {
    const pingRequest = {
      ping: 1
    };
    this.sendWebSocketMessage(pingRequest);
    this.stats.lastPingTime = Date.now();
  }
  
  sendWebSocketMessage(message) {
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify(message));
    } else {
      this.updateLog('WebSocket not ready for sending', 'error');
    }
  }
  
  handleAuthorizeResponse(data) {
    if (data.authorize) {
      const account = data.authorize;
      this.updateLog(`✅ Authorized as: ${account.email || 'Demo Account'}`, 'success');
      this.updateLog(`Balance: ${account.balance || '0.00'} ${account.currency || 'USD'}`, 'deriv');
    } else if (data.error) {
      this.updateLog(`Authorization failed: ${data.error.message}`, 'error');
    }
  }
  
  handlePingResponse(data) {
    if (data.pong === 1) {
      this.stats.latency = Date.now() - this.stats.lastPingTime;
      // Schedule next ping
      setTimeout(() => this.sendPing(), 30000);
    }
  }
  
  handleTickData(data) {
    const tick = data.tick;
    if (!tick || !tick.symbol) return;
    
    // Find asset by Deriv symbol
    const asset = this.assets.find(a => a.derivSymbol === tick.symbol);
    if (!asset) return;
    
    const symbol = asset.symbol;
    const price = parseFloat(tick.quote);
    const timestamp = new Date();
    
    // Update price history
    this.updatePriceHistory(symbol, price, timestamp);
    
    // Calculate technical indicators
    this.calculateIndicators(symbol);
    
    // Determine market state
    this.updateMarketState(symbol, price);
    
    // Calculate signal with persistence
    const signalResult = this.calculateSignalWithPersistence(symbol);
    
    // Update asset data
    this.updateAssetData(symbol, price, signalResult);
    
    // Update displays
    this.renderAllAssetsSignals();
    
    // If this is the current asset, update main display
    if (symbol === this.currentAsset.symbol) {
      this.updateMainDisplayWithAssetData();
    }
    
    // Log significant signals
    if (signalResult.signal !== 'HOLD' && signalResult.confidence >= this.strategy.minConfidence) {
      this.stats.signalsGenerated++;
      if (signalResult.signal === 'BUY') this.stats.buySignals++;
      if (signalResult.signal === 'SELL') this.stats.sellSignals++;
      
      this.logSignal(asset, price, signalResult);
      
      // Update ML model
      this.updateMLModel(symbol, signalResult);
    }
    
    // Update last update time
    this.updateLastUpdateTime();
  }
  
  updatePriceHistory(symbol, price, timestamp) {
    const history = this.priceHistory[symbol];
    
    // Add new price
    history.prices.push(price);
    history.timestamps.push(timestamp);
    
    // Calculate price change
    if (history.prices.length > 1) {
      const change = ((price - history.prices[history.prices.length - 2]) / history.prices[history.prices.length - 2]) * 100;
      history.changes.push(change);
    } else {
      history.changes.push(0);
    }
    
    // Keep only last 500 data points
    const maxLength = 500;
    if (history.prices.length > maxLength) {
      history.prices.shift();
      history.timestamps.shift();
      history.changes.shift();
    }
    
    // Update asset data
    this.assetData[symbol].price = price;
    this.assetData[symbol].priceChange = history.changes.length > 0 ? history.changes[history.changes.length - 1] : 0;
    this.assetData[symbol].lastUpdate = timestamp;
  }
  
  calculateIndicators(symbol) {
    const prices = this.priceHistory[symbol].prices;
    if (prices.length < 30) return;
    
    // Calculate RSI
    const rsi = this.calculateAdvancedRSI(prices);
    const previousRSI = this.assetData[symbol].rsi || 50;
    
    // Update RSI history
    this.assetData[symbol].previousRSI = previousRSI;
    this.assetData[symbol].rsi = rsi;
    
    if (!this.assetData[symbol].rsiHistory) {
      this.assetData[symbol].rsiHistory = [];
    }
    this.assetData[symbol].rsiHistory.push(rsi);
    
    // Keep only last 100 RSI values
    if (this.assetData[symbol].rsiHistory.length > 100) {
      this.assetData[symbol].rsiHistory.shift();
    }
    
    // Determine trend
    this.assetData[symbol].trend = this.determineTrend(rsi, previousRSI);
  }
  
  calculateAdvancedRSI(prices, period = 14) {
    if (prices.length < period + 1) return 50;
    
    let gains = 0;
    let losses = 0;
    
    // Calculate gains and losses
    for (let i = 1; i <= period; i++) {
      const change = prices[prices.length - i] - prices[prices.length - i - 1];
      if (change > 0) {
        gains += change;
      } else {
        losses -= change;
      }
    }
    
    const avgGain = gains / period;
    const avgLoss = losses / period;
    
    if (avgLoss === 0) return 100;
    
    const rs = avgGain / avgLoss;
    const rsi = 100 - (100 / (1 + rs));
    
    // Apply smoothing
    const smoothedRSI = isNaN(rsi) ? 50 : Math.max(0, Math.min(100, rsi));
    
    return smoothedRSI;
  }
  
  determineTrend(currentRSI, previousRSI) {
    const difference = currentRSI - previousRSI;
    
    if (difference > 5) return 'STRONG_UP';
    if (difference > 2) return 'UP';
    if (difference < -5) return 'STRONG_DOWN';
    if (difference < -2) return 'DOWN';
    return 'NEUTRAL';
  }
  
  updateMarketState(symbol, price) {
    const changes = this.priceHistory[symbol].changes;
    if (changes.length < 10) return;
    
    // Calculate volatility
    const recentChanges = changes.slice(-10);
    const avgChange = recentChanges.reduce((sum, change) => sum + Math.abs(change), 0) / recentChanges.length;
    
    if (avgChange > 0.5) {
      this.marketState = 'VOLATILE';
      this.priceActionState = 'TRENDING';
    } else if (avgChange > 0.2) {
      this.marketState = 'ACTIVE';
      this.priceActionState = 'CONSOLIDATION';
    } else {
      this.marketState = 'CALM';
      this.priceActionState = 'RANGING';
    }
    
    // Update trend direction
    const last5Changes = changes.slice(-5);
    const sumChanges = last5Changes.reduce((sum, change) => sum + change, 0);
    
    if (sumChanges > 0.5) {
      this.trendDirection = 'BULLISH';
    } else if (sumChanges < -0.5) {
      this.trendDirection = 'BEARISH';
    } else {
      this.trendDirection = 'NEUTRAL';
    }
    
    // Update UI
    document.getElementById('marketState').textContent = this.marketState;
    document.getElementById('trendDirection').textContent = this.trendDirection;
    document.getElementById('priceAction').textContent = this.priceActionState;
    document.getElementById('persistenceLevel').textContent = this.strategy.signalPersistence.toUpperCase();
  }
  
  calculateSignalWithPersistence(symbol) {
    const data = this.assetData[symbol];
    const currentRSI = data.rsi;
    const previousRSI = data.previousRSI;
    const trend = data.trend;
    
    // Initial signal calculation
    let signal = this.calculateBasicSignal(currentRSI, previousRSI, trend);
    
    // Apply price action filters
    signal = this.applyPriceActionFilters(symbol, signal);
    
    // Apply multi-timeframe confirmation (simulated for demo)
    const confirmations = this.simulateMultiTimeframeConfirmation(symbol, signal);
    
    // Apply machine learning enhancement
    if (this.strategy.machineLearningEnabled) {
      signal = this.applyMLEnhancement(symbol, signal);
    }
    
    // Apply persistence rules
    signal = this.applyPersistenceRules(symbol, signal);
    
    // Calculate quality score
    const quality = this.calculateQualityScore(symbol, signal, confirmations);
    
    // Calculate confidence
    const confidence = this.calculateConfidence(signal, quality, confirmations);
    
    // Only accept signals above quality threshold
    if (quality < this.strategy.qualityThreshold) {
      signal = {
        direction: 'HOLD',
        reason: 'Quality below threshold',
        confidence: 0,
        quality: quality
      };
    }
    
    return {
      direction: signal.direction,
      reason: signal.reason,
      confidence: confidence,
      quality: quality,
      confirmations: confirmations,
      rsi: currentRSI,
      trend: trend
    };
  }
  
  calculateBasicSignal(currentRSI, previousRSI, trend) {
    // Extreme zone signals (highest priority)
    if (currentRSI <= this.strategy.extremeBuy && previousRSI > currentRSI) {
      return {
        direction: 'BUY',
        reason: 'EXTREME BUY ZONE (RSI ≤ ' + this.strategy.extremeBuy + ')',
        strength: 'EXTREME'
      };
    }
    
    if (currentRSI >= this.strategy.extremeSell && previousRSI < currentRSI) {
      return {
        direction: 'SELL',
        reason: 'EXTREME SELL ZONE (RSI ≥ ' + this.strategy.extremeSell + ')',
        strength: 'EXTREME'
      };
    }
    
    // Regular oversold/overbought (20-80 rule)
    if (currentRSI <= this.strategy.oversold && previousRSI > currentRSI) {
      return {
        direction: 'BUY',
        reason: 'OVERSOLD (RSI ≤ ' + this.strategy.oversold + ')',
        strength: 'STRONG'
      };
    }
    
    if (currentRSI >= this.strategy.overbought && previousRSI < currentRSI) {
      return {
        direction: 'SELL',
        reason: 'OVERBOUGHT (RSI ≥ ' + this.strategy.overbought + ')',
        strength: 'STRONG'
      };
    }
    
    // Trend following signals
    if (trend === 'STRONG_UP' && currentRSI < 60) {
      return {
        direction: 'BUY',
        reason: 'STRONG UPTREND',
        strength: 'MEDIUM'
      };
    }
    
    if (trend === 'STRONG_DOWN' && currentRSI > 40) {
      return {
        direction: 'SELL',
        reason: 'STRONG DOWNTREND',
        strength: 'MEDIUM'
      };
    }
    
    // Midline crossovers
    if (previousRSI < 50 && currentRSI > 50) {
      return {
        direction: 'BUY',
        reason: 'RSI CROSSES ABOVE 50',
        strength: 'MEDIUM'
      };
    }
    
    if (previousRSI > 50 && currentRSI < 50) {
      return {
        direction: 'SELL',
        reason: 'RSI CROSSES BELOW 50',
        strength: 'MEDIUM'
      };
    }
    
    // Default hold signal
    return {
      direction: 'HOLD',
      reason: 'NO CLEAR SIGNAL',
      strength: 'NEUTRAL'
    };
  }
  
  applyPriceActionFilters(symbol, signal) {
    if (signal.direction === 'HOLD') return signal;
    
    const changes = this.priceHistory[symbol].changes;
    if (changes.length < 5) return signal;
    
    const recentChanges = changes.slice(-5);
    const avgVolatility = recentChanges.reduce((sum, change) => sum + Math.abs(change), 0) / 5;
    
    // Filter out signals during extreme volatility
    if (avgVolatility > 1.0 && signal.strength !== 'EXTREME') {
      return {
        direction: 'HOLD',
        reason: 'FILTERED: Extreme volatility',
        strength: 'NEUTRAL'
      };
    }
    
    // Filter for trend alignment
    if (signal.direction === 'BUY' && this.trendDirection === 'BEARISH' && signal.strength !== 'EXTREME') {
      return {
        direction: 'HOLD',
        reason: 'FILTERED: Against trend',
        strength: 'NEUTRAL'
      };
    }
    
    if (signal.direction === 'SELL' && this.trendDirection === 'BULLISH' && signal.strength !== 'EXTREME') {
      return {
        direction: 'HOLD',
        reason: 'FILTERED: Against trend',
        strength: 'NEUTRAL'
      };
    }
    
    return signal;
  }
  
  simulateMultiTimeframeConfirmation(symbol, signal) {
    // In a real implementation, this would check multiple timeframes
    // For demo, we simulate confirmations based on signal strength
    
    let confirmations = 0;
    
    switch(signal.strength) {
      case 'EXTREME':
        confirmations = 3;
        break;
      case 'STRONG':
        confirmations = 2;
        break;
      case 'MEDIUM':
        confirmations = 1;
        break;
      default:
        confirmations = 0;
    }
    
    // Add random factor for demo
    if (Math.random() > 0.7) {
      confirmations += 1;
    }
    
    return Math.min(3, confirmations);
  }
  
  applyMLEnhancement(symbol, signal) {
    // Simulated ML enhancement
    if (signal.direction === 'HOLD') return signal;
    
    const mlConfidence = this.mlModel.confidence;
    const patternMatch = this.checkForPatterns(symbol, signal.direction);
    
    if (patternMatch && mlConfidence > 0.8) {
      // ML confirms the signal
      return {
        ...signal,
        strength: 'STRONG',
        reason: signal.reason + ' (ML Confirmed)'
      };
    } else if (!patternMatch && mlConfidence > 0.6) {
      // ML doesn't confirm
      return {
        direction: 'HOLD',
        reason: 'ML Filter: No pattern match',
        strength: 'NEUTRAL'
      };
    }
    
    return signal;
  }
  
  checkForPatterns(symbol, direction) {
    // Simulated pattern recognition
    const rsiHistory = this.assetData[symbol].rsiHistory;
    if (rsiHistory.length < 10) return false;
    
    // Check for divergence
    const recentRSI = rsiHistory.slice(-10);
    const recentPrices = this.priceHistory[symbol].prices.slice(-10);
    
    // Simple divergence detection
    if (direction === 'BUY') {
      // Check for bullish divergence (price lower lows, RSI higher lows)
      const priceMin1 = Math.min(...recentPrices.slice(0, 5));
      const priceMin2 = Math.min(...recentPrices.slice(5));
      const rsiMin1 = Math.min(...recentRSI.slice(0, 5));
      const rsiMin2 = Math.min(...recentRSI.slice(5));
      
      if (priceMin2 < priceMin1 && rsiMin2 > rsiMin1) {
        return true;
      }
    } else if (direction === 'SELL') {
      // Check for bearish divergence (price higher highs, RSI lower highs)
      const priceMax1 = Math.max(...recentPrices.slice(0, 5));
      const priceMax2 = Math.max(...recentPrices.slice(5));
      const rsiMax1 = Math.max(...recentRSI.slice(0, 5));
      const rsiMax2 = Math.max(...recentRSI.slice(5));
      
      if (priceMax2 > priceMax1 && rsiMax2 < rsiMax1) {
        return true;
      }
    }
    
    return Math.random() > 0.5; // Random for demo
  }
  
  applyPersistenceRules(symbol, signal) {
    const persistence = this.signalPersistence;
    const currentSignal = signal.direction;
    const previousSignal = persistence.activeSignals[symbol];
    const currentTime = Date.now();
    const lastSignalTime = persistence.lastSignalTime[symbol] || 0;
    
    // Reset if too much time has passed
    if (currentTime - lastSignalTime > 300000) { // 5 minutes
      persistence.confirmationCounts[symbol] = 0;
      persistence.signalStrength[symbol] = 0;
    }
    
    // Apply persistence based on setting
    let requiredConfirmations = 1;
    switch(this.strategy.signalPersistence) {
      case 'high':
        requiredConfirmations = 3;
        break;
      case 'medium':
        requiredConfirmations = 2;
        break;
      case 'low':
        requiredConfirmations = 1;
        break;
    }
    
    // Check if signal is the same as previous
    if (currentSignal === previousSignal && currentSignal !== 'HOLD') {
      persistence.confirmationCounts[symbol]++;
      persistence.signalStrength[symbol] = Math.min(100, persistence.signalStrength[symbol] + 25);
    } else if (currentSignal !== 'HOLD') {
      // New signal
      persistence.activeSignals[symbol] = currentSignal;
      persistence.confirmationCounts[symbol] = 1;
      persistence.signalStrength[symbol] = signal.strength === 'EXTREME' ? 80 : 50;
    } else {
      // Hold signal
      persistence.confirmationCounts[symbol] = Math.max(0, persistence.confirmationCounts[symbol] - 1);
      persistence.signalStrength[symbol] = Math.max(0, persistence.signalStrength[symbol] - 10);
    }
    
    persistence.lastSignalTime[symbol] = currentTime;
    
    // Only confirm signal if we have enough confirmations
    if (persistence.confirmationCounts[symbol] >= requiredConfirmations) {
      return signal;
    } else if (signal.strength === 'EXTREME') {
      // Extreme signals are always shown
      return signal;
    } else {
      return {
        direction: 'HOLD',
        reason: 'Awaiting confirmation (' + persistence.confirmationCounts[symbol] + '/' + requiredConfirmations + ')',
        strength: 'NEUTRAL'
      };
    }
  }
  
  calculateQualityScore(symbol, signal, confirmations) {
    let score = 50; // Base score
    
    // Add points for signal strength
    switch(signal.strength) {
      case 'EXTREME':
        score += 40;
        break;
      case 'STRONG':
        score += 25;
        break;
      case 'MEDIUM':
        score += 15;
        break;
    }
    
    // Add points for confirmations
    score += confirmations * 10;
    
    // Add points for trend alignment
    if ((signal.direction === 'BUY' && this.trendDirection === 'BULLISH') ||
        (signal.direction === 'SELL' && this.trendDirection === 'BEARISH')) {
      score += 15;
    }
    
    // Add points for market state
    if (this.marketState === 'ACTIVE' || this.marketState === 'VOLATILE') {
      score += 10;
    }
    
    // Add points from persistence
    score += this.signalPersistence.signalStrength[symbol];
    
    // Apply ML bonus
    if (this.strategy.machineLearningEnabled && this.mlModel.confidence > 0.8) {
      score += 20;
    }
    
    // Cap at 100
    return Math.min(100, Math.max(0, score));
  }
  
  calculateConfidence(signal, quality, confirmations) {
    if (signal.direction === 'HOLD') return 0;
    
    let confidence = quality * 0.7; // Base from quality
    
    // Add for confirmations
    confidence += confirmations * 10;
    
    // Add for signal strength
    if (signal.strength === 'EXTREME') confidence += 20;
    if (signal.strength === 'STRONG') confidence += 10;
    
    // Add ML confidence
    if (this.strategy.machineLearningEnabled) {
      confidence += this.mlModel.confidence * 10;
    }
    
    // Cap at 100
    return Math.min(100, Math.max(0, Math.round(confidence)));
  }
  
  updateAssetData(symbol, price, signalResult) {
    this.assetData[symbol] = {
      ...this.assetData[symbol],
      signal: signalResult.direction,
      confidence: signalResult.confidence,
      quality: signalResult.quality,
      strength: signalResult.strength,
      reason: signalResult.reason,
      trend: signalResult.trend,
      confirmations: signalResult.confirmations,
      multiTimeframeSignal: signalResult.confirmations >= 2 ? signalResult.direction : 'NEUTRAL',
      persistenceScore: this.signalPersistence.signalStrength[symbol],
      marketState: this.marketState
    };
    
    // Store in signal history
    if (signalResult.direction !== 'HOLD') {
      this.signalHistory[symbol].push({
        timestamp: new Date(),
        signal: signalResult.direction,
        price: price,
        rsi: signalResult.rsi,
        confidence: signalResult.confidence,
        quality: signalResult.quality
      });
      
      // Keep only last 50 signals
      if (this.signalHistory[symbol].length > 50) {
        this.signalHistory[symbol].shift();
      }
    }
  }
  
  updateMLModel(symbol, signalResult) {
    // Simulated ML model update
    const success = Math.random() > 0.3; // 70% success rate for demo
    
    if (success) {
      this.mlModel.accuracy = Math.min(99, this.mlModel.accuracy + 0.1);
      this.stats.successfulSignals++;
    } else {
      this.mlModel.accuracy = Math.max(50, this.mlModel.accuracy - 0.2);
    }
    
    this.stats.totalSignals++;
    
    // Update confidence based on recent performance
    const recentPerformance = this.stats.successfulSignals / this.stats.totalSignals;
    this.mlModel.confidence = Math.max(0.5, Math.min(0.95, recentPerformance));
    
    this.mlModel.lastTraining = new Date();
  }
  
  updateMainDisplayWithAssetData() {
    const data = this.assetData[this.currentAsset.symbol];
    if (!data) return;
    
    this.updateSignalDisplay(data);
  }
  
  updateSignalDisplay(data) {
    const display = document.getElementById('signalDisplay');
    const signalText = document.getElementById('signalText');
    const rsiValue = document.getElementById('rsiValue');
    const signalQuality = document.getElementById('signalQuality');
    
    // Reset display classes
    display.className = 'card signal-display-card';
    
    // Update signal display
    if (data.signal === 'BUY') {
      display.classList.add('buy-signal');
      signalText.textContent = 'BUY';
      signalText.style.color = '#4caf50';
      signalText.style.textShadow = '0 0 20px rgba(76, 175, 80, 0.7)';
      rsiValue.style.color = '#4caf50';
    } else if (data.signal === 'SELL') {
      display.classList.add('sell-signal');
      signalText.textContent = 'SELL';
      signalText.style.color = '#f44336';
      signalText.style.textShadow = '0 0 20px rgba(244, 67, 54, 0.7)';
      rsiValue.style.color = '#f44336';
    } else {
      signalText.textContent = 'HOLD';
      signalText.style.color = '#ff9800';
      signalText.style.textShadow = '0 0 10px rgba(255, 152, 0, 0.5)';
      rsiValue.style.color = '#00d4ff';
    }
    
    // Update values
    rsiValue.textContent = `RSI: ${data.rsi.toFixed(1)}`;
    signalQuality.textContent = `Quality: ${data.quality}% | Confidence: ${data.confidence}%`;
    
    // Update other details
    document.getElementById('currentAsset').textContent = this.currentAsset.symbol;
    document.getElementById('signalStrength').textContent = data.strength;
    document.getElementById('confidenceLevel').textContent = `${data.confidence}%`;
  }
  
  subscribeToTicker(symbol) {
    if (!this.isConnected) return;
    
    const subscribeRequest = {
      ticks: symbol,
      subscribe: 1
    };
    
    this.sendWebSocketMessage(subscribeRequest);
    this.subscriptions.add(symbol);
    
    this.updateLog(`Subscribed to ${symbol}`, 'deriv');
  }
  
  subscribeToAllAssets() {
    if (!this.isConnected) {
      this.updateLog('Not connected to WebSocket', 'error');
      return;
    }
    
    this.updateLog('Subscribing to all assets...', 'system');
    
    this.assets.forEach(asset => {
      this.subscribeToTicker(asset.derivSymbol);
    });
    
    this.updateLog('Subscribed to all 5 assets', 'success');
  }
  
  unsubscribeFromTicker(symbol) {
    if (!this.isConnected) return;
    
    const unsubscribeRequest = {
      ticks: symbol,
      unsubscribe: 1
    };
    
    this.sendWebSocketMessage(unsubscribeRequest);
    this.subscriptions.delete(symbol);
    
    this.updateLog(`Unsubscribed from ${symbol}`, 'deriv');
  }
  
  disconnectWebSocket() {
    if (this.ws) {
      // Unsubscribe from all
      this.subscriptions.forEach(symbol => {
        this.unsubscribeFromTicker(symbol);
      });
      
      // Close connection
      this.ws.close(1000, 'User requested disconnect');
    }
  }
  
  startEngine() {
    if (!this.isConnected) {
      this.updateLog('Please connect to WebSocket first', 'error');
      return;
    }
    
    this.isEngineRunning = true;
    
    // Update UI
    document.getElementById('startEngineBtn').disabled = true;
    document.getElementById('stopEngineBtn').disabled = false;
    document.getElementById('connectionStatus').classList.remove('offline');
    document.getElementById('connectionStatus').querySelector('.status-dot').classList.remove('offline');
    document.getElementById('connectionStatus').querySelector('span').textContent = 'LIVE';
    
    // Subscribe to current asset
    this.subscribeToTicker(this.currentAsset.derivSymbol);
    
    this.updateLog('Advanced RSI Signal Engine Started', 'success');
    this.updateLog('Strategy: 20-80 RSI with extreme zones (12/88)', 'system');
    this.updateLog('Multi-timeframe confirmation enabled', 'system');
    this.updateLog('Machine Learning enhancement active', 'system');
  }
  
  stopEngine() {
    this.isEngineRunning = false;
    
    // Update UI
    document.getElementById('startEngineBtn').disabled = false;
    document.getElementById('stopEngineBtn').disabled = true;
    
    // Unsubscribe from all
    this.subscriptions.forEach(symbol => {
      this.unsubscribeFromTicker(symbol);
    });
    
    this.updateLog('Signal engine stopped', 'system');
  }
  
  updateWebSocketStatus() {
    const wsDot = document.getElementById('wsDot');
    const wsStatus = document.getElementById('wsStatus');
    const wsServer = document.getElementById('wsServer');
    
    if (this.isConnected) {
      wsDot.className = 'ws-dot connected';
      wsStatus.textContent = 'CONNECTED';
      wsServer.textContent = this.currentServer ? this.currentServer.name : 'Unknown';
      
      // Update header status
      document.getElementById('connectionStatus').classList.remove('offline', 'connecting');
      document.getElementById('connectionStatus').querySelector('.status-dot').classList.remove('offline', 'connecting');
      document.getElementById('connectionStatus').querySelector('span').textContent = 'CONNECTED';
      
    } else if (this.isConnecting) {
      wsDot.className = 'ws-dot connecting';
      wsStatus.textContent = 'CONNECTING';
      wsServer.textContent = 'Establishing connection...';
      
      // Update header status
      document.getElementById('connectionStatus').classList.add('connecting');
      document.getElementById('connectionStatus').querySelector('.status-dot').classList.add('connecting');
      document.getElementById('connectionStatus').querySelector('span').textContent = 'CONNECTING';
      
    } else {
      wsDot.className = 'ws-dot disconnected';
      wsStatus.textContent = 'DISCONNECTED';
      wsServer.textContent = 'Not connected';
      
      // Update header status
      document.getElementById('connectionStatus').classList.add('offline');
      document.getElementById('connectionStatus').querySelector('.status-dot').classList.add('offline');
      document.getElementById('connectionStatus').querySelector('span').textContent = 'DISCONNECTED';
    }
  }
  
  startStatsUpdate() {
    // Update stats every second
    this.statsInterval = setInterval(() => {
      this.updateStats();
    }, 1000);
  }
  
  updateStats() {
    // Update WebSocket stats
    document.getElementById('wsMessages').textContent = this.stats.messagesReceived;
    document.getElementById('wsLatency').textContent = `${this.stats.latency}ms`;
    
    // Calculate quality score
    const qualityScore = Math.min(100, Math.max(0, 
      this.stats.successfulSignals > 0 ? 
      (this.stats.successfulSignals / this.stats.totalSignals) * 100 : 
      85 + (Math.random() * 10)
    ));
    
    document.getElementById('wsQuality').textContent = `${qualityScore.toFixed(1)}%`;
    
    // Update uptime
    if (this.stats.connectionStartTime) {
      const uptimeSeconds = Math.floor((Date.now() - this.stats.connectionStartTime) / 1000);
      const hours = Math.floor(uptimeSeconds / 3600);
      const minutes = Math.floor((uptimeSeconds % 3600) / 60);
      const seconds = uptimeSeconds % 60;
      
      if (hours > 0) {
        document.getElementById('wsUptime').textContent = `${hours}h ${minutes}m`;
      } else {
        document.getElementById('wsUptime').textContent = `${minutes}m ${seconds}s`;
      }
    }
    
    // Update other metrics
    document.getElementById('signalsToday').textContent = this.stats.signalsGenerated;
    
    // Calculate accuracy
    const accuracy = this.stats.totalSignals > 0 ? 
      (this.stats.successfulSignals / this.stats.totalSignals) * 100 : 
      85 + (Math.random() * 10);
    
    document.getElementById('accuracyMetric').textContent = `${accuracy.toFixed(1)}%`;
    document.getElementById('mlAccuracy').textContent = `${this.mlModel.accuracy.toFixed(1)}%`;
    
    // Calculate data rate
    const dataRate = this.stats.dataPoints / (this.stats.connectionStartTime ? 
      (Date.now() - this.stats.connectionStartTime) / 1000 : 1);
    document.getElementById('dataRate').textContent = `${dataRate.toFixed(1)}/s`;
    
    // Update overall stats
    this.stats.qualityScore = qualityScore;
  }
  
  updateLastUpdateTime() {
    const now = new Date();
    const timeStr = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
    document.getElementById('lastUpdateTime').textContent = timeStr;
  }
  
  logSignal(asset, price, signal) {
    const time = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
    const logClass = signal.direction === 'BUY' ? 'log-buy' : 'log-sell';
    
    const signalType = signal.strength === 'EXTREME' ? '🚨 EXTREME ' : 
                      signal.strength === 'STRONG' ? '✅ STRONG ' : '📊 ';
    
    const logEntry = document.createElement('div');
    logEntry.className = 'log-entry';
    logEntry.innerHTML = `
      <div class="log-time">${time}</div>
      <div class="log-content ${logClass}">
        <strong>${signalType}${signal.direction}</strong> ${asset.symbol} @ $${price.toFixed(asset.symbol === 'EURUSD' ? 4 : 2)}
        <span style="color: var(--text-muted); font-size: 0.8em;"> - RSI: ${signal.rsi.toFixed(1)} | Quality: ${signal.quality}% | Confirmations: ${signal.confirmations}</span>
      </div>
    `;
    
    const logsContainer = document.getElementById('signalLogs');
    logsContainer.prepend(logEntry);
    
    // Keep only last 25 logs
    if (logsContainer.children.length > 25) {
      logsContainer.removeChild(logsContainer.lastChild);
    }
  }
  
  updateLog(message, type = 'system') {
    const time = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
    const typeClass = `log-${type}`;
    
    const logEntry = document.createElement('div');
    logEntry.className = 'log-entry';
    logEntry.innerHTML = `
      <div class="log-time">${time}</div>
      <div class="log-content ${typeClass}">${message}</div>
    `;
    
    const logsContainer = document.getElementById('signalLogs');
    logsContainer.prepend(logEntry);
    
    // Keep only last 25 logs
    if (logsContainer.children.length > 25) {
      logsContainer.removeChild(logsContainer.lastChild);
    }
  }
  
  clearLogs() {
    const logsContainer = document.getElementById('signalLogs');
    logsContainer.innerHTML = '';
    this.updateLog('Logs cleared', 'system');
  }
  
  updateUI() {
    // Update UI based on connection state
    const statusBadge = document.getElementById('connectionStatus');
    
    if (this.isConnected && this.isEngineRunning) {
      statusBadge.classList.remove('offline');
      statusBadge.querySelector('.status-dot').classList.remove('offline');
      statusBadge.querySelector('span').textContent = 'LIVE';
    } else if (this.isConnected) {
      statusBadge.classList.remove('offline');
      statusBadge.querySelector('.status-dot').classList.remove('offline');
      statusBadge.querySelector('span').textContent = 'CONNECTED';
    } else {
      statusBadge.classList.add('offline');
      statusBadge.querySelector('.status-dot').classList.add('offline');
      statusBadge.querySelector('span').textContent = 'DISCONNECTED';
    }
  }
  
  handleOHLCData(data) {
    // Handle OHLC data for multi-timeframe analysis
    const ohlc = data.ohlc;
    if (!ohlc || !ohlc.symbol) return;
    
    // In a real implementation, this would process OHLC data
    // for different timeframes and update confirmation levels
    this.updateLog(`OHLC data received for ${ohlc.symbol}: ${ohlc.close}`, 'deriv');
  }
}

// Initialize the application
const app = new AdvancedDerivWebSocketEngine();

// Auto-connect to demo server after 1 second (for testing)
setTimeout(() => {
  document.getElementById('connectWsBtn').click();
}, 1000);
</script>
</body>
</html>
