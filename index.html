<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KILER ZONE - Real-Time Trading Dashboard</title>
    <style>
        /* CSS Styles - Everything included */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        :root {
            --buy-color: #10b981;
            --sell-color: #ef4444;
            --neutral-color: #6b7280;
            --bg-dark: #0f172a;
            --bg-card: #1e293b;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --warning: #f59e0b;
            --error: #dc2626;
            --success: #22c55e;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            line-height: 1.6;
            padding: 15px;
            min-height: 100vh;
        }
        
        .container { max-width: 1400px; margin: 0 auto; }
        
        /* Header */
        .header {
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--bg-card);
        }
        
        .title {
            font-size: 2rem;
            background: linear-gradient(90deg, #ffd700, #ffed4e);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            margin-bottom: 5px;
            font-weight: 800;
        }
        
        .subtitle {
            color: var(--text-secondary);
            font-size: 0.85rem;
        }
        
        /* Connection Status */
        .connection-banner {
            background: var(--bg-card);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid #334155;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .status-section {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--error);
        }
        
        .status-dot.connected { background: var(--success); animation: pulse 2s infinite; }
        .status-dot.connecting { background: var(--warning); }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .status-text {
            font-size: 0.9rem;
            font-weight: 600;
        }
        
        .connection-time {
            font-size: 0.85rem;
            color: var(--text-secondary);
            font-family: 'Courier New', monospace;
        }
        
        /* API Setup */
        .api-setup {
            background: linear-gradient(135deg, #1e293b, #334155);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            border: 2px solid var(--warning);
        }
        
        .api-setup h3 {
            margin-bottom: 10px;
            color: var(--warning);
        }
        
        .api-input-group {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        
        .api-input-group input {
            flex: 1;
            min-width: 200px;
            padding: 10px;
            background: var(--bg-dark);
            border: 1px solid #475569;
            border-radius: 5px;
            color: var(--text-primary);
            font-family: 'Courier New', monospace;
        }
        
        .connect-btn {
            padding: 10px 25px;
            background: var(--success);
            color: white;
            border: none;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .connect-btn:hover { background: #16a34a; transform: scale(1.02); }
        .connect-btn:disabled { background: var(--neutral-color); cursor: not-allowed; }
        
        .disconnect-btn {
            padding: 10px 25px;
            background: var(--error);
            color: white;
            border: none;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
        }
        
        .api-info {
            margin-top: 10px;
            padding: 10px;
            background: rgba(59, 130, 246, 0.1);
            border-radius: 5px;
            font-size: 0.85rem;
            border-left: 3px solid #3b82f6;
        }
        
        /* Controls */
        .controls {
            background: var(--bg-card);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #334155;
        }
        
        .control-row {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .control-group label {
            font-size: 0.85rem;
            color: var(--text-secondary);
            white-space: nowrap;
        }
        
        .control-group input, .control-group select {
            padding: 6px 10px;
            background: var(--bg-dark);
            border: 1px solid #475569;
            border-radius: 5px;
            color: var(--text-primary);
            font-size: 0.85rem;
        }
        
        .control-group input {
            width: 60px;
            text-align: center;
        }
        
        /* Assets Grid */
        .assets-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .asset-card {
            background: var(--bg-card);
            border-radius: 10px;
            padding: 15px;
            border: 2px solid transparent;
            transition: all 0.3s;
            position: relative;
        }
        
        .asset-card.buy-signal { 
            border-color: var(--buy-color); 
            box-shadow: 0 0 20px rgba(16, 185, 129, 0.3); 
        }
        
        .asset-card.sell-signal { 
            border-color: var(--sell-color); 
            box-shadow: 0 0 20px rgba(239, 68, 68, 0.3); 
        }
        
        .asset-card.neutral { border-color: #334155; }
        .asset-card.offline { opacity: 0.6; }
        
        .signal-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: bold;
            text-transform: uppercase;
        }
        
        .signal-badge.buy { background: var(--buy-color); }
        .signal-badge.sell { background: var(--sell-color); }
        .signal-badge.neutral { background: var(--neutral-color); }
        
        .asset-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 12px;
        }
        
        .asset-info h3 {
            font-size: 1.1rem;
            margin-bottom: 2px;
        }
        
        .asset-symbol {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }
        
        .price-section {
            text-align: right;
        }
        
        .current-price {
            font-size: 1.5rem;
            font-weight: bold;
            font-family: 'Courier New', monospace;
        }
        
        .price-change {
            font-size: 0.85rem;
            font-family: 'Courier New', monospace;
        }
        
        .price-change.positive { color: var(--buy-color); }
        .price-change.negative { color: var(--sell-color); }
        
        /* Mini Chart */
        .mini-chart {
            height: 120px;
            margin: 12px 0;
            background: rgba(15, 23, 42, 0.5);
            border-radius: 6px;
            overflow: hidden;
            position: relative;
        }
        
        .mini-chart canvas {
            width: 100%;
            height: 100%;
        }
        
        /* RSI Display */
        .rsi-display {
            margin: 12px 0;
        }
        
        .rsi-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }
        
        .rsi-label {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }
        
        .rsi-value {
            font-size: 1.2rem;
            font-weight: bold;
            font-family: 'Courier New', monospace;
        }
        
        .rsi-bar-container {
            height: 16px;
            background: #334155;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }
        
        .rsi-bar {
            height: 100%;
            transition: width 0.5s ease, background 0.3s;
        }
        
        .rsi-bar.oversold { background: var(--buy-color); }
        .rsi-bar.neutral { background: var(--warning); }
        .rsi-bar.overbought { background: var(--sell-color); }
        
        .rsi-levels {
            display: flex;
            justify-content: space-between;
            margin-top: 4px;
            font-size: 0.7rem;
            color: var(--text-secondary);
        }
        
        /* Card Footer */
        .card-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #334155;
            font-size: 0.8rem;
            color: var(--text-secondary);
        }
        
        .last-update {
            font-family: 'Courier New', monospace;
        }
        
        .signal-strength {
            font-weight: 600;
        }
        
        /* Signal Log */
        .signal-log {
            background: var(--bg-card);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            border: 1px solid #334155;
        }
        
        .signal-log h3 {
            margin-bottom: 10px;
            font-size: 1rem;
        }
        
        .log-entries {
            max-height: 200px;
            overflow-y: auto;
        }
        
        .log-entry {
            display: flex;
            gap: 10px;
            padding: 8px 0;
            border-bottom: 1px solid #334155;
            font-size: 0.85rem;
            align-items: center;
        }
        
        .log-time {
            font-family: 'Courier New', monospace;
            color: var(--text-secondary);
            min-width: 80px;
        }
        
        .log-symbol {
            font-weight: 600;
            min-width: 70px;
        }
        
        .log-signal {
            font-weight: bold;
            padding: 2px 8px;
            border-radius: 4px;
        }
        
        .log-signal.buy { color: var(--buy-color); background: rgba(16, 185, 129, 0.1); }
        .log-signal.sell { color: var(--sell-color); background: rgba(239, 68, 68, 0.1); }
        
        .log-price {
            font-family: 'Courier New', monospace;
            margin-left: auto;
        }
        
        /* Disclaimer */
        .disclaimer {
            background: linear-gradient(135deg, #7c2d12, #9a3412);
            color: #fbbf24;
            padding: 15px;
            border-radius: 8px;
            font-size: 0.85rem;
            border: 2px solid #ea580c;
            line-height: 1.5;
        }
        
        .disclaimer strong {
            display: block;
            margin-bottom: 8px;
            font-size: 1rem;
        }
        
        /* Loading/Error States */
        .loading-state, .error-state {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-secondary);
        }
        
        .error-state {
            color: var(--error);
        }
        
        .spinner {
            border: 3px solid #334155;
            border-top: 3px solid var(--success);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Mobile Responsive */
        @media (max-width: 768px) {
            body { padding: 10px; }
            .title { font-size: 1.5rem; }
            .subtitle { font-size: 0.75rem; }
            .assets-grid { grid-template-columns: 1fr; }
            .connection-banner { flex-direction: column; align-items: flex-start; }
            .control-row { flex-direction: column; align-items: stretch; }
            .control-group { justify-content: space-between; }
            .api-input-group { flex-direction: column; }
            .api-input-group input { min-width: 100%; }
        }
    </style>
</head>
<body>
    <!-- HTML Content - Everything included -->
    <div class="container">
        <div class="header">
            <h1 class="title">‚ö° KILER ZONE</h1>
            <p class="subtitle">Real-Time RSI Reversal Signals ‚Ä¢ Powered by Deriv API</p>
        </div>

        <div class="connection-banner">
            <div class="status-section">
                <div class="status-dot" id="statusDot"></div>
                <span class="status-text" id="statusText">Disconnected</span>
            </div>
            <div class="connection-time" id="connectionTime">--:--:--</div>
        </div>

        <div class="api-setup" id="apiSetup">
            <h3>üîå Connect to Deriv API</h3>
            <div class="api-input-group">
                <input type="text" id="apiToken" placeholder="Enter your Deriv API Token" autocomplete="off">
                <button class="connect-btn" id="connectBtn">Connect</button>
            </div>
            <div class="api-info">
                ‚ÑπÔ∏è Get your API token from <strong>Deriv.com ‚Üí Settings ‚Üí API Token</strong>. 
                Create a token with "Read" permissions only. Your token is stored locally and never shared.
            </div>
        </div>

        <div class="controls" id="controls" style="display: none;">
            <div class="control-row">
                <div class="control-group">
                    <label>RSI Period:</label>
                    <input type="number" id="rsiPeriod" value="14" min="5" max="30">
                </div>
                <div class="control-group">
                    <label>Oversold:</label>
                    <input type="number" id="oversoldLevel" value="30" min="10" max="40">
                </div>
                <div class="control-group">
                    <label>Overbought:</label>
                    <input type="number" id="overboughtLevel" value="70" min="60" max="90">
                </div>
                <button class="disconnect-btn" id="disconnectBtn">Disconnect</button>
            </div>
        </div>

        <div class="assets-grid" id="assetsGrid">
            <div class="loading-state">
                <div class="spinner"></div>
                <p>Connect to Deriv API to start trading</p>
            </div>
        </div>

        <div class="signal-log" id="signalLog" style="display: none;">
            <h3>üìä Recent Trading Signals</h3>
            <div class="log-entries" id="logEntries"></div>
        </div>

        <div class="disclaimer">
            <strong>‚ö†Ô∏è IMPORTANT RISK DISCLAIMER</strong>
            This dashboard provides RSI-based trading signals for EDUCATIONAL and INFORMATIONAL purposes only. 
            Trading involves substantial risk of loss. Signals are not financial advice. You are solely responsible 
            for your trading decisions. This tool does NOT execute trades automatically. Past performance does not 
            guarantee future results. Only trade with money you can afford to lose. Not regulated financial advice.
        </div>
    </div>

    <!-- JavaScript - Everything included -->
    <script>
        // ===================== CONFIGURATION =====================
        const CONFIG = {
            DERIV_APP_ID: 1089,
            WS_URL: 'wss://ws.derivws.com/websockets/v3',
            SYMBOLS: ['R_10', 'R_25', 'R_50', 'R_75', 'R_100'],
            RSI_PERIOD: 14,
            OVERSOLD: 30,
            OVERBOUGHT: 70,
            CANDLE_INTERVAL: 60,
            MAX_CANDLES: 50,
            UPDATE_INTERVAL: 1000,
            MAX_LOG_ENTRIES: 50
        };

        const SYMBOL_INFO = {
            'R_10': { name: 'Volatility 10 Index', decimals: 3 },
            'R_25': { name: 'Volatility 25 Index', decimals: 3 },
            'R_50': { name: 'Volatility 50 Index', decimals: 2 },
            'R_75': { name: 'Volatility 75 Index', decimals: 2 },
            'R_100': { name: 'Volatility 100 Index', decimals: 2 }
        };

        // ===================== STATE MANAGEMENT =====================
        class AppState {
            constructor() {
                this.ws = null;
                this.connected = false;
                this.apiToken = null;
                this.subscriptions = new Map();
                this.marketData = new Map();
                this.signals = new Map();
                this.charts = new Map();
                this.lastPrices = new Map();
                this.signalLog = [];
            }

            reset() {
                this.subscriptions.clear();
                this.marketData.clear();
                this.signals.clear();
                this.charts.clear();
                this.lastPrices.clear();
                this.signalLog = [];
            }
        }

        const state = new AppState();

        // ===================== DERIV API MANAGER =====================
        class DerivAPI {
            static connect(token) {
                return new Promise((resolve, reject) => {
                    try {
                        const wsUrl = `${CONFIG.WS_URL}?app_id=${CONFIG.DERIV_APP_ID}`;
                        state.ws = new WebSocket(wsUrl);
                        
                        state.ws.onopen = () => {
                            console.log('‚úÖ Connected to Deriv');
                            state.connected = true;
                            state.apiToken = token;
                            this.authorize(token).then(resolve).catch(reject);
                        };
                        
                        state.ws.onmessage = (msg) => this.handleMessage(JSON.parse(msg.data));
                        
                        state.ws.onerror = (error) => {
                            console.error('WebSocket error:', error);
                            reject(new Error('Connection failed'));
                        };
                        
                        state.ws.onclose = () => {
                            console.log('Disconnected from Deriv');
                            state.connected = false;
                            UI.updateConnectionStatus(false);
                        };
                    } catch (error) {
                        reject(error);
                    }
                });
            }

            static authorize(token) {
                return new Promise((resolve, reject) => {
                    const authRequest = { authorize: token };
                    this.send(authRequest);
                    
                    const timeout = setTimeout(() => {
                        reject(new Error('Authorization timeout'));
                    }, 5000);

                    const authHandler = (msg) => {
                        if (msg.msg_type === 'authorize') {
                            clearTimeout(timeout);
                            if (msg.error) {
                                reject(new Error(msg.error.message));
                            } else {
                                resolve(msg.authorize);
                            }
                        }
                    };

                    const originalHandler = state.ws.onmessage;
                    state.ws.onmessage = (msg) => {
                        const data = JSON.parse(msg.data);
                        authHandler(data);
                        if (originalHandler) originalHandler(msg);
                    };
                });
            }

            static send(data) {
                if (state.ws && state.ws.readyState === WebSocket.OPEN) {
                    state.ws.send(JSON.stringify(data));
                }
            }

            static subscribeTicks(symbol) {
                const request = {
                    ticks: symbol,
                    subscribe: 1
                };
                this.send(request);
            }

            static subscribeCandles(symbol) {
                const request = {
                    ticks_history: symbol,
                    adjust_start_time: 1,
                    count: CONFIG.MAX_CANDLES,
                    end: 'latest',
                    start: 1,
                    style: 'candles',
                    granularity: CONFIG.CANDLE_INTERVAL,
                    subscribe: 1
                };
                this.send(request);
            }

            static handleMessage(data) {
                if (data.error) {
                    console.error('Deriv API Error:', data.error.message);
                    UI.showError(data.error.message);
                    return;
                }

                if (data.msg_type === 'tick') {
                    this.handleTick(data.tick);
                }

                if (data.msg_type === 'ohlc') {
                    this.handleOHLC(data.ohlc);
                }
            }

            static handleTick(tick) {
                const symbol = tick.symbol;
                const price = parseFloat(tick.quote);
                
                state.lastPrices.set(symbol, {
                    price: price,
                    time: tick.epoch,
                    timestamp: Date.now()
                });

                Analyzer.updatePrice(symbol, price);
                UI.updateAssetCard(symbol);
            }

            static handleOHLC(ohlc) {
                const symbol = ohlc.symbol;
                const candle = {
                    time: ohlc.epoch,
                    open: parseFloat(ohlc.open),
                    high: parseFloat(ohlc.high),
                    low: parseFloat(ohlc.low),
                    close: parseFloat(ohlc.close)
                };

                if (!state.marketData.has(symbol)) {
                    state.marketData.set(symbol, { candles: [] });
                }

                const data = state.marketData.get(symbol);
                data.candles.push(candle);
                
                if (data.candles.length > CONFIG.MAX_CANDLES) {
                    data.candles.shift();
                }

                Analyzer.analyze(symbol);
                UI.updateAssetCard(symbol);
            }

            static disconnect() {
                if (state.ws) {
                    state.ws.close();
                    state.ws = null;
                }
                state.reset();
                state.connected = false;
            }
        }

        // ===================== TECHNICAL ANALYSIS =====================
        class Analyzer {
            static calculateRSI(prices, period = CONFIG.RSI_PERIOD) {
                if (!prices || prices.length < period + 1) return null;

                let gains = 0;
                let losses = 0;

                for (let i = 1; i <= period; i++) {
                    const change = prices[i] - prices[i - 1];
                    if (change > 0) gains += change;
                    else losses -= change;
                }

                let avgGain = gains / period;
                let avgLoss = losses / period;

                for (let i = period + 1; i < prices.length; i++) {
                    const change = prices[i] - prices[i - 1];
                    if (change > 0) {
                        avgGain = (avgGain * (period - 1) + change) / period;
                        avgLoss = (avgLoss * (period - 1)) / period;
                    } else {
                        avgGain = (avgGain * (period - 1)) / period;
                        avgLoss = (avgLoss * (period - 1) - change) / period;
                    }
                }

                if (avgLoss === 0) return 100;
                const rs = avgGain / avgLoss;
                return 100 - (100 / (1 + rs));
            }

            static generateSignal(rsi, prevRsi, oversold, overbought) {
                if (!rsi || !prevRsi) return { type: 'NEUTRAL', strength: 'NONE', reason: 'Insufficient data' };

                if (prevRsi <= oversold && rsi > oversold) {
                    return { type: 'BUY', strength: 'STRONG', reason: 'RSI crossed above oversold' };
                }
                
                if (prevRsi >= overbought && rsi < overbought) {
                    return { type: 'SELL', strength: 'STRONG', reason: 'RSI crossed below overbought' };
                }
                
                if (rsi < 35 && rsi > prevRsi) {
                    return { type: 'BUY', strength: 'WEAK', reason: 'RSI rising from oversold' };
                }
                
                if (rsi > 65 && rsi < prevRsi) {
                    return { type: 'SELL', strength: 'WEAK', reason: 'RSI falling from overbought' };
                }

                return { type: 'NEUTRAL', strength: 'NONE', reason: 'No clear signal' };
            }

            static analyze(symbol) {
                const data = state.marketData.get(symbol);
                if (!data || !data.candles || data.candles.length < CONFIG.RSI_PERIOD + 1) return;

                const prices = data.candles.map(c => c.close);
                const currentRsi = this.calculateRSI(prices, CONFIG.RSI_PERIOD);
                
                if (currentRsi === null) return;

                const prevPrices = prices.slice(0, -1);
                const prevRsi = this.calculateRSI(prevPrices, CONFIG.RSI_PERIOD);

                const signal = this.generateSignal(
                    currentRsi,
                    prevRsi,
                    CONFIG.OVERSOLD,
                    CONFIG.OVERBOUGHT
                );

                data.rsi = currentRsi;
                data.signal = signal;
                data.timestamp = Date.now();

                const prevSignal = state.signals.get(symbol);
                const isNewSignal = signal.type !== 'NEUTRAL' && 
                    (!prevSignal || prevSignal.type !== signal.type || 
                     Date.now() - prevSignal.timestamp > 300000);

                if (isNewSignal) {
                    signal.timestamp = Date.now();
                    signal.price = prices[prices.length - 1];
                    state.signals.set(symbol, signal);
                    UI.addSignalLog(symbol, signal);
                    this.playNotification(signal.type);
                }
            }

            static updatePrice(symbol, price) {
                const data = state.marketData.get(symbol);
                if (!data) return;

                data.currentPrice = price;
                data.lastUpdate = Date.now();
            }

            static playNotification(signalType) {
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = signalType === 'BUY' ? 880 : 440;
                    oscillator.type = 'sine';
                    
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.5);
                } catch (e) {
                    console.log('Audio notification not supported');
                }
            }
        }

        // ===================== USER INTERFACE =====================
        class UI {
            static init() {
                this.setupEventListeners();
                this.updateConnectionStatus(false);
                this.renderInitialAssets();
                this.updateTime();
                setInterval(() => this.updateTime(), 1000);
                
                // Load saved API token
                const savedToken = localStorage.getItem('deriv_api_token');
                if (savedToken) {
                    document.getElementById('apiToken').value = savedToken;
                }
            }

            static setupEventListeners() {
                // Connect button
                document.getElementById('connectBtn').addEventListener('click', async () => {
                    await this.connectToAPI();
                });

                // Disconnect button
                document.getElementById('disconnectBtn').addEventListener('click', () => {
                    this.disconnectFromAPI();
                });

                // Enter key for API token input
                document.getElementById('apiToken').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.connectToAPI();
                    }
                });

                // RSI parameter changes
                document.getElementById('rsiPeriod').addEventListener('change', (e) => {
                    CONFIG.RSI_PERIOD = parseInt(e.target.value);
                    this.reanalyzeAll();
                });

                document.getElementById('oversoldLevel').addEventListener('change', (e) => {
                    CONFIG.OVERSOLD = parseInt(e.target.value);
                    this.reanalyzeAll();
                });

                document.getElementById('overboughtLevel').addEventListener('change', (e) => {
                    CONFIG.OVERBOUGHT = parseInt(e.target.value);
                    this.reanalyzeAll();
                });

                // Save API token to localStorage
                document.getElementById('apiToken').addEventListener('input', (e) => {
                    if (e.target.value) {
                        localStorage.setItem('deriv_api_token', e.target.value);
                    }
                });
            }

            static async connectToAPI() {
                const token = document.getElementById('apiToken').value.trim();
                if (!token) {
                    this.showError('Please enter your Deriv API token');
                    return;
                }

                if (token.length < 20) {
                    this.showError('Invalid API token format');
                    return;
                }

                const btn = document.getElementById('connectBtn');
                btn.disabled = true;
                btn.textContent = 'Connecting...';
                this.updateConnectionStatus(false, 'Connecting...');

                try {
                    await DerivAPI.connect(token);
                    
                    this.updateConnectionStatus(true, 'Connected to Deriv');
                    document.getElementById('controls').style.display = 'block';
                    document.getElementById('signalLog').style.display = 'block';
                    btn.style.display = 'none';
                    document.getElementById('apiToken').style.display = 'none';
                    
                    this.subscribeToAssets();
                    this.renderAssetsGrid();
                    
                } catch (error) {
                    this.showError('Connection failed: ' + error.message);
                    btn.disabled = false;
                    btn.textContent = 'Connect';
                    this.updateConnectionStatus(false, 'Connection failed');
                    document.getElementById('apiToken').style.display = 'block';
                }
            }

            static disconnectFromAPI() {
                DerivAPI.disconnect();
                this.updateConnectionStatus(false, 'Disconnected');
                document.getElementById('controls').style.display = 'none';
                document.getElementById('signalLog').style.display = 'none';
                document.getElementById('connectBtn').style.display = 'block';
                document.getElementById('connectBtn').disabled = false;
                document.getElementById('connectBtn').textContent = 'Connect';
                document.getElementById('apiToken').style.display = 'block';
                
                // Clear assets grid
                document.getElementById('assetsGrid').innerHTML = `
                    <div class="loading-state">
                        <div class="spinner"></div>
                        <p>Connect to Deriv API to start trading</p>
                    </div>
                `;
            }

            static subscribeToAssets() {
                CONFIG.SYMBOLS.forEach(symbol => {
                    setTimeout(() => {
                        DerivAPI.subscribeCandles(symbol);
                    }, 100);
                    
                    setTimeout(() => {
                        DerivAPI.subscribeTicks(symbol);
                    }, 500);
                });
            }

            static updateConnectionStatus(connected, message = '') {
                const dot = document.getElementById('statusDot');
                const text = document.getElementById('statusText');
                
                if (connected) {
                    dot.className = 'status-dot connected';
                    text.textContent = message || 'Connected';
                    dot.style.background = 'var(--success)';
                } else if (message === 'Connecting...') {
                    dot.className = 'status-dot connecting';
                    text.textContent = message;
                    dot.style.background = 'var(--warning)';
                } else {
                    dot.className = 'status-dot';
                    text.textContent = message || 'Disconnected';
                    dot.style.background = 'var(--error)';
                }
            }

            static updateTime() {
                const now = new Date();
                const timeString = now.toLocaleTimeString('en-US', { 
                    hour12: false,
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                });
                document.getElementById('connectionTime').textContent = timeString;
            }

            static showError(message) {
                console.error('UI Error:', message);
                // Could add a toast notification here
                alert(`Error: ${message}`);
            }

            static renderInitialAssets() {
                const grid = document.getElementById('assetsGrid');
                grid.innerHTML = CONFIG.SYMBOLS.map(symbol => `
                    <div class="asset-card neutral offline" id="card-${symbol}">
                        <div class="signal-badge neutral">OFFLINE</div>
                        <div class="asset-header">
                            <div class="asset-info">
                                <h3>${SYMBOL_INFO[symbol].name}</h3>
                                <div class="asset-symbol">${symbol}</div>
                            </div>
                            <div class="price-section">
                                <div class="current-price">--</div>
                                <div class="price-change">0.00%</div>
                            </div>
                        </div>
                        <div class="mini-chart" id="chart-${symbol}">
                            <canvas></canvas>
                        </div>
                        <div class="rsi-display">
                            <div class="rsi-header">
                                <span class="rsi-label">RSI(14)</span>
                                <span class="rsi-value" id="rsi-${symbol}">--</span>
                            </div>
                            <div class="rsi-bar-container">
                                <div class="rsi-bar neutral" id="rsi-bar-${symbol}" style="width: 50%"></div>
                            </div>
                            <div class="rsi-levels">
                                <span>0</span>
                                <span>30</span>
                                <span>50</span>
                                <span>70</span>
                                <span>100</span>
                            </div>
                        </div>
                        <div class="card-footer">
                            <div class="last-update">--:--:--</div>
                            <div class="signal-strength">NO SIGNAL</div>
                        </div>
                    </div>
                `).join('');
            }

            static renderAssetsGrid() {
                const grid = document.getElementById('assetsGrid');
                grid.innerHTML = CONFIG.SYMBOLS.map(symbol => `
                    <div class="asset-card neutral" id="card-${symbol}">
                        <div class="signal-badge neutral">WAITING</div>
                        <div class="asset-header">
                            <div class="asset-info">
                                <h3>${SYMBOL_INFO[symbol].name}</h3>
                                <div class="asset-symbol">${symbol}</div>
                            </div>
                            <div class="price-section">
                                <div class="current-price" id="price-${symbol}">--</div>
                                <div class="price-change" id="change-${symbol}">0.00%</div>
                            </div>
                        </div>
                        <div class="mini-chart" id="chart-${symbol}">
                            <canvas></canvas>
                        </div>
                        <div class="rsi-display">
                            <div class="rsi-header">
                                <span class="rsi-label">RSI(${CONFIG.RSI_PERIOD})</span>
                                <span class="rsi-value" id="rsi-${symbol}">--</span>
                            </div>
                            <div class="rsi-bar-container">
                                <div class="rsi-bar neutral" id="rsi-bar-${symbol}" style="width: 50%"></div>
                            </div>
                            <div class="rsi-levels">
                                <span>0</span>
                                <span>${CONFIG.OVERSOLD}</span>
                                <span>50</span>
                                <span>${CONFIG.OVERBOUGHT}</span>
                                <span>100</span>
                            </div>
                        </div>
                        <div class="card-footer">
                            <div class="last-update" id="update-${symbol}">--:--:--</div>
                            <div class="signal-strength" id="strength-${symbol}">WAITING</div>
                        </div>
                    </div>
                `).join('');
                
                // Initialize charts
                this.initCharts();
            }

            static initCharts() {
                CONFIG.SYMBOLS.forEach(symbol => {
                    const container = document.getElementById(`chart-${symbol}`);
                    const canvas = container.querySelector('canvas');
                    if (canvas) {
                        const ctx = canvas.getContext('2d');
                        state.charts.set(symbol, {
                            ctx: ctx,
                            canvas: canvas,
                            data: []
                        });
                    }
                });
            }

            static updateAssetCard(symbol) {
                const data = state.marketData.get(symbol);
                if (!data || !data.candles || data.candles.length === 0) return;

                const card = document.getElementById(`card-${symbol}`);
                if (!card) return;

                // Remove offline class if present
                card.classList.remove('offline');

                // Update price
                const lastCandle = data.candles[data.candles.length - 1];
                const price = data.currentPrice || lastCandle.close;
                const prevPrice = data.candles.length > 1 ? 
                    data.candles[data.candles.length - 2].close : price;
                const change = ((price - prevPrice) / prevPrice * 100);

                const priceEl = document.getElementById(`price-${symbol}`);
                if (priceEl) {
                    priceEl.textContent = price.toFixed(SYMBOL_INFO[symbol].decimals);
                }
                
                const changeElement = document.getElementById(`change-${symbol}`);
                if (changeElement) {
                    changeElement.textContent = `${change >= 0 ? '+' : ''}${change.toFixed(2)}%`;
                    changeElement.className = `price-change ${change >= 0 ? 'positive' : 'negative'}`;
                }

                // Update RSI
                const rsiValue = document.getElementById(`rsi-${symbol}`);
                const rsiBar = document.getElementById(`rsi-bar-${symbol}`);
                
                if (data.rsi && rsiValue && rsiBar) {
                    rsiValue.textContent = data.rsi.toFixed(2);
                    
                    const rsiWidth = Math.min(Math.max(data.rsi, 0), 100);
                    rsiBar.style.width = `${rsiWidth}%`;
                    
                    // Set RSI bar color
                    let rsiClass = 'neutral';
                    if (data.rsi < CONFIG.OVERSOLD) rsiClass = 'oversold';
                    else if (data.rsi > CONFIG.OVERBOUGHT) rsiClass = 'overbought';
                    rsiBar.className = `rsi-bar ${rsiClass}`;
                }

                // Update signal
                const signalBadge = card.querySelector('.signal-badge');
                const signalStrength = document.getElementById(`strength-${symbol}`);
                
                if (data.signal && signalBadge && signalStrength) {
                    // Update card class
                    card.className = `asset-card ${data.signal.type.toLowerCase()}-signal`;
                    
                    // Update badge
                    signalBadge.className = `signal-badge ${data.signal.type.toLowerCase()}`;
                    signalBadge.textContent = data.signal.type;
                    
                    // Update strength
                    signalStrength.textContent = data.signal.strength;
                    signalStrength.style.color = data.signal.strength === 'STRONG' ? 
                        (data.signal.type === 'BUY' ? 'var(--buy-color)' : 'var(--sell-color)') : 
                        'var(--warning)';
                }

                // Update last update time
                const updateTime = document.getElementById(`update-${symbol}`);
                if (updateTime && data.lastUpdate) {
                    const time = new Date(data.lastUpdate);
                    updateTime.textContent = time.toLocaleTimeString('en-US', {
                        hour12: false,
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit'
                    });
                }

                // Update chart
                this.updateChart(symbol);
            }

            static updateChart(symbol) {
                const data = state.marketData.get(symbol);
                if (!data || !data.candles || data.candles.length < 2) return;

                const chart = state.charts.get(symbol);
                if (!chart || !chart.canvas) return;

                const canvas = chart.canvas;
                const ctx = chart.ctx;
                const candles = data.candles.slice(-20);

                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Set canvas dimensions
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;

                const padding = 20;
                const chartWidth = canvas.width - 2 * padding;
                const chartHeight = canvas.height - 2 * padding;

                // Find price range
                let minPrice = Infinity;
                let maxPrice = -Infinity;
                
                candles.forEach(candle => {
                    minPrice = Math.min(minPrice, candle.low);
                    maxPrice = Math.max(maxPrice, candle.high);
                });

                // Add some padding
                const priceRange = maxPrice - minPrice;
                const paddingPercent = 0.1;
                minPrice -= priceRange * paddingPercent;
                maxPrice += priceRange * paddingPercent;

                // Draw grid
                ctx.strokeStyle = '#334155';
                ctx.lineWidth = 1;
                
                // Vertical grid lines
                for (let i = 0; i <= 5; i++) {
                    const x = padding + (i * chartWidth / 5);
                    ctx.beginPath();
                    ctx.moveTo(x, padding);
                    ctx.lineTo(x, padding + chartHeight);
                    ctx.stroke();
                }

                // Draw candles
                const candleWidth = (chartWidth / candles.length) * 0.7;
                
                candles.forEach((candle, index) => {
                    const x = padding + (index * chartWidth / candles.length) + candleWidth / 2;
                    
                    // Calculate Y positions
                    const openY = padding + chartHeight - ((candle.open - minPrice) / (maxPrice - minPrice) * chartHeight);
                    const closeY = padding + chartHeight - ((candle.close - minPrice) / (maxPrice - minPrice) * chartHeight);
                    const highY = padding + chartHeight - ((candle.high - minPrice) / (maxPrice - minPrice) * chartHeight);
                    const lowY = padding + chartHeight - ((candle.low - minPrice) / (maxPrice - minPrice) * chartHeight);

                    // Determine color
                    const isBullish = candle.close > candle.open;
                    ctx.fillStyle = isBullish ? 'var(--buy-color)' : 'var(--sell-color)';
                    ctx.strokeStyle = isBullish ? 'var(--buy-color)' : 'var(--sell-color)';

                    // Draw wick
                    ctx.beginPath();
                    ctx.moveTo(x, highY);
                    ctx.lineTo(x, lowY);
                    ctx.stroke();

                    // Draw body
                    const bodyTop = Math.min(openY, closeY);
                    const bodyHeight = Math.abs(openY - closeY);
                    
                    if (bodyHeight > 0) {
                        ctx.fillRect(x - candleWidth / 2, bodyTop, candleWidth, bodyHeight);
                    } else {
                        // Draw line for doji
                        ctx.beginPath();
                        ctx.moveTo(x - candleWidth / 2, bodyTop);
                        ctx.lineTo(x + candleWidth / 2, bodyTop);
                        ctx.stroke();
                    }
                });
            }

            static addSignalLog(symbol, signal) {
                const logEntries = document.getElementById('logEntries');
                const symbolInfo = SYMBOL_INFO[symbol];
                
                const logEntry = document.createElement('div');
                logEntry.className = 'log-entry';
                
                const time = new Date().toLocaleTimeString('en-US', {
                    hour12: false,
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                });
                
                logEntry.innerHTML = `
                    <div class="log-time">${time}</div>
                    <div class="log-symbol">${symbol}</div>
                    <div class="log-signal ${signal.type.toLowerCase()}">${signal.type} ${signal.strength}</div>
                    <div class="log-price">${signal.price.toFixed(symbolInfo.decimals)}</div>
                `;
                
                if (logEntries.firstChild) {
                    logEntries.insertBefore(logEntry, logEntries.firstChild);
                } else {
                    logEntries.appendChild(logEntry);
                }
                
                // Keep only last MAX_LOG_ENTRIES
                const entries = logEntries.querySelectorAll('.log-entry');
                if (entries.length > CONFIG.MAX_LOG_ENTRIES) {
                    logEntries.removeChild(entries[entries.length - 1]);
                }
                
                // Add to state log
                state.signalLog.unshift({
                    time: Date.now(),
                    symbol: symbol,
                    signal: signal,
                    price: signal.price
                });
                
                if (state.signalLog.length > CONFIG.MAX_LOG_ENTRIES) {
                    state.signalLog.pop();
                }
            }

            static reanalyzeAll() {
                CONFIG.SYMBOLS.forEach(symbol => {
                    const data = state.marketData.get(symbol);
                    if (data && data.candles && data.candles.length >= CONFIG.RSI_PERIOD + 1) {
                        Analyzer.analyze(symbol);
                        this.updateAssetCard(symbol);
                    }
                });
            }
        }

        // ===================== INITIALIZATION =====================
        document.addEventListener('DOMContentLoaded', () => {
            console.log('üöÄ KILER ZONE Dashboard Initializing...');
            UI.init();
            console.log('‚úÖ Dashboard Ready - Enter your Deriv API token to begin');
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            if (state.connected) {
                CONFIG.SYMBOLS.forEach(symbol => {
                    const chart = state.charts.get(symbol);
                    if (chart && chart.canvas) {
                        UI.updateChart(symbol);
                    }
                });
            }
        });

        // Handle beforeunload to disconnect properly
        window.addEventListener('beforeunload', () => {
            if (state.connected) {
                DerivAPI.disconnect();
            }
        });
    </script>
</body>
</html>
