<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Crossing Indicator — Standalone Dashboard</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#071021; --card:rgba(255,255,255,0.03); --muted:#9aa4b2; --accent:#6EE7B7; --danger:#ff6b6b;
    }
    html,body,#app{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;background:linear-gradient(180deg,#071021 0%, #0f1724 100%);color:#e6eef8}
    .container{max-width:1200px;margin:18px auto;padding:12px;display:grid;grid-template-columns:1fr 360px;gap:16px}
    header{grid-column:1/-1;display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
    .logo{font-weight:700;color:var(--accent);letter-spacing:0.6px}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:12px;box-shadow:0 6px 18px rgba(2,6,23,0.6);border:1px solid rgba(255,255,255,0.03)}
    .scanner{display:grid;grid-template-columns:repeat(2,1fr);gap:10px}
    .pair{display:flex;justify-content:space-between;align-items:center;padding:10px;border-radius:8px;background:var(--card);border:1px solid rgba(255,255,255,0.02)}
    .badge{padding:6px 10px;border-radius:999px;background:rgba(0,0,0,0.35);font-weight:600}
    .badge.buy{background:linear-gradient(90deg,#0ea5a4,#6ee7b7);color:#05282a}
    .badge.wait{background:rgba(255,255,255,0.03);color:var(--muted)}
    .controls{display:flex;gap:8px;align-items:center}
    button{background:var(--card);border:1px solid rgba(255,255,255,0.03);color:var(--accent);padding:8px 12px;border-radius:10px;cursor:pointer}
    button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted)}
    .small{font-size:12px;color:var(--muted)}
    .history{max-height:340px;overflow:auto;padding:8px;display:flex;flex-direction:column;gap:8px}
    .history-item{display:flex;justify-content:space-between;gap:8px;padding:8px;border-radius:8px;background:rgba(255,255,255,0.02);font-size:13px}
    .debug{max-height:220px;overflow:auto;background:rgba(0,0,0,0.25);padding:8px;border-radius:8px;font-family:monospace;font-size:12px}
    label.small{display:flex;align-items:center;gap:8px}
    textarea{background:rgba(0,0,0,0.2);border:1px solid rgba(255,255,255,0.05);border-radius:6px;padding:8px;color:white;font-family:inherit;font-size:12px}
    input[type="number"]{background:rgba(0,0,0,0.2);border:1px solid rgba(255,255,255,0.05);border-radius:6px;padding:6px;color:white;font-family:inherit}
    input[type="checkbox"]{accent-color:var(--accent)}
    @media(max-width:980px){.container{grid-template-columns:1fr;}}
  </style>
</head>
<body>
  <div id="app"></div>

  <script>
    // ----------------------------------------------------
    // Crossing Indicator Standalone Dashboard
    // - 4H main, 1H confirm, Stochastic %K=5 %D=3 slow=3
    // - Deriv WebSocket helper (optional)
    // - History trimmed to 10 before auto-refresh
    // - Debug logging & on-screen debug panel
    // - Input validation & performance optimizations
    // ----------------------------------------------------

    /***********************
     Config & defaults
    ************************/
    const DEFAULT_PAIRS = [
      { id: "EURUSD", apiSymbol: "frxEURUSD", type: "forex" },
      { id: "XAUUSD", apiSymbol: "gold", type: "index" },
      { id: "BTCUSD", apiSymbol: "BTCUSD", type: "crypto" },
      { id: "US30", apiSymbol: "US30", type: "index" },
      { id: "Boom 1000", apiSymbol: null, type: "synthetic" },
      { id: "Crash 1000", apiSymbol: null, type: "synthetic" }
    ];

    const STOCH = { k:5, d:3, slowing:3, high:85, low:15 };
    const AUTO_INTERVAL_DEFAULT = 15000; // 15s
    const HISTORY_LIMIT = 10;

    /***********************
     Application State
    ************************/
    let appState = {
      pairs: [...DEFAULT_PAIRS],
      auto: false,
      intervalMs: AUTO_INTERVAL_DEFAULT,
      history: [],
      isRunning: false,
      debugOn: true,
      consoleLogs: [],
      derivWS: null,
      cache: {},
      timer: null
    };

    /***********************
     Utility & validation
    ************************/
    function isValidPairList(pairs){
      if(!Array.isArray(pairs)) return false;
      return pairs.every(p => p && typeof p.id === 'string' && p.id.length <= 64);
    }
    
    function isPositiveInt(v){ return Number.isInteger(v) && v>0; }

    function logDebug(msg){
      const ts = new Date().toISOString();
      console.log("[Crossing Debug]", ts, msg);
      // maintain on-screen log
      appState.consoleLogs = (appState.consoleLogs || []).slice(-199);
      appState.consoleLogs.unshift(ts + " " + msg);
      renderDebugPanel();
    }

    /***********************
     Deriv WebSocket helper
    ************************/
    class DerivWS {
      constructor(app_id = 1089){
        this.app_id = app_id;
        this.ws = null;
        this.requestId = 1;
        this.pending = new Map();
        this.connected = false;
      }
      
      connect(){
        return new Promise((resolve, reject) => {
          if(this.connected && this.ws) return resolve(this);
          try{
            this.ws = new WebSocket(`wss://ws.binaryws.com/websockets/v3?app_id=${this.app_id}`);
          }catch(err){
            return reject(err);
          }
          this.ws.onopen = () => {
            this.connected = true;
            resolve(this);
          };
          this.ws.onerror = (e) => {
            reject(e);
          };
          this.ws.onmessage = (ev) => {
            try{
              const data = JSON.parse(ev.data);
              if(data.echo_req && data.req_id){
                const id = data.req_id;
                const cb = this.pending.get(id);
                if(cb){
                  cb.resolve(data);
                  this.pending.delete(id);
                }
              } else if(data.req_id){
                const id = data.req_id;
                const cb = this.pending.get(id);
                if(cb){
                  cb.resolve(data);
                  this.pending.delete(id);
                }
              } else {
                if(data.echo_req && data.echo_req.req_id){
                  const id = data.echo_req.req_id;
                  const cb = this.pending.get(id);
                  if(cb){
                    cb.resolve(data);
                    this.pending.delete(id);
                  }
                }
              }
            }catch(err){
              // ignore
            }
          };
        });
      }
      
      send(reqObj, timeoutMs = 7000){
        return new Promise(async (resolve, reject) => {
          try{
            if(!this.ws || this.ws.readyState !== WebSocket.OPEN){
              await this.connect();
            }
            const req_id = (++this.requestId);
            reqObj.req_id = req_id;
            const payload = JSON.stringify(reqObj);
            let settled = false;
            const timer = setTimeout(()=>{
              if(!settled){
                settled = true;
                this.pending.delete(req_id);
                reject(new Error("DerivWS: request timed out"));
              }
            }, timeoutMs);
            this.pending.set(req_id, {
              resolve: (data) => { if(!settled){ settled=true; clearTimeout(timer); resolve(data);} },
              reject: (err) => { if(!settled){ settled=true; clearTimeout(timer); reject(err);} }
            });
            this.ws.send(payload);
          }catch(err){
            reject(err);
          }
        });
      }
      
      async close(){
        try{ if(this.ws) this.ws.close(); }catch(e){}
        this.connected = false;
      }
    }

    /***********************
     Candles & Stochastic
    ************************/
    async function fetchCandlesDerivOrDemo(apiSymbol, timeframeMinutes, count=300, derivWS=null){
      if(!apiSymbol) {
        logDebug(`fetchCandles: no apiSymbol for demo (${timeframeMinutes}m, ${count} bars)`);
        return generateDemoCandles(count, 1000 + Math.random()*500, 0.006, timeframeMinutes);
      }

      try{
        const granularity = timeframeMinutes*60;
        const request = {
          ticks_history: apiSymbol,
          start: 1,
          end: "latest",
          style: "candles",
          granularity: granularity,
          count: count
        };
        const resp = await derivWS.send(request, 8000);
        if(resp && resp.candles && Array.isArray(resp.candles) && resp.candles.length>0){
          const arr = resp.candles.map(c => ({ t: c.epoch*1000, o:+c.open, h:+c.high, l:+c.low, c:+c.close, v:0 }));
          return arr;
        } else if(resp && resp.history && resp.history.candles){
          const arr = resp.history.candles.map(c => ({ t:c.time*1000, o:+c.open, h:+c.high, l:+c.low, c:+c.close, v:0 }));
          return arr;
        } else {
          logDebug(`Deriv returned no candles for ${apiSymbol}, falling back demo`);
          return generateDemoCandles(count, 1000 + Math.random()*500, 0.006, timeframeMinutes);
        }
      }catch(err){
        logDebug(`Deriv fetch failed for ${apiSymbol}: ${err.message || err}`);
        return generateDemoCandles(count, 1000 + Math.random()*500, 0.006, timeframeMinutes);
      }
    }

    function generateDemoCandles(bars=200, startPrice=1000, volatility=0.01, timeframeMinutes=60){
      const out = [];
      let price = startPrice;
      const now = Date.now();
      for(let i = bars-1; i>=0; i--){
        const time = now - i * timeframeMinutes * 60 * 1000;
        const change = (Math.random()*2 -1) * volatility * price;
        const o = price;
        const c = Math.max(0.0001, price + change);
        const h = Math.max(o,c) + Math.abs((Math.random())*volatility*price*0.5);
        const l = Math.min(o,c) - Math.abs((Math.random())*volatility*price*0.5);
        out.push({t:time,o:o,h:h,l:l,c:c,v:Math.random()*10});
        price = c;
      }
      return out;
    }

    function computeStochastic(candles, kPeriod=5, dPeriod=3, slowing=3){
      const n = candles.length;
      const kRaw = new Array(n).fill(null);
      for(let i=0;i<n;i++){
        if(i - (kPeriod -1) < 0){ kRaw[i] = null; continue; }
        let low = Infinity, high = -Infinity;
        for(let j=i-(kPeriod-1); j<=i; j++){ low = Math.min(low, candles[j].l); high = Math.max(high, candles[j].h); }
        const close = candles[i].c;
        kRaw[i] = (high - low) === 0 ? 50 : ((close - low) / (high - low)) * 100;
      }
      const sma = (arr, idx, len) => {
        if(idx - (len-1) < 0) return null;
        let sum=0,cnt=0;
        for(let i=idx-(len-1); i<=idx; i++){ if(arr[i] !== null){ sum+=arr[i]; cnt++; } }
        return cnt===0 ? null : sum/cnt;
      };
      const kSmoothed = new Array(n).fill(null);
      for(let i=0;i<n;i++) kSmoothed[i] = sma(kRaw, i, slowing);
      const dLine = new Array(n).fill(null);
      for(let i=0;i<n;i++) dLine[i] = sma(kSmoothed, i, dPeriod);
      return { kSmoothed, dLine };
    }

    /***********************
     Signal detection
    ************************/
    function detectSignalSingle(candles){
      const n = candles.length;
      if(n < Math.max(STOCH.k, STOCH.d, STOCH.slowing) + 2) {
        logDebug("Not enough bars for stochastic");
        return { signal:null, reason: "InsufficientBars", k:null, d:null, passed:[] , failed:[] };
      }
      const st = computeStochastic(candles, STOCH.k, STOCH.d, STOCH.slowing);
      const i = n-1;
      const kNow = st.kSmoothed[i];
      const dNow = st.dLine[i];
      const kPrev = st.kSmoothed[i-1];
      const dPrev = st.dLine[i-1];
      const reasonsPassed = [];
      const reasonsFailed = [];

      if(kNow === null || dNow === null) {
        reasonsFailed.push("NullLines");
        return { signal:null, reason:"NullLines", k:kNow, d:dNow, passed:reasonsPassed, failed:reasonsFailed };
      }

      // Rule A: touched below low (15) in recent window AND now K rising
      let touchedBelow = false;
      for(let j = Math.max(0, n-20); j < n; j++){
        if(st.kSmoothed[j] !== null && st.dLine[j] !== null && st.kSmoothed[j] <= STOCH.low && st.dLine[j] <= STOCH.low){
          touchedBelow = true; break;
        }
      }
      if(touchedBelow) reasonsPassed.push("TouchedBelow");
      else reasonsFailed.push("TouchedBelow");

      const nowRising = (kPrev !== null && kNow > kPrev);
      if(nowRising) reasonsPassed.push("NowRising"); else reasonsFailed.push("NowRising");

      if(touchedBelow && nowRising){
        logDebug(`Signal Rule A passed (TouchedBelow + NowRising). k:${kNow.toFixed(2)} d:${dNow.toFixed(2)}`);
        return { signal:"BUY", reason:"TouchedBelowThenRising", k:kNow, d:dNow, passed:reasonsPassed, failed:reasonsFailed };
      }

      // Rule B: crossover up while both < 50
      if(kPrev !== null && dPrev !== null && kPrev <= dPrev && kNow > dNow && kNow < 50 && dNow < 50){
        reasonsPassed.push("CrossUpBelow50");
        logDebug(`Signal Rule B passed (CrossUpBelow50). k:${kNow.toFixed(2)} d:${dNow.toFixed(2)}`);
        return { signal:"BUY", reason:"CrossUpBelow50", k:kNow, d:dNow, passed:reasonsPassed, failed:reasonsFailed };
      } else {
        reasonsFailed.push("CrossUpBelow50");
      }

      return { signal:null, reason:"NoRule", k:kNow, d:dNow, passed:reasonsPassed, failed:reasonsFailed };
    }

    /***********************
     Trade execution (simulated)
    ************************/
    async function attemptTradeExecute(pairId, side){
      try{
        logDebug(`Trade attempt: ${pairId} ${side} — (SIMULATED)`);
        const success = Math.random() > 0.15;
        await new Promise(r=>setTimeout(r, 300 + Math.random()*200));
        if(success){
          logDebug(`Trade executed SUCCESS for ${pairId}`);
          return { success:true, id: "SIM-"+Date.now() };
        } else {
          logDebug(`Trade executed FAILED for ${pairId}`);
          return { success:false, error:"simulated-reject" };
        }
      }catch(err){
        logDebug(`Trade execution exception for ${pairId}: ${err.message||err}`);
        return { success:false, error:err.message || err };
      }
    }

    /***********************
     Core scanning logic
    ************************/
    async function startScan(){
      if(appState.isRunning) {
        logDebug("Scan already running — skipping concurrent start");
        return;
      }
      appState.isRunning = true;
      logDebug("Scanner: Starting scan pass");

      const derivWS = appState.derivWS;
      const fetchTasks = [];
      const concurrencyLimit = 4;
      const pairChunks = [];
      for(let i=0;i<appState.pairs.length;i+=concurrencyLimit) pairChunks.push(appState.pairs.slice(i, i+concurrencyLimit));

      for(const chunk of pairChunks){
        const promises = chunk.map(async pair => {
          try{
            const cacheKey4h = pair.id + "|4h";
            const cacheKey1h = pair.id + "|1h";
            const nowTs = Date.now();
            let candles4h = null, candles1h = null;
            
            if(appState.cache[cacheKey4h] && (nowTs - appState.cache[cacheKey4h].ts < 15*1000)){
              candles4h = appState.cache[cacheKey4h].value;
              logDebug(`Cache hit 4H for ${pair.id}`);
            } else {
              candles4h = await fetchCandlesDerivOrDemo(pair.apiSymbol, 240, 300, derivWS);
              appState.cache[cacheKey4h] = { value:candles4h, ts:Date.now() };
            }
            
            if(appState.cache[cacheKey1h] && (nowTs - appState.cache[cacheKey1h].ts < 15*1000)){
              candles1h = appState.cache[cacheKey1h].value;
              logDebug(`Cache hit 1H for ${pair.id}`);
            } else {
              candles1h = await fetchCandlesDerivOrDemo(pair.apiSymbol, 60, 300, derivWS);
              appState.cache[cacheKey1h] = { value:candles1h, ts:Date.now() };
            }

            const sig4 = detectSignalSingle(candles4h);
            const sig1 = detectSignalSingle(candles1h);

            logDebug(`Eval ${pair.id} 4H: ${sig4.signal||'NO'} (${sig4.reason}) 1H: ${sig1.signal||'NO'} (${sig1.reason})`);

            // Session enforcement for EURUSD & XAUUSD
            const enforceSessions = true;
            if(enforceSessions && (pair.id === 'EURUSD' || pair.id === 'XAUUSD')){
              const s = sessionForNowUTC();
              if(!(s === 'London' || s === 'NY')){
                logDebug(`${pair.id}: out of allowed sessions (${s}) — skipping`);
                return { pair, result:null };
              }
            }

            // Confirm: both must be BUY
            if(sig4.signal === 'BUY' && sig1.signal === 'BUY'){
              logDebug(`Entry signal detected for ${pair.id} (4H + 1H). Preparing trade attempt`);
              const exec = await attemptTradeExecute(pair.id, "BUY");
              const entry = {
                time: new Date().toISOString(),
                pair: pair.id,
                action: "BUY",
                exec,
                reason: `${sig4.reason} / ${sig1.reason}`,
                k4: sig4.k, d4: sig4.d, k1: sig1.k, d1: sig1.d
              };
              
              appState.history = [entry, ...appState.history].slice(0, HISTORY_LIMIT);
              renderHistory();
              return { pair, result: entry };
            } else {
              return { pair, result: null, debug: { sig4, sig1 } };
            }
          }catch(err){
            logDebug(`Error fetching/evaluating ${pair.id}: ${err.message || err}`);
            return { pair, result:null };
          }
        });
        
        const chunkResults = await Promise.all(promises);
        fetchTasks.push(...chunkResults);
      }

      appState.history = appState.history.slice(0, HISTORY_LIMIT);
      renderHistory();
      
      logDebug("Scanner: Scan pass complete");
      appState.isRunning = false;
      return;
    }

    /***********************
     Session detection
    ************************/
    function isLondonUTC(d){ const h = d.getUTCHours(); return h >=7 && h < 16;}
    function isNewYorkUTC(d){ const h = d.getUTCHours(); return h >=12 && h < 21; }
    function sessionForNowUTC(){ const d = new Date(); if(isNewYorkUTC(d)) return "NY"; if(isLondonUTC(d)) return "London"; return "Closed"; }

    /***********************
     UI Rendering Functions
    ************************/
    function renderHeader() {
      return `
        <header>
          <div>
            <div class="logo">Crossing Dashboard (Standalone)</div>
            <div class="small">Stochastic %K=5 %D=3 slow=3 · 4H main + 1H confirm · History up to ${HISTORY_LIMIT}</div>
          </div>
          <div class="controls">
            <div class="card small" style="padding:8px 12px; display:flex;align-items:center; gap:8px">
              <div style="width:10px;height:10px;border-radius:50%;background: ${sessionForNowUTC() === 'Closed' ? '#333' : '#6ee7b7'}"></div>
              <div>Session: ${sessionForNowUTC()}</div>
            </div>
            <button onclick="manualRefresh()">Refresh</button>
            <button class="secondary" onclick="toggleAuto()">${appState.auto ? "Auto ON" : "Auto OFF"}</button>
            <button class="secondary" onclick="clearHistory()">Clear History</button>
          </div>
        </header>
      `;
    }

    function renderScanner() {
      return `
        <div class="card">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
            <div style="font-weight:700">Scanner</div>
            <div class="small">${appState.pairs.length} pairs</div>
          </div>
          <div class="scanner">
            ${appState.pairs.map(p => `
              <div class="pair">
                <div>
                  <div style="font-weight:600">${p.id}</div>
                  <div class="small">TF: 4H / 1H · ${p.type}</div>
                </div>
                <div style="text-align:right">
                  <div class="badge wait" style="min-width:80px;text-align:center">WAIT</div>
                  <div style="height:6px"></div>
                  <div class="small">apiSymbol: ${p.apiSymbol||'—'}</div>
                </div>
              </div>
            `).join('')}
          </div>
        </div>
      `;
    }

    function renderHistory() {
      const historyElement = document.getElementById('history-content');
      if (historyElement) {
        historyElement.innerHTML = appState.history.length === 0 
          ? '<div class="small">No signals yet.</div>'
          : appState.history.map(h => `
              <div class="history-item">
                <div>
                  <strong>${h.pair}</strong>
                  <div class="small">${h.reason}</div>
                  <div class="small">${new Date(h.time).toLocaleString()}</div>
                </div>
                <div style="text-align:right">
                  <div style="font-weight:700;color:#05282a;background:linear-gradient(90deg,#0ea5a4,#6ee7b7);padding:6px 10px;border-radius:8px">${h.action}</div>
                  <div class="small">${h.exec && h.exec.success ? 'exec:ok' : 'exec:fail'}</div>
                </div>
              </div>
            `).join('');
      }
    }

    function renderDebugPanel() {
      const debugElement = document.getElementById('debug-content');
      if (debugElement && appState.debugOn) {
        const debugLines = (appState.consoleLogs || []).slice(0, 200);
        debugElement.innerHTML = debugLines.length === 0 
          ? '<div class="small">No debug logs yet</div>' 
          : debugLines.map(l => `<div>${l}</div>`).join('');
      }
    }

    function renderSettings() {
      return `
        <div>
          <div style="font-weight:700">Settings</div>
          <div class="small" style="margin-top:6px">Refine params & pairs (one per line: ID|apiSymbol|type )</div>
          <textarea id="pairsTextarea" rows="6" style="width:100%;margin-top:8px">${appState.pairs.map(p=> `${p.id}|${p.apiSymbol||''}|${p.type}`).join("\n")}</textarea>
          <div style="display:flex;gap:8px;margin-top:8px">
            <button onclick="applyPairs()">Apply Pairs</button>
            <button class="secondary" onclick="resetPairs()">Reset</button>
          </div>
          <div style="display:flex;gap:8px;margin-top:8px;align-items:center">
            <label class="small">Auto-interval (ms)</label>
            <input type="number" id="intervalInput" value="${appState.intervalMs}" style="width:120px">
          </div>
          <div style="display:flex;gap:8px;margin-top:8px;align-items:center">
            <label class="small"><input type="checkbox" id="autoCheckbox" ${appState.auto ? 'checked' : ''}> Auto-refresh</label>
            <label class="small"><input type="checkbox" id="debugCheckbox" ${appState.debugOn ? 'checked' : ''}> Debug</label>
          </div>
        </div>
      `;
    }

    function renderActions() {
      return `
        <div>
          <div style="font-weight:700">Actions</div>
          <div style="display:flex;gap:8px;margin-top:8px">
            <button onclick="manualScan()">Run Scan Now</button>
            <button class="secondary" onclick="clearHistory()">Clear History</button>
            <button class="secondary" onclick="connectDeriv()">Connect Deriv</button>
          </div>
          <div style="margin-top:10px" class="small">Note: For real Deriv connectivity, ensure symbol names match Deriv's API format and the account permissions allow ticks_history calls.</div>
        </div>
      `;
    }

    function renderApp() {
      document.getElementById('app').innerHTML = `
        <div class="container">
          ${renderHeader()}
          
          <main style="grid-column:1/2">
            ${renderScanner()}
            
            <div class="card" style="margin-top:12px">
              <div style="display:flex;justify-content:space-between;align-items:center">
                <div style="font-weight:700">Signal Notifications</div>
                <div class="small">Only shows when 4H + 1H confirm</div>
              </div>
              <div id="history-content" style="margin-top:8px">
                ${appState.history.length === 0 ? '<div class="small">No signals yet.</div>' : ''}
              </div>
            </div>
          </main>

          <aside class="card" style="display:flex;flex-direction:column;gap:12px">
            ${renderSettings()}
            
            <div>
              <div style="font-weight:700">Debug Panel</div>
              <div class="small" style="margin-top:6px">On-screen logs (latest first)</div>
              <div class="debug" style="margin-top:8px">
                <div id="debug-content"></div>
              </div>
            </div>
            
            ${renderActions()}
          </aside>
        </div>
      `;
      
      renderHistory();
      renderDebugPanel();
      
      // Add event listeners for checkboxes and input
      const autoCheckbox = document.getElementById('autoCheckbox');
      const debugCheckbox = document.getElementById('debugCheckbox');
      const intervalInput = document.getElementById('intervalInput');
      
      if (autoCheckbox) {
        autoCheckbox.addEventListener('change', (e) => {
          appState.auto = e.target.checked;
          updateAutoRefresh();
        });
      }
      
      if (debugCheckbox) {
        debugCheckbox.addEventListener('change', (e) => {
          appState.debugOn = e.target.checked;
          renderDebugPanel();
        });
      }
      
      if (intervalInput) {
        intervalInput.addEventListener('change', (e) => {
          const v = parseInt(e.target.value || '0', 10);
          if (isPositiveInt(v)) {
            appState.intervalMs = v;
            updateAutoRefresh();
          } else {
            alert("Interval must be positive integer ms");
          }
        });
      }
    }

    /***********************
     UI Event Handlers
    ************************/
    function handlePairsUpdate(rawText){
      const lines = rawText.split("\n").map(l => l.trim()).filter(Boolean);
      const newPairs = [];
      for(const ln of lines){
        const parts = ln.split("|").map(p=>p.trim());
        if(parts.length === 1){
          newPairs.push({ id: parts[0], apiSymbol: null, type: "synthetic" });
        } else {
          newPairs.push({ id: parts[0], apiSymbol: parts[1] || null, type: parts[2] || "forex" });
        }
      }
      if(isValidPairList(newPairs)){
        appState.pairs = newPairs;
        logDebug(`Pairs updated: ${newPairs.map(p=>p.id).join(",")}`);
        renderApp();
      } else {
        alert("Invalid pairs list. Each line must present a pair name. Format per-line: ID|apiSymbol|type (apiSymbol optional).");
      }
    }

    function applyPairs() {
      const txt = document.getElementById('pairsTextarea').value;
      handlePairsUpdate(txt);
    }

    function resetPairs() {
      document.getElementById('pairsTextarea').value = DEFAULT_PAIRS.map(p=> `${p.id}|${p.apiSymbol||''}|${p.type}`).join("\n");
      handlePairsUpdate(document.getElementById('pairsTextarea').value);
    }

    function toggleAuto() {
      appState.auto = !appState.auto;
      updateAutoRefresh();
      renderApp();
    }

    function updateAutoRefresh() {
      if (appState.timer) clearInterval(appState.timer);
      
      if (appState.auto) {
        appState.timer = setInterval(() => startScan(), appState.intervalMs || AUTO_INTERVAL_DEFAULT);
      }
    }

    function manualRefresh() {
      startScan();
    }

    function manualScan() {
      startScan();
      logDebug("Manual scan triggered by user");
    }

    function clearHistory() {
      appState.history = [];
      renderHistory();
      logDebug("History cleared by user");
    }

    function connectDeriv() {
      if (appState.derivWS) {
        appState.derivWS.connect()
          .then(() => logDebug("DerivWS reconnect attempted"))
          .catch(e => logDebug("Deriv reconnect failed: " + e));
      }
    }

    /***********************
     Application Initialization
    ************************/
    function initApp() {
      logDebug("OnInit: App initializing");
      
      // Initialize Deriv WS connection
      appState.derivWS = new DerivWS(1089);
      appState.derivWS.connect()
        .then(() => logDebug("DerivWS connected"))
        .catch(err => logDebug("DerivWS connect failed: " + (err.message||err)));
      
      // Run initial scan
      startScan();
      
      // Render the application
      renderApp();
    }

    // Start the application when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initApp);
    } else {
      initApp();
    }
  </script>
</body>
</html>
