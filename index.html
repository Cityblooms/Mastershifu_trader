<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>AI SMC Multi-Asset Dashboard</title>
<script src="https://unpkg.com/lightweight-charts@4.0.1/dist/lightweight-charts.standalone.production.js"></script>
<style>
body{font-family:'Poppins',sans-serif;background:#0b0b10;color:#eee;margin:0;padding:0;display:flex;flex-direction:column;align-items:center}
header{background:#111827;width:100%;padding:10px 20px;text-align:center;font-size:1.3em;box-shadow:0 2px 5px rgba(0,0,0,.4)}
.controls{margin:15px 0;display:flex;gap:10px;flex-wrap:wrap;justify-content:center}
select,button,input[type=checkbox]{background:#1f2937;color:#fff;border:none;padding:10px 16px;border-radius:10px;cursor:pointer;font-weight:600;transition:.3s}
button:hover,select:hover{background:#4f46e5}
#chart{width:95%;height:400px;margin-top:10px;border-radius:10px}
#signalLog{width:95%;margin-top:20px;background:#1e1e2e;border-radius:10px;padding:10px;max-height:250px;overflow-y:auto}
.signal-card{background:#26263a;margin:5px 0;padding:10px;border-left:5px solid #6366f1;border-radius:8px;font-size:.9em}
.buy{border-left-color:#22c55e}.sell{border-left-color:#ef4444}
label{display:flex;align-items:center;gap:6px;font-size:.9em}
.status-container{display:flex;gap:15px;margin:10px 0;flex-wrap:wrap;justify-content:center}
.status-item{padding:8px 15px;background:#1f2937;border-radius:8px;font-size:0.9em}
.connected{color:#22c55e}.disconnected{color:#ef4444}.connecting{color:#f59e0b}
.loading{display:none;color:#f59e0b}
.time-display{font-size:0.9em;color:#888;margin:5px 0}
.conditions{background:#1a1a2e;padding:10px;border-radius:8px;margin:10px 0;font-size:0.8em}
.condition-met{color:#22c55e}
.condition-failed{color:#ef4444}
.current-signal{font-size:1.2em;font-weight:bold;padding:10px;border-radius:8px;margin:10px 0;text-align:center}
.signal-buy{background:#1a2e1a;color:#22c55e;border:2px solid #22c55e}
.signal-sell{background:#2e1a1a;color:#ef4444;border:2px solid #ef4444}
.signal-none{background:#1a1a2e;color:#888;border:2px solid #6366f1}
.sync-status{font-size:0.8em;color:#f59e0b;margin:5px 0}
</style>
</head>
<body>
<header>AI SMC Multi-Asset Dashboard</header>

<div class="controls">
  <select id="pairSelect">
    <optgroup label="Forex Major">
      <option value="EURUSD">EUR/USD</option>
      <option value="GBPUSD">GBP/USD</option>
      <option value="USDJPY">USD/JPY</option>
      <option value="AUDUSD">AUD/USD</option>
      <option value="USDCAD">USD/CAD</option>
      <option value="NZDUSD">NZD/USD</option>
      <option value="EURGBP">EUR/GBP</option>
      <option value="EURJPY">EUR/JPY</option>
    </optgroup>
    <optgroup label="Commodities & Crypto">
      <option value="XAUUSD">Gold (XAU/USD)</option>
      <option value="BTCUSD">Bitcoin (BTC/USD)</option>
    </optgroup>
    <optgroup label="Volatility Indices">
      <option value="Volatility 10 Index">Volatility 10 Index</option>
      <option value="Volatility 25 Index">Volatility 25 Index</option>
      <option value="Volatility 50 Index">Volatility 50 Index</option>
      <option value="Volatility 75 Index">Volatility 75 Index</option>
      <option value="Volatility 100 Index">Volatility 100 Index</option>
    </optgroup>
    <optgroup label="Boom & Crash Indices">
      <option value="Boom 1000 Index">Boom 1000 Index</option>
      <option value="Boom 500 Index">Boom 500 Index</option>
      <option value="Crash 1000 Index">Crash 1000 Index</option>
      <option value="Crash 500 Index">Crash 500 Index</option>
    </optgroup>
    <optgroup label="Step & Jump Indices">
      <option value="Step Index">Step Index</option>
      <option value="Jump 10 Index">Jump 10 Index</option>
      <option value="Jump 25 Index">Jump 25 Index</option>
      <option value="Jump 50 Index">Jump 50 Index</option>
      <option value="Jump 75 Index">Jump 75 Index</option>
      <option value="Jump 100 Index">Jump 100 Index</option>
    </optgroup>
  </select>
  <button id="connectFeed">üîå Connect Live Feed</button>
  <button id="disconnectFeed">üîå Disconnect</button>
  <button id="generateSignal">‚ö° Manual SMC Signal</button>
  <label><input type="checkbox" id="autoMode" checked> Auto Signal Mode</label>
  <label><input type="checkbox" id="filterMode" checked> EMA + RSI Filter</label>
  <button id="clearSignals">üßπ Clear</button>
</div>

<div class="status-container">
  <div>Status: <span id="connectionStatus" class="disconnected">Disconnected</span></div>
  <div>5m Feed: <span id="feed5mStatus" class="disconnected">‚ùå</span></div>
  <div>15m Feed: <span id="feed15mStatus" class="disconnected">‚ùå</span></div>
  <div class="loading" id="loadingIndicator">üîÑ Loading Historical Data...</div>
</div>

<div class="time-display">
  System Time: <span id="systemTime">-</span> | 
  Chart Time: <span id="chartTime">-</span> |
  Next Candle: <span id="nextCandleTime">-</span>
</div>

<div class="sync-status" id="syncStatus">üîÑ Synchronizing timeframes...</div>

<div id="currentSignal" class="current-signal signal-none">
  üü° NO CURRENT SIGNAL - Waiting for perfect conditions...
</div>

<div class="conditions">
  <strong>Signal Conditions:</strong>
  <div id="conditionStatus">Waiting for data...</div>
</div>

<div id="chart"></div>
<h3>üìä Recent Signals <span id="signalCount">(0)</span></h3>
<div id="signalLog"></div>

<script>
// --- Global State ---
const state = {
  ws: null,
  wsHTF: null,
  pair: "EURUSD",
  candles: [],
  candlesHTF: [],
  ema: [],
  emaHTF: [],
  rsi: [],
  rsiHTF: [],
  auto: true,
  filter: true,
  lastSignalTime: 0,
  series: null,
  emaSeries: null,
  signals: [],
  reconnectAttempts: 0,
  maxReconnectAttempts: 5,
  currentTime: Math.floor(Date.now() / 1000),
  lastCandleTime: null,
  liveUpdateInterval: null,
  currentBias: null,
  timeSyncInterval: null
};

// --- Chart setup ---
const chart = LightweightCharts.createChart(document.getElementById('chart'), {
  layout: { background: { color: "#0b0b10" }, textColor: "#DDD" },
  grid: { vertLines: { color: "#1e1e2e" }, horzLines: { color: "#1e1e2e" } },
  timeScale: { 
    timeVisible: true, 
    secondsVisible: false,
    rightOffset: 12,
    barSpacing: 6,
    minBarSpacing: 0.5
  },
  crosshair: {
    mode: LightweightCharts.CrosshairMode.Normal,
  }
});
state.series = chart.addCandlestickSeries();
state.emaSeries = chart.addLineSeries({ color: '#f59e0b', lineWidth: 2 });

// --- Asset Properties ---
const assetProperties = {
  // Forex Pairs
  "EURUSD": { basePrice: 1.0800, volatility: 0.0008, trendStrength: 0.0001, decimals: 5 },
  "GBPUSD": { basePrice: 1.2600, volatility: 0.0010, trendStrength: 0.0001, decimals: 5 },
  "USDJPY": { basePrice: 148.50, volatility: 0.0080, trendStrength: 0.0005, decimals: 3 },
  "AUDUSD": { basePrice: 0.6550, volatility: 0.0012, trendStrength: 0.0001, decimals: 5 },
  "USDCAD": { basePrice: 1.3500, volatility: 0.0010, trendStrength: 0.0001, decimals: 5 },
  "NZDUSD": { basePrice: 0.6100, volatility: 0.0012, trendStrength: 0.0001, decimals: 5 },
  "EURGBP": { basePrice: 0.8570, volatility: 0.0006, trendStrength: 0.00005, decimals: 5 },
  "EURJPY": { basePrice: 160.00, volatility: 0.0090, trendStrength: 0.0005, decimals: 3 },
  
  // Commodities & Crypto
  "XAUUSD": { basePrice: 1980.00, volatility: 0.005, trendStrength: 0.002, decimals: 2 },
  "BTCUSD": { basePrice: 43000.00, volatility: 0.015, trendStrength: 0.005, decimals: 2 },
  
  // Volatility Indices
  "Volatility 10 Index": { basePrice: 10000, volatility: 0.08, trendStrength: 0.1, decimals: 2 },
  "Volatility 25 Index": { basePrice: 10000, volatility: 0.12, trendStrength: 0.15, decimals: 2 },
  "Volatility 50 Index": { basePrice: 10000, volatility: 0.18, trendStrength: 0.2, decimals: 2 },
  "Volatility 75 Index": { basePrice: 10000, volatility: 0.25, trendStrength: 0.25, decimals: 2 },
  "Volatility 100 Index": { basePrice: 10000, volatility: 0.35, trendStrength: 0.3, decimals: 2 },
  
  // Boom & Crash Indices
  "Boom 1000 Index": { basePrice: 1000, volatility: 0.05, trendStrength: 0.4, decimals: 2 },
  "Boom 500 Index": { basePrice: 500, volatility: 0.06, trendStrength: 0.35, decimals: 2 },
  "Crash 1000 Index": { basePrice: 1000, volatility: 0.05, trendStrength: -0.4, decimals: 2 },
  "Crash 500 Index": { basePrice: 500, volatility: 0.06, trendStrength: -0.35, decimals: 2 },
  
  // Step & Jump Indices
  "Step Index": { basePrice: 10000, volatility: 0.02, trendStrength: 0.1, decimals: 2 },
  "Jump 10 Index": { basePrice: 10000, volatility: 0.15, trendStrength: 0.1, decimals: 2 },
  "Jump 25 Index": { basePrice: 10000, volatility: 0.2, trendStrength: 0.15, decimals: 2 },
  "Jump 50 Index": { basePrice: 10000, volatility: 0.25, trendStrength: 0.2, decimals: 2 },
  "Jump 75 Index": { basePrice: 10000, volatility: 0.3, trendStrength: 0.25, decimals: 2 },
  "Jump 100 Index": { basePrice: 10000, volatility: 0.4, trendStrength: 0.3, decimals: 2 }
};

// --- Time Synchronization Functions ---
function getCurrentCandleTime(timeframe = 5) {
  const now = Math.floor(Date.now() / 1000);
  const alignedTime = now - (now % (timeframe * 60));
  return alignedTime;
}

function updateTimeDisplay() {
  const now = new Date();
  document.getElementById('systemTime').textContent = now.toLocaleTimeString();
  
  if (state.candles.length > 0) {
    const lastCandleTime = new Date(state.candles[state.candles.length - 1].time * 1000);
    document.getElementById('chartTime').textContent = lastCandleTime.toLocaleTimeString();
    
    const nextCandleTime = new Date((state.candles[state.candles.length - 1].time + 300) * 1000);
    document.getElementById('nextCandleTime').textContent = nextCandleTime.toLocaleTimeString();
    
    // Check sync status
    const timeDiff = Math.abs(now.getTime() - lastCandleTime.getTime());
    const syncElement = document.getElementById('syncStatus');
    if (timeDiff < 10000) { // 10 seconds tolerance
      syncElement.textContent = '‚úÖ Timeframes synchronized';
      syncElement.style.color = '#22c55e';
    } else {
      syncElement.textContent = '‚ö†Ô∏è Timeframes slightly out of sync';
      syncElement.style.color = '#f59e0b';
    }
  }
}

// --- Update Current Signal Display ---
function updateCurrentSignal(bias, confidence) {
  const signalElement = document.getElementById('currentSignal');
  
  if (bias === 'BUY') {
    signalElement.className = 'current-signal signal-buy';
    signalElement.innerHTML = `üéØ BUY SIGNAL ACTIVE | Confidence: ${confidence}% | ${state.pair}`;
  } else if (bias === 'SELL') {
    signalElement.className = 'current-signal signal-sell';
    signalElement.innerHTML = `üéØ SELL SIGNAL ACTIVE | Confidence: ${confidence}% | ${state.pair}`;
  } else {
    signalElement.className = 'current-signal signal-none';
    signalElement.innerHTML = `üü° NO CURRENT SIGNAL - Waiting for perfect conditions...`;
  }
}

// --- Update Condition Display ---
function updateConditionStatus(conditions) {
  const conditionElement = document.getElementById('conditionStatus');
  let html = '';
  
  conditions.forEach(condition => {
    const statusClass = condition.met ? 'condition-met' : 'condition-failed';
    const icon = condition.met ? '‚úÖ' : '‚ùå';
    html += `<div class="${statusClass}">${icon} ${condition.name}</div>`;
  });
  
  conditionElement.innerHTML = html;
}

// --- EMA Calculation ---
function calcEMA(values, period) {
  if (!values || values.length < period) return [];
  try {
    let k = 2 / (period + 1);
    let ema = [values[0]];
    for (let i = 1; i < values.length; i++) {
      ema.push(values[i] * k + ema[i - 1] * (1 - k));
    }
    return ema;
  } catch (error) {
    console.error('EMA calculation error:', error);
    return [];
  }
}

// --- Fixed RSI Calculation ---
function calcRSI(values, period = 14) {
  if (!values || values.length <= period) return [];
  
  try {
    let gains = 0;
    let losses = 0;

    for (let i = 1; i <= period; i++) {
      const diff = values[i] - values[i - 1];
      gains += Math.max(diff, 0);
      losses += Math.max(-diff, 0);
    }

    let avgGain = gains / period;
    let avgLoss = losses / period;
    const rsi = new Array(period).fill(null);

    for (let i = period + 1; i < values.length; i++) {
      const diff = values[i] - values[i - 1];
      const currentGain = Math.max(diff, 0);
      const currentLoss = Math.max(-diff, 0);

      avgGain = (avgGain * (period - 1) + currentGain) / period;
      avgLoss = (avgLoss * (period - 1) + currentLoss) / period;

      if (avgLoss === 0) {
        rsi.push(100);
      } else {
        const rs = avgGain / avgLoss;
        rsi.push(100 - (100 / (1 + rs)));
      }
    }
    return rsi;
  } catch (error) {
    console.error('RSI calculation error:', error);
    return [];
  }
}

// --- Add signal ---
function addSignal(sig) {
  try {
    const div = document.createElement('div');
    div.className = `signal-card ${sig.bias.toLowerCase()}`;
    
    const properties = assetProperties[state.pair] || { decimals: 2 };
    const decimals = properties.decimals;
    
    div.innerHTML = `<b>${sig.pair}</b> | <b>${sig.bias}</b> | Entry ${sig.entry.toFixed(decimals)} TP ${sig.tp.toFixed(decimals)} SL ${sig.sl.toFixed(decimals)}<br>
      Reason: ${sig.reason}<br>Conf: ${sig.confidence}% | ${sig.time}`;
    document.getElementById('signalLog').prepend(div);
    
    document.getElementById('signalCount').textContent = `(${state.signals.length})`;
    
    // Update current signal display
    updateCurrentSignal(sig.bias, sig.confidence);
    
    const markers = [{
      time: state.candles[state.candles.length - 1].time,
      position: sig.bias === 'BUY' ? 'belowBar' : 'aboveBar',
      color: sig.bias === 'BUY' ? '#22c55e' : '#ef4444',
      shape: sig.bias === 'BUY' ? 'arrowUp' : 'arrowDown',
      text: sig.bias
    }];
    
    state.series.setMarkers(markers);
    
    console.log(`üéØ SIGNAL GENERATED: ${sig.bias} at ${sig.time}`);
  } catch (error) {
    console.error('Error adding signal:', error);
  }
}

// --- STRICT SMC Signal Detection for All Assets ---
function detectSMC() {
  try {
    // Check minimum data requirements
    if (!state.candles || state.candles.length < 35 || !state.candlesHTF || state.candlesHTF.length < 15) {
      console.log('‚ùå Insufficient data for SMC detection');
      updateConditionStatus([{ name: 'Minimum data (35 candles 5m, 15 candles 15m)', met: false }]);
      updateCurrentSignal(null, 0);
      return;
    }

    const conditions = [];
    let allConditionsMet = true;

    // Get current market data
    const last20 = state.candles.slice(-20);
    const currentClose = last20[last20.length - 1].close;
    const currentHigh = last20[last20.length - 1].high;
    const currentLow = last20[last20.length - 1].low;

    // Condition 1: Sufficient volatility
    const recentHigh = Math.max(...last20.slice(-10).map(c => c.high));
    const recentLow = Math.min(...last20.slice(-10).map(c => c.low));
    const volatility = (recentHigh - recentLow) / recentLow;
    
    const properties = assetProperties[state.pair] || { volatility: 0.01 };
    const minVolatility = state.pair.includes('Volatility') ? 0.003 : 0.001;
    const hasVolatility = volatility > minVolatility;
    
    conditions.push({ name: `Minimum volatility (${(minVolatility*100).toFixed(2)}%): ${(volatility * 100).toFixed(2)}%`, met: hasVolatility });
    if (!hasVolatility) allConditionsMet = false;

    // Condition 2: Clear market structure
    const highs = last20.map(c => c.high);
    const lows = last20.map(c => c.low);
    
    // Identify swing points
    const swingHighs = [];
    const swingLows = [];
    
    for (let i = 1; i < highs.length - 1; i++) {
      if (highs[i] > highs[i-1] && highs[i] > highs[i+1]) {
        swingHighs.push(highs[i]);
      }
      if (lows[i] < lows[i-1] && lows[i] < lows[i+1]) {
        swingLows.push(lows[i]);
      }
    }

    const hasMarketStructure = swingHighs.length >= 1 && swingLows.length >= 1;
    conditions.push({ name: `Market structure (min 1 swing)`, met: hasMarketStructure });
    if (!hasMarketStructure) allConditionsMet = false;

    // Condition 3: Multi-timeframe alignment
    const lastHTF = state.candlesHTF.slice(-5);
    const closesHTF = lastHTF.map(c => c.close);
    const dirHTF = closesHTF[closesHTF.length - 1] > closesHTF[0] ? 'BUY' : 'SELL';
    
    // Determine 5m direction based on recent price action
    const recent5m = last20.slice(-5);
    const dir5m = recent5m[recent5m.length - 1].close > recent5m[0].close ? 'BUY' : 'SELL';
    
    const timeframeAligned = dir5m === dirHTF;
    conditions.push({ name: `Multi-timeframe alignment (5m: ${dir5m}, 15m: ${dirHTF})`, met: timeframeAligned });
    if (!timeframeAligned) allConditionsMet = false;

    // Condition 4: EMA alignment (if filter enabled)
    let emaConditionsMet = true;
    if (state.filter) {
      const emaNow = state.ema[state.ema.length - 1];
      const emaHTFNow = state.emaHTF[state.emaHTF.length - 1];
      const rsiNow = state.rsi[state.rsi.length - 1];
      const rsiHTFNow = state.rsiHTF[state.rsiHTF.length - 1];
      
      if (!emaNow || !emaHTFNow || !rsiNow || !rsiHTFNow) {
        emaConditionsMet = false;
      } else {
        // For BUY: Price above EMA, RSI > 45 but not overbought (< 75)
        const buyEmaCondition = dir5m === 'BUY' ? 
          (currentClose > emaNow && currentClose > emaHTFNow) : 
          (currentClose < emaNow && currentClose < emaHTFNow);
        
        const buyRsiCondition = dir5m === 'BUY' ? 
          (rsiNow > 45 && rsiNow < 75 && rsiHTFNow > 45 && rsiHTFNow < 75) :
          (rsiNow < 55 && rsiNow > 25 && rsiHTFNow < 55 && rsiHTFNow > 25);
        
        emaConditionsMet = buyEmaCondition && buyRsiCondition;
        
        conditions.push({ 
          name: `EMA alignment (Price ${dir5m === 'BUY' ? 'above' : 'below'} EMA)`, 
          met: buyEmaCondition 
        });
        conditions.push({ 
          name: `RSI conditions (5m: ${rsiNow.toFixed(1)}, 15m: ${rsiHTFNow.toFixed(1)})`, 
          met: buyRsiCondition 
        });
      }
      
      if (!emaConditionsMet) allConditionsMet = false;
    }

    // Condition 5: Valid retracement level
    const range = recentHigh - recentLow;
    const retracementLevel = (currentClose - recentLow) / range;
    const validRetracement = retracementLevel >= 0.35 && retracementLevel <= 0.65;
    conditions.push({ name: `Valid retracement (${(retracementLevel * 100).toFixed(1)}% of range)`, met: validRetracement });
    if (!validRetracement) allConditionsMet = false;

    // Condition 6: Recent breakout confirmation
    const previousHigh = Math.max(...last20.slice(-15, -5).map(c => c.high));
    const previousLow = Math.min(...last20.slice(-15, -5).map(c => c.low));
    
    let hasBreakout = false;
    let bias = null;
    let reason = '';
    
    if (dir5m === 'BUY' && currentHigh > previousHigh) {
      hasBreakout = true;
      bias = 'BUY';
      reason = 'Break of Structure + Bullish Momentum';
    } else if (dir5m === 'SELL' && currentLow < previousLow) {
      hasBreakout = true;
      bias = 'SELL';
      reason = 'Break of Structure + Bearish Momentum';
    }
    
    conditions.push({ name: `Breakout confirmation`, met: hasBreakout });
    if (!hasBreakout) allConditionsMet = false;

    // Update condition display
    updateConditionStatus(conditions);

    // FINAL CHECK: Only generate signal if ALL conditions are met
    if (allConditionsMet && bias) {
      const properties = assetProperties[state.pair] || { volatility: 0.1 };
      const baseVolatility = properties.volatility;
      
      const sl = bias === 'BUY' ? recentLow - range * 0.15 : recentHigh + range * 0.15;
      const tp = bias === 'BUY' ? currentClose + range * 1.5 : currentClose - range * 1.5;
      
      // Calculate confidence based on how many conditions were strongly met
      let confidence = 70;
      if (volatility > baseVolatility * 0.8) confidence += 10;
      if (timeframeAligned) confidence += 10;
      if (validRetracement && retracementLevel >= 0.4 && retracementLevel <= 0.6) confidence += 10;
      
      const sig = {
        pair: state.pair,
        bias,
        entry: currentClose,
        tp: tp,
        sl: sl,
        reason: `${reason} + Multi-Timeframe${state.filter ? ' + EMA+RSI' : ''}`,
        confidence: Math.min(confidence, 95),
        time: new Date().toLocaleTimeString()
      };
      
      // Prevent signal spam (1.5 minute cooldown)
      if (Date.now() - state.lastSignalTime > 90000) {
        state.lastSignalTime = Date.now();
        state.signals.push(sig);
        state.currentBias = bias;
        addSignal(sig);
        console.log('üéØ ALL CONDITIONS MET - SIGNAL GENERATED!', sig);
      } else {
        console.log('‚è≥ Signal cooldown active');
      }
    } else {
      console.log('‚ùå Conditions not met for signal generation');
      console.log('Failed conditions:', conditions.filter(c => !c.met).map(c => c.name));
      updateCurrentSignal(null, 0);
      state.currentBias = null;
    }
    
  } catch (error) {
    console.error('Error in SMC detection:', error);
    updateConditionStatus([{ name: 'Error in detection logic', met: false }]);
    updateCurrentSignal(null, 0);
  }
}

// --- Load Historical Data for All Assets ---
async function loadHistoricalData(pair, timeframe, limit = 100) {
  try {
    document.getElementById('loadingIndicator').style.display = 'block';
    
    const candles = [];
    const properties = assetProperties[pair] || { basePrice: 1.0, volatility: 0.01, trendStrength: 0.001, decimals: 5 };
    const { basePrice, volatility, trendStrength, decimals } = properties;
    
    let currentTime = getCurrentCandleTime(timeframe) - (limit * timeframe * 60);
    let lastClose = basePrice;
    
    // Create realistic price movement
    let trend = trendStrength;
    let jumpProbability = pair.includes('Jump') ? 0.1 : 0.02;
    let crashBoomProbability = (pair.includes('Boom') || pair.includes('Crash')) ? 0.05 : 0.01;
    
    for (let i = 0; i < limit; i++) {
      let change;
      
      // Special behavior for different asset types
      if (pair.includes('Boom') && Math.random() < crashBoomProbability) {
        change = volatility * 3 * lastClose;
      } else if (pair.includes('Crash') && Math.random() < crashBoomProbability) {
        change = -volatility * 3 * lastClose;
      } else if (pair.includes('Jump') && Math.random() < jumpProbability) {
        change = (Math.random() - 0.5) * volatility * 5 * lastClose;
      } else if (pair.includes('Step')) {
        change = trend * volatility * lastClose + (Math.random() - 0.5) * volatility * 0.5 * lastClose;
      } else {
        // Normal movement with trend bias
        change = (Math.random() - 0.5 + trend) * volatility * lastClose;
      }
      
      const open = lastClose;
      const close = open + change;
      const high = Math.max(open, close) + Math.random() * volatility * lastClose * 0.5;
      const low = Math.min(open, close) - Math.random() * volatility * lastClose * 0.5;
      
      candles.push({
        time: currentTime,
        open: parseFloat(open.toFixed(decimals)),
        high: parseFloat(high.toFixed(decimals)),
        low: parseFloat(low.toFixed(decimals)),
        close: parseFloat(close.toFixed(decimals)),
        volume: pair.includes('Index') ? 10000 + Math.random() * 50000 : 1000 + Math.random() * 5000
      });
      
      lastClose = close;
      currentTime += timeframe * 60;
    }
    
    document.getElementById('loadingIndicator').style.display = 'none';
    return candles;
    
  } catch (error) {
    console.error('Error loading historical data:', error);
    document.getElementById('loadingIndicator').style.display = 'none';
    return [];
  }
}

// --- Real-Time Synchronized Data Simulation ---
function startLiveDataSimulation() {
  if (state.liveUpdateInterval) {
    clearInterval(state.liveUpdateInterval);
  }
  
  // Start time synchronization
  if (state.timeSyncInterval) {
    clearInterval(state.timeSyncInterval);
  }
  
  state.timeSyncInterval = setInterval(updateTimeDisplay, 1000);
  
  state.liveUpdateInterval = setInterval(() => {
    if (state.candles.length > 0) {
      const now = getCurrentCandleTime(5);
      const lastCandle = state.candles[state.candles.length - 1];
      const properties = assetProperties[state.pair] || { volatility: 0.01, trendStrength: 0.001 };
      
      // Only create new candle when real 5 minutes have passed
      if (now > lastCandle.time) {
        let change;
        const volatility = properties.volatility;
        const trend = properties.trendStrength;
        
        // Special behaviors for different asset types
        if (state.pair.includes('Boom') && Math.random() < 0.03) {
          change = volatility * 2 * lastCandle.close;
        } else if (state.pair.includes('Crash') && Math.random() < 0.03) {
          change = -volatility * 2 * lastCandle.close;
        } else if (state.pair.includes('Jump') && Math.random() < 0.08) {
          change = (Math.random() - 0.5) * volatility * 4 * lastCandle.close;
        } else {
          change = (Math.random() - 0.5 + trend) * volatility * lastCandle.close;
        }
        
        const newCandle = {
          time: now,
          open: lastCandle.close,
          close: lastCandle.close + change,
          high: Math.max(lastCandle.close, lastCandle.close + change) + Math.random() * volatility * lastCandle.close,
          low: Math.min(lastCandle.close, lastCandle.close + change) - Math.random() * volatility * lastCandle.close,
          volume: state.pair.includes('Index') ? 10000 + Math.random() * 50000 : 1000 + Math.random() * 5000
        };
        
        state.candles.push(newCandle);
        if (state.candles.length > 200) state.candles.shift();
        
        // Update 15m chart every 3 candles (15 minutes)
        if (state.candles.length % 3 === 0 && state.candlesHTF.length > 0) {
          const lastHTF = state.candlesHTF[state.candlesHTF.length - 1];
          const recent5m = state.candles.slice(-3);
          
          const newHTFCandle = {
            time: getCurrentCandleTime(15),
            open: lastHTF.close,
            close: newCandle.close,
            high: Math.max(lastHTF.high, ...recent5m.map(c => c.high)),
            low: Math.min(lastHTF.low, ...recent5m.map(c => c.low)),
            volume: recent5m.reduce((sum, c) => sum + c.volume, 0)
          };
          
          state.candlesHTF.push(newHTFCandle);
          if (state.candlesHTF.length > 100) state.candlesHTF.shift();
          
          const closesHTFAll = state.candlesHTF.map(x => x.close);
          state.emaHTF = calcEMA(closesHTFAll, 50);
          state.rsiHTF = calcRSI(closesHTFAll, 14);
        }
        
        const closesAll = state.candles.map(x => x.close);
        state.ema = calcEMA(closesAll, 50);
        state.rsi = calcRSI(closesAll, 14);
        
        if (state.ema.length > 0) {
          const emaPlot = state.candles.slice(-state.ema.length).map((x, i) => ({
            time: x.time,
            value: state.ema[i]
          }));
          state.emaSeries.setData(emaPlot);
        }
        
        state.series.setData(state.candles);
        updateTimeDisplay();
        
        // Check for signals only when we have enough data
        if (state.auto && state.candles.length > 35 && state.candlesHTF.length > 15) {
          detectSMC();
        }
        
        console.log(`üïí New 5m candle created at ${new Date(now * 1000).toLocaleTimeString()}`);
      }
    }
  }, 1000); // Check every second for new candles
}

// --- Connect to Data Feeds ---
document.getElementById('connectFeed').addEventListener('click', async () => {
  try {
    const pair = document.getElementById('pairSelect').value;
    state.pair = pair;
    
    state.candles = [];
    state.candlesHTF = [];
    state.signals = [];
    state.currentBias = null;
    document.getElementById('signalLog').innerHTML = '';
    document.getElementById('signalCount').textContent = '(0)';
    updateCurrentSignal(null, 0);
    
    document.getElementById('connectionStatus').textContent = 'Loading...';
    document.getElementById('connectionStatus').className = 'connecting';
    
    const historical5m = await loadHistoricalData(pair, 5, 100);
    const historical15m = await loadHistoricalData(pair, 15, 50);
    
    state.candles = historical5m;
    state.candlesHTF = historical15m;
    
    if (state.candles.length > 0) {
      state.series.setData(state.candles);
      
      const closesAll = state.candles.map(x => x.close);
      state.ema = calcEMA(closesAll, 50);
      state.rsi = calcRSI(closesAll, 14);
      
      if (state.ema.length > 0) {
        const emaPlot = state.candles.slice(-state.ema.length).map((x, i) => ({
          time: x.time,
          value: state.ema[i]
        }));
        state.emaSeries.setData(emaPlot);
      }
      
      const closesHTFAll = state.candlesHTF.map(x => x.close);
      state.emaHTF = calcEMA(closesHTFAll, 50);
      state.rsiHTF = calcRSI(closesHTFAll, 14);
    }
    
    startLiveDataSimulation();
    
    document.getElementById('connectionStatus').textContent = `Connected (${pair})`;
    document.getElementById('connectionStatus').className = 'connected';
    document.getElementById('feed5mStatus').textContent = '‚úÖ';
    document.getElementById('feed5mStatus').className = 'connected';
    document.getElementById('feed15mStatus').textContent = '‚úÖ';
    document.getElementById('feed15mStatus').className = 'connected';
    
    updateTimeDisplay();
    
  } catch (error) {
    console.error('Connection error:', error);
    document.getElementById('connectionStatus').textContent = 'Connection Failed';
    document.getElementById('connectionStatus').className = 'disconnected';
  }
});

// --- Disconnect feeds ---
document.getElementById('disconnectFeed').addEventListener('click', () => {
  if (state.liveUpdateInterval) {
    clearInterval(state.liveUpdateInterval);
    state.liveUpdateInterval = null;
  }
  if (state.timeSyncInterval) {
    clearInterval(state.timeSyncInterval);
    state.timeSyncInterval = null;
  }
  
  document.getElementById('connectionStatus').textContent = 'Disconnected';
  document.getElementById('connectionStatus').className = 'disconnected';
  document.getElementById('feed5mStatus').textContent = '‚ùå';
  document.getElementById('feed5mStatus').className = 'disconnected';
  document.getElementById('feed15mStatus').textContent = '‚ùå';
  document.getElementById('feed15mStatus').className = 'disconnected';
  updateCurrentSignal(null, 0);
});

// --- Manual signal generation ---
document.getElementById('generateSignal').addEventListener('click', () => {
  console.log('Manual signal generation triggered');
  detectSMC();
});

// --- Clear log ---
document.getElementById('clearSignals').addEventListener('click', () => {
  document.getElementById('signalLog').innerHTML = '';
  state.signals = [];
  document.getElementById('signalCount').textContent = '(0)';
});

// --- Auto Mode toggle ---
document.getElementById('autoMode').addEventListener('change', (e) => {
  state.auto = e.target.checked;
  console.log('Auto mode:', state.auto ? 'ON' : 'OFF');
});

document.getElementById('filterMode').addEventListener('change', (e) => {
  state.filter = e.target.checked;
  console.log('Filter mode:', state.filter ? 'ON' : 'OFF');
});

// --- Pair selection change ---
document.getElementById('pairSelect').addEventListener('change', (e) => {
  const newPair = e.target.value;
  console.log(`Pair changed to: ${newPair}`);
  
  // If already connected, reconnect with new pair
  if (state.liveUpdateInterval) {
    document.getElementById('connectFeed').click();
  }
});

// --- Auto-connect on page load ---
window.addEventListener('load', () => {
  setTimeout(() => {
    document.getElementById('connectFeed').click();
  }, 1000);
});

// --- Cleanup on page unload ---
window.addEventListener('beforeunload', () => {
  if (state.liveUpdateInterval) clearInterval(state.liveUpdateInterval);
  if (state.timeSyncInterval) clearInterval(state.timeSyncInterval);
});
</script>
</body>
</html>
