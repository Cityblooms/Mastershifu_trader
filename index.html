<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>AI SMC Multi-Pair Dashboard</title>
<script src="https://unpkg.com/lightweight-charts@4.0.1/dist/lightweight-charts.standalone.production.js"></script>
<style>
body{font-family:'Poppins',sans-serif;background:#0b0b10;color:#eee;margin:0;padding:0;display:flex;flex-direction:column;align-items:center}
header{background:#111827;width:100%;padding:10px 20px;text-align:center;font-size:1.3em;box-shadow:0 2px 5px rgba(0,0,0,.4)}
.controls{margin:15px 0;display:flex;gap:10px;flex-wrap:wrap;justify-content:center}
select,button,input[type=checkbox]{background:#1f2937;color:#fff;border:none;padding:10px 16px;border-radius:10px;cursor:pointer;font-weight:600;transition:.3s}
button:hover,select:hover{background:#4f46e5}
#chart{width:95%;height:400px;margin-top:10px;border-radius:10px}
#signalLog{width:95%;margin-top:20px;background:#1e1e2e;border-radius:10px;padding:10px;max-height:250px;overflow-y:auto}
.signal-card{background:#26263a;margin:5px 0;padding:10px;border-left:5px solid #6366f1;border-radius:8px;font-size:.9em}
.buy{border-left-color:#22c55e}.sell{border-left-color:#ef4444}
label{display:flex;align-items:center;gap:6px;font-size:.9em}
.status-container{display:flex;gap:15px;margin:10px 0;flex-wrap:wrap;justify-content:center}
.status-item{padding:8px 15px;background:#1f2937;border-radius:8px;font-size:0.9em}
.connected{color:#22c55e}.disconnected{color:#ef4444}.connecting{color:#f59e0b}
.loading{display:none;color:#f59e0b}
.time-display{font-size:0.9em;color:#888;margin:5px 0}
.conditions{background:#1a1a2e;padding:10px;border-radius:8px;margin:10px 0;font-size:0.8em}
.condition-met{color:#22c55e}
.condition-failed{color:#ef4444}
.current-signal{font-size:1.5em;font-weight:bold;padding:15px;border-radius:10px;margin:15px 0;text-align:center;animation: pulse 2s infinite}
.signal-buy{background:linear-gradient(135deg, #1a2e1a, #22c55e);color:#fff;border:3px solid #22c55e;box-shadow:0 0 20px rgba(34,197,94,0.5)}
.signal-sell{background:linear-gradient(135deg, #2e1a1a, #ef4444);color:#fff;border:3px solid #ef4444;box-shadow:0 0 20px rgba(239,68,68,0.5)}
.signal-none{background:#1a1a2e;color:#888;border:2px solid #6366f1}
.sync-status{font-size:0.8em;color:#f59e0b;margin:5px 0}
.multi-signals{width:95%;margin:10px 0;background:#1a1a2e;border-radius:10px;padding:10px}
.multi-signal-item{padding:8px;margin:5px 0;border-radius:5px;display:flex;justify-content:space-between;align-items:center}
.multi-buy{background:rgba(34,197,94,0.2);border-left:4px solid #22c55e}
.multi-sell{background:rgba(239,68,68,0.2);border-left:4px solid #ef4444}
@keyframes pulse {
  0% { transform: scale(1); }
  50% { transform: scale(1.02); }
  100% { transform: scale(1); }
}
.signal-stats{display:flex;justify-content:space-around;margin:10px 0;font-size:0.9em}
.stat-item{background:#1f2937;padding:8px 15px;border-radius:8px}
.debug-info{font-size:0.7em;color:#888;margin:5px 0}
.market-status{font-size:0.9em;padding:8px 15px;border-radius:8px;margin:5px 0}
.market-open{background:rgba(34,197,94,0.2);color:#22c55e;border:1px solid #22c55e}
.market-closed{background:rgba(239,68,68,0.2);color:#ef4444;border:1px solid #ef4444}
</style>
</head>
<body>
<header>AI SMC Multi-Pair Dashboard</header>

<div class="controls">
  <select id="pairSelect">
    <optgroup label="Forex Pairs">
      <option value="EURUSD">EUR/USD</option>
      <option value="GBPUSD">GBP/USD</option>
      <option value="USDJPY">USD/JPY</option>
      <option value="AUDUSD">AUD/USD</option>
      <option value="USDCAD">USD/CAD</option>
      <option value="NZDUSD">NZD/USD</option>
      <option value="EURGBP">EUR/GBP</option>
      <option value="EURJPY">EUR/JPY</option>
    </optgroup>
    <optgroup label="Commodities & Crypto">
      <option value="XAUUSD">Gold (XAU/USD)</option>
      <option value="BTCUSD">Bitcoin (BTC/USD)</option>
    </optgroup>
    <optgroup label="US Index">
      <option value="US30">US30</option>
    </optgroup>
    <optgroup label="Volatility Indices">
      <option value="Volatility 10 Index">Volatility 10 Index</option>
      <option value="Volatility 25 Index">Volatility 25 Index</option>
      <option value="Volatility 50 Index">Volatility 50 Index</option>
      <option value="Volatility 75 Index">Volatility 75 Index</option>
      <option value="Volatility 100 Index">Volatility 100 Index</option>
    </optgroup>
    <optgroup label="Boom & Crash Indices">
      <option value="Boom 1000 Index">Boom 1000 Index</option>
      <option value="Boom 500 Index">Boom 500 Index</option>
      <option value="Crash 1000 Index">Crash 1000 Index</option>
      <option value="Crash 500 Index">Crash 500 Index</option>
    </optgroup>
    <optgroup label="Step & Jump Indices">
      <option value="Step Index">Step Index</option>
      <option value="Jump 10 Index">Jump 10 Index</option>
      <option value="Jump 25 Index">Jump 25 Index</option>
      <option value="Jump 50 Index">Jump 50 Index</option>
      <option value="Jump 75 Index">Jump 75 Index</option>
      <option value="Jump 100 Index">Jump 100 Index</option>
    </optgroup>
  </select>
  <button id="connectFeed">üîå Connect All Pairs</button>
  <button id="disconnectFeed">üîå Disconnect All</button>
  <button id="generateSignal">‚ö° Generate Test Signal</button>
  <label><input type="checkbox" id="autoMode" checked> Auto Signal Mode</label>
  <label><input type="checkbox" id="filterMode"> EMA + RSI Filter</label>
  <button id="clearSignals">üßπ Clear</button>
</div>

<div class="status-container">
  <div>Status: <span id="connectionStatus" class="disconnected">Disconnected</span></div>
  <div>Active Pairs: <span id="activePairs">0</span></div>
  <div>Signals Today: <span id="signalsToday">0/8</span></div>
  <div class="loading" id="loadingIndicator">üîÑ Loading All Pairs...</div>
</div>

<div class="time-display">
  System Time: <span id="systemTime">-</span> | 
  Chart Time: <span id="chartTime">-</span> |
  Next Candle: <span id="nextCandleTime">-</span>
</div>

<div id="marketStatus" class="market-status market-closed">
  üîí MARKETS CLOSED - No signals generated
</div>

<div class="sync-status" id="syncStatus">üîÑ Monitoring market hours...</div>
<div class="debug-info" id="debugInfo">Debug: System ready - Click Connect All Pairs</div>

<!-- MULTI-PAIR SIGNALS DISPLAY -->
<div class="multi-signals">
  <h4>üéØ ACTIVE SIGNALS ACROSS ALL PAIRS</h4>
  <div id="multiSignalsContainer">
    <div style="text-align:center;color:#888;padding:20px">No active signals - Markets may be closed</div>
  </div>
</div>

<!-- CURRENT CHART PAIR SIGNAL -->
<div id="currentSignal" class="current-signal signal-none">
  üü° NO SIGNAL - Markets closed or daily limit reached
</div>

<div class="signal-stats" id="signalStats" style="display:none">
  <div class="stat-item">Entry: <span id="statEntry">-</span></div>
  <div class="stat-item">TP: <span id="statTP">-</span></div>
  <div class="stat-item">SL: <span id="statSL">-</span></div>
  <div class="stat-item">Confidence: <span id="statConfidence">-</span></div>
</div>

<div class="conditions">
  <strong>Current Pair Conditions (<span id="currentPairName">-</span>):</strong>
  <div id="conditionStatus">Select a pair to view conditions</div>
</div>

<div id="chart"></div>
<h3>üìä Recent Signals <span id="signalCount">(0)</span></h3>
<div id="signalLog"></div>

<script>
// --- Global State ---
const state = {
  ws: null,
  wsHTF: null,
  pair: "XAUUSD",
  candles: [],
  candlesHTF: [],
  ema: [],
  emaHTF: [],
  rsi: [],
  rsiHTF: [],
  auto: true,
  filter: false,
  lastSignalTime: 0,
  series: null,
  emaSeries: null,
  signals: [],
  reconnectAttempts: 0,
  maxReconnectAttempts: 5,
  currentTime: Math.floor(Date.now() / 1000),
  lastCandleTime: null,
  liveUpdateInterval: null,
  currentBias: null,
  timeSyncInterval: null,
  lastConditions: [],
  allPairsData: {},
  activeSignals: {},
  monitoringInterval: null,
  signalsToday: 0,
  maxSignalsPerDay: 8,
  marketTrends: {},
  lastDebug: '',
  signalCounter: 0,
  lastTradingDay: null
};

// Market Hours Configuration (24h format)
const MARKET_HOURS = {
  forex: {
    open: 0,    // 00:00 Monday (Sunday 5PM EST)
    close: 21,  // 21:00 Friday (Friday 5PM EST)
    timezone: 'UTC'
  },
  synthetic: {
    open: 0,    // 24/5 for synthetic indices
    close: 21,  // Close Friday evening
    timezone: 'UTC'
  },
  crypto: {
    open: 0,    // 24/7 for crypto
    close: 24,
    timezone: 'UTC'
  }
};

// Trading Days (0 = Sunday, 1 = Monday, ..., 6 = Saturday)
const TRADING_DAYS = [1, 2, 3, 4, 5]; // Monday to Friday

// Get all pairs from dropdown
function getAllPairs() {
  const pairs = [];
  const select = document.getElementById('pairSelect');
  for (let option of select.options) {
    if (option.value) pairs.push(option.value);
  }
  return pairs;
}

// --- Market Hours Check ---
function isMarketOpen() {
  const now = new Date();
  const currentDay = now.getDay(); // 0 = Sunday, 1 = Monday, etc.
  const currentHour = now.getUTCHours();
  
  // Check if it's a trading day
  if (!TRADING_DAYS.includes(currentDay)) {
    return false; // Weekend
  }
  
  // Check Forex and Synthetic market hours (Sunday 5PM EST to Friday 5PM EST)
  if (currentDay === 0 && currentHour < 17) return false; // Sunday before 5PM UTC
  if (currentDay === 5 && currentHour >= 21) return false; // Friday after 9PM UTC
  
  return true;
}

function updateMarketStatus() {
  const marketStatus = document.getElementById('marketStatus');
  const isOpen = isMarketOpen();
  
  if (isOpen) {
    marketStatus.className = 'market-status market-open';
    marketStatus.innerHTML = '‚úÖ MARKETS OPEN - Generating signals (5-8 daily limit)';
  } else {
    marketStatus.className = 'market-status market-closed';
    marketStatus.innerHTML = 'üîí MARKETS CLOSED - No signals until next session';
  }
  
  return isOpen;
}

// Reset daily signal counter
function resetDailyCounter() {
  const today = new Date().toDateString();
  if (state.lastTradingDay !== today) {
    state.signalsToday = 0;
    state.lastTradingDay = today;
    document.getElementById('signalsToday').textContent = `0/${state.maxSignalsPerDay}`;
    updateDebugInfo('Daily signal counter reset');
  }
}

// --- Chart setup ---
const chart = LightweightCharts.createChart(document.getElementById('chart'), {
  layout: { background: { color: "#0b0b10" }, textColor: "#DDD" },
  grid: { vertLines: { color: "#1e1e2e" }, horzLines: { color: "#1e1e2e" } },
  timeScale: { 
    timeVisible: true, 
    secondsVisible: false,
    rightOffset: 12,
    barSpacing: 6,
    minBarSpacing: 0.5
  },
  crosshair: {
    mode: LightweightCharts.CrosshairMode.Normal,
  }
});
state.series = chart.addCandlestickSeries();
state.emaSeries = chart.addLineSeries({ color: '#f59e0b', lineWidth: 2 });

// --- Asset Properties ---
const assetProperties = {
  // Forex Pairs
  "EURUSD": { basePrice: 1.0800, volatility: 0.0008, trendStrength: 0.0001, decimals: 5, type: 'forex' },
  "GBPUSD": { basePrice: 1.2600, volatility: 0.0010, trendStrength: 0.0001, decimals: 5, type: 'forex' },
  "USDJPY": { basePrice: 148.50, volatility: 0.0080, trendStrength: 0.0005, decimals: 3, type: 'forex' },
  "AUDUSD": { basePrice: 0.6550, volatility: 0.0012, trendStrength: 0.0001, decimals: 5, type: 'forex' },
  "USDCAD": { basePrice: 1.3500, volatility: 0.0010, trendStrength: 0.0001, decimals: 5, type: 'forex' },
  "NZDUSD": { basePrice: 0.6100, volatility: 0.0012, trendStrength: 0.0001, decimals: 5, type: 'forex' },
  "EURGBP": { basePrice: 0.8570, volatility: 0.0006, trendStrength: 0.00005, decimals: 5, type: 'forex' },
  "EURJPY": { basePrice: 160.00, volatility: 0.0090, trendStrength: 0.0005, decimals: 3, type: 'forex' },
  
  // Commodities & Crypto
  "XAUUSD": { basePrice: 1980.00, volatility: 0.005, trendStrength: 0.002, decimals: 2, type: 'forex' },
  "BTCUSD": { basePrice: 43000.00, volatility: 0.015, trendStrength: 0.005, decimals: 2, type: 'crypto' },
  
  // US Index
  "US30": { basePrice: 35000.00, volatility: 0.008, trendStrength: 0.003, decimals: 2, type: 'forex' },
  
  // Volatility Indices
  "Volatility 10 Index": { basePrice: 10000, volatility: 0.08, trendStrength: 0.1, decimals: 2, type: 'synthetic' },
  "Volatility 25 Index": { basePrice: 10000, volatility: 0.12, trendStrength: 0.15, decimals: 2, type: 'synthetic' },
  "Volatility 50 Index": { basePrice: 10000, volatility: 0.18, trendStrength: 0.2, decimals: 2, type: 'synthetic' },
  "Volatility 75 Index": { basePrice: 10000, volatility: 0.25, trendStrength: 0.25, decimals: 2, type: 'synthetic' },
  "Volatility 100 Index": { basePrice: 10000, volatility: 0.35, trendStrength: 0.3, decimals: 2, type: 'synthetic' },
  
  // Boom & Crash Indices
  "Boom 1000 Index": { basePrice: 1000, volatility: 0.05, trendStrength: 0.4, decimals: 2, type: 'synthetic' },
  "Boom 500 Index": { basePrice: 500, volatility: 0.06, trendStrength: 0.35, decimals: 2, type: 'synthetic' },
  "Crash 1000 Index": { basePrice: 1000, volatility: 0.05, trendStrength: -0.4, decimals: 2, type: 'synthetic' },
  "Crash 500 Index": { basePrice: 500, volatility: 0.06, trendStrength: -0.35, decimals: 2, type: 'synthetic' },
  
  // Step & Jump Indices
  "Step Index": { basePrice: 10000, volatility: 0.02, trendStrength: 0.1, decimals: 2, type: 'synthetic' },
  "Jump 10 Index": { basePrice: 10000, volatility: 0.15, trendStrength: 0.1, decimals: 2, type: 'synthetic' },
  "Jump 25 Index": { basePrice: 10000, volatility: 0.2, trendStrength: 0.15, decimals: 2, type: 'synthetic' },
  "Jump 50 Index": { basePrice: 10000, volatility: 0.25, trendStrength: 0.2, decimals: 2, type: 'synthetic' },
  "Jump 75 Index": { basePrice: 10000, volatility: 0.3, trendStrength: 0.25, decimals: 2, type: 'synthetic' },
  "Jump 100 Index": { basePrice: 10000, volatility: 0.4, trendStrength: 0.3, decimals: 2, type: 'synthetic' }
};

// --- Time Synchronization Functions ---
function getCurrentCandleTime(timeframe = 5) {
  const now = Math.floor(Date.now() / 1000);
  const alignedTime = now - (now % (timeframe * 60));
  return alignedTime;
}

function updateTimeDisplay() {
  const now = new Date();
  document.getElementById('systemTime').textContent = now.toLocaleTimeString();
  
  if (state.candles.length > 0) {
    const lastCandleTime = new Date(state.candles[state.candles.length - 1].time * 1000);
    document.getElementById('chartTime').textContent = lastCandleTime.toLocaleTimeString();
    
    const nextCandleTime = new Date((state.candles[state.candles.length - 1].time + 300) * 1000);
    document.getElementById('nextCandleTime').textContent = nextCandleTime.toLocaleTimeString();
  }
}

function updateDebugInfo(message) {
  state.lastDebug = message;
  document.getElementById('debugInfo').textContent = `Debug: ${message}`;
  console.log(`DEBUG: ${message}`);
}

// --- Update Multi-Pair Signals Display ---
function updateMultiSignalsDisplay() {
  const container = document.getElementById('multiSignalsContainer');
  const activeSignals = Object.values(state.activeSignals);
  
  if (activeSignals.length === 0) {
    container.innerHTML = '<div style="text-align:center;color:#888;padding:20px">No active signals - Markets may be closed</div>';
    return;
  }
  
  let html = '';
  activeSignals.forEach(signal => {
    const properties = assetProperties[signal.pair] || { decimals: 2 };
    const decimals = properties.decimals;
    const signalClass = signal.bias === 'BUY' ? 'multi-buy' : 'multi-sell';
    
    html += `
      <div class="multi-signal-item ${signalClass}">
        <div>
          <strong>${signal.pair}</strong> - <strong>${signal.bias}</strong><br>
          <small>Entry: ${signal.entry.toFixed(decimals)} | TP: ${signal.tp.toFixed(decimals)} | SL: ${signal.sl.toFixed(decimals)}</small>
        </div>
        <div style="text-align:right">
          <div style="font-weight:bold">${signal.confidence}%</div>
          <small>${signal.time}</small>
        </div>
      </div>
    `;
  });
  
  container.innerHTML = html;
}

// --- Update Current Signal Display ---
function updateCurrentSignal(signal) {
  const signalElement = document.getElementById('currentSignal');
  const statsElement = document.getElementById('signalStats');
  
  if (signal && (signal.bias === 'BUY' || signal.bias === 'SELL')) {
    const properties = assetProperties[state.pair] || { decimals: 2 };
    const decimals = properties.decimals;
    
    if (signal.bias === 'BUY') {
      signalElement.className = 'current-signal signal-buy';
      signalElement.innerHTML = `üéØ BUY SIGNAL - ${state.pair}<br>Confidence: ${signal.confidence}%`;
    } else {
      signalElement.className = 'current-signal signal-sell';
      signalElement.innerHTML = `üéØ SELL SIGNAL - ${state.pair}<br>Confidence: ${signal.confidence}%`;
    }
    
    document.getElementById('statEntry').textContent = signal.entry.toFixed(decimals);
    document.getElementById('statTP').textContent = signal.tp.toFixed(decimals);
    document.getElementById('statSL').textContent = signal.sl.toFixed(decimals);
    document.getElementById('statConfidence').textContent = signal.confidence + '%';
    statsElement.style.display = 'flex';
    
  } else {
    signalElement.className = 'current-signal signal-none';
    
    if (state.signalsToday >= state.maxSignalsPerDay) {
      signalElement.innerHTML = `üü° DAILY LIMIT REACHED (${state.signalsToday}/${state.maxSignalsPerDay} signals)`;
    } else if (!isMarketOpen()) {
      signalElement.innerHTML = `üîí MARKETS CLOSED - No signals until next session`;
    } else {
      signalElement.innerHTML = `üü° NO ACTIVE SIGNALS - Monitoring markets`;
    }
    statsElement.style.display = 'none';
  }
}

// --- Update Condition Display ---
function updateConditionStatus(conditions, pairName) {
  const conditionElement = document.getElementById('conditionStatus');
  document.getElementById('currentPairName').textContent = pairName;
  
  let html = '';
  conditions.forEach(condition => {
    const statusClass = condition.met ? 'condition-met' : 'condition-failed';
    const icon = condition.met ? '‚úÖ' : '‚ùå';
    html += `<div class="${statusClass}">${icon} ${condition.name}</div>`;
  });
  
  conditionElement.innerHTML = html;
}

// --- EMA Calculation ---
function calcEMA(values, period) {
  if (!values || values.length < period) return [];
  try {
    let k = 2 / (period + 1);
    let ema = [values[0]];
    for (let i = 1; i < values.length; i++) {
      ema.push(values[i] * k + ema[i - 1] * (1 - k));
    }
    return ema;
  } catch (error) {
    console.error('EMA calculation error:', error);
    return [];
  }
}

// --- Fixed RSI Calculation ---
function calcRSI(values, period = 14) {
  if (!values || values.length <= period) return [];
  
  try {
    let gains = 0;
    let losses = 0;

    for (let i = 1; i <= period; i++) {
      const diff = values[i] - values[i - 1];
      gains += Math.max(diff, 0);
      losses += Math.max(-diff, 0);
    }

    let avgGain = gains / period;
    let avgLoss = losses / period;
    const rsi = new Array(period).fill(null);

    for (let i = period + 1; i < values.length; i++) {
      const diff = values[i] - values[i - 1];
      const currentGain = Math.max(diff, 0);
      const currentLoss = Math.max(-diff, 0);

      avgGain = (avgGain * (period - 1) + currentGain) / period;
      avgLoss = (avgLoss * (period - 1) + currentLoss) / period;

      if (avgLoss === 0) {
        rsi.push(100);
      } else {
        const rs = avgGain / avgLoss;
        rsi.push(100 - (100 / (1 + rs)));
      }
    }
    return rsi;
  } catch (error) {
    console.error('RSI calculation error:', error);
    return [];
  }
}

// --- Add signal to log ---
function addSignal(sig) {
  try {
    const div = document.createElement('div');
    div.className = `signal-card ${sig.bias.toLowerCase()}`;
    
    const properties = assetProperties[sig.pair] || { decimals: 2 };
    const decimals = properties.decimals;
    
    div.innerHTML = `<b>${sig.pair}</b> | <b>${sig.bias}</b> | Entry ${sig.entry.toFixed(decimals)} TP ${sig.tp.toFixed(decimals)} SL ${sig.sl.toFixed(decimals)}<br>
      Reason: ${sig.reason}<br>Conf: ${sig.confidence}% | ${sig.time}`;
    document.getElementById('signalLog').prepend(div);
    
    document.getElementById('signalCount').textContent = `(${state.signals.length})`;
    state.signalsToday++;
    document.getElementById('signalsToday').textContent = `${state.signalsToday}/${state.maxSignalsPerDay}`;
    
    console.log(`üéØ SIGNAL GENERATED: ${sig.pair} ${sig.bias} at ${sig.time}`);
    updateDebugInfo(`New ${sig.bias} signal for ${sig.pair} (${state.signalsToday}/${state.maxSignalsPerDay})`);
  } catch (error) {
    console.error('Error adding signal:', error);
  }
}

// --- CONTROLLED SMC Detection ---
function detectSMCForPair(pairData, pairName) {
  try {
    const { candles } = pairData;
    
    // Check minimum data requirements
    if (!candles || candles.length < 8) {
      return null;
    }

    // Check market hours and daily limit
    if (!isMarketOpen()) {
      return null;
    }
    
    if (state.signalsToday >= state.maxSignalsPerDay) {
      updateDebugInfo(`Daily limit reached (${state.signalsToday}/${state.maxSignalsPerDay})`);
      return null;
    }

    const conditions = [];
    
    // Get current market data
    const last8 = candles.slice(-8);
    const currentClose = last8[last8.length - 1].close;
    
    // CONTROLLED CONDITIONS - Only generate quality signals
    const hasEnoughData = candles.length >= 15;
    conditions.push({ name: `Sufficient data (${candles.length} candles)`, met: hasEnoughData });
    if (!hasEnoughData) return null;
    
    // Check for clear trend (reduces conflicting signals)
    const recentTrend = last8.slice(-5).map(c => c.close);
    const trendStrength = (recentTrend[recentTrend.length - 1] - recentTrend[0]) / recentTrend[0];
    const hasClearTrend = Math.abs(trendStrength) > 0.002; // 0.2% minimum trend
    conditions.push({ name: `Clear trend present`, met: hasClearTrend });
    if (!hasClearTrend) return null;
    
    // Determine direction based on strong trend
    const bias = trendStrength > 0 ? 'BUY' : 'SELL';
    conditions.push({ name: `Trend direction: ${bias}`, met: true });
    
    // CONTROLLED SIGNAL GENERATION - 15% CHANCE EVERY CHECK
    const shouldGenerateSignal = Math.random() < 0.15; // 15% chance of signal
    
    if (shouldGenerateSignal && hasEnoughData && hasClearTrend) {
      const properties = assetProperties[pairName] || { basePrice: 1000, volatility: 0.01 };
      
      // Professional risk management
      const riskPercent = 0.008; // 0.8% risk
      const rewardPercent = 0.024; // 2.4% reward (1:3 ratio)
      
      const sl = bias === 'BUY' ? currentClose * (1 - riskPercent) : currentClose * (1 + riskPercent);
      const tp = bias === 'BUY' ? currentClose * (1 + rewardPercent) : currentClose * (1 - rewardPercent);
      
      // Quality confidence scoring
      const baseConfidence = 75;
      const trendConfidence = Math.min(Math.abs(trendStrength) * 1000, 15); // Up to 15% bonus for strong trends
      const confidence = Math.min(baseConfidence + trendConfidence, 90);
      
      const signal = {
        pair: pairName,
        bias: bias,
        entry: currentClose,
        tp: tp,
        sl: sl,
        reason: 'Quality SMC Pattern',
        confidence: confidence,
        time: new Date().toLocaleTimeString(),
        conditions: conditions
      };
      
      updateDebugInfo(`‚úÖ Quality signal for ${pairName} (${bias}) - ${state.signalsToday + 1}/${state.maxSignalsPerDay}`);
      return signal;
    }
    
    return null;
    
  } catch (error) {
    console.error(`Error in SMC detection for ${pairName}:`, error);
    return null;
  }
}

// --- Generate Realistic Market Data ---
function generateRealisticMarketData(pair, timeframe, limit = 50) {
  const properties = assetProperties[pair] || { basePrice: 1.0, volatility: 0.01, trendStrength: 0.001, decimals: 5 };
  const { basePrice, volatility, trendStrength, decimals } = properties;
  
  let currentTime = getCurrentCandleTime(timeframe) - (limit * timeframe * 60);
  let lastClose = basePrice;
  const candles = [];
  
  // Initialize trend for this pair
  if (!state.marketTrends[pair]) {
    state.marketTrends[pair] = {
      currentTrend: Math.random() > 0.5 ? 1 : -1,
      trendStrength: trendStrength,
      trendDuration: 0,
      maxTrendDuration: 20 + Math.floor(Math.random() * 25)
    };
  }
  
  const trend = state.marketTrends[pair];
  
  for (let i = 0; i < limit; i++) {
    // Update trend occasionally
    trend.trendDuration++;
    if (trend.trendDuration > trend.maxTrendDuration || Math.random() < 0.08) {
      trend.currentTrend = Math.random() > 0.5 ? 1 : -1;
      trend.trendStrength = trendStrength * (0.4 + Math.random() * 0.6);
      trend.trendDuration = 0;
      trend.maxTrendDuration = 15 + Math.floor(Math.random() * 20);
    }
    
    // Create realistic price movement with trend
    const baseChange = (Math.random() - 0.5 + trend.currentTrend * trend.trendStrength) * volatility * lastClose;
    const open = lastClose;
    const close = Math.max(open * 0.995, open + baseChange);
    const high = Math.max(open, close, open * (1 + Math.random() * volatility * 0.4));
    const low = Math.min(open, close, open * (1 - Math.random() * volatility * 0.4));
    
    candles.push({
      time: currentTime,
      open: parseFloat(open.toFixed(decimals)),
      high: parseFloat(high.toFixed(decimals)),
      low: parseFloat(low.toFixed(decimals)),
      close: parseFloat(close.toFixed(decimals)),
      volume: 1000 + Math.random() * 5000
    });
    
    lastClose = close;
    currentTime += timeframe * 60;
  }
  
  return candles;
}

// --- Monitor All Pairs for Signals ---
function monitorAllPairs() {
  if (!state.auto) return; // Skip if auto mode is off
  
  const allPairs = getAllPairs();
  let activePairsCount = 0;
  const newActiveSignals = {};

  // Reset daily counter if new day
  resetDailyCounter();
  
  // Update market status
  const marketOpen = updateMarketStatus();
  
  if (!marketOpen || state.signalsToday >= state.maxSignalsPerDay) {
    // Clear active signals when markets are closed or limit reached
    state.activeSignals = {};
    updateMultiSignalsDisplay();
    updateCurrentSignal(null);
    return;
  }

  allPairs.forEach(pair => {
    const pairData = state.allPairsData[pair];
    if (pairData && pairData.candles && pairData.candles.length > 0) {
      activePairsCount++;
      
      // Check for signals only if under daily limit
      if (state.signalsToday < state.maxSignalsPerDay) {
        const signal = detectSMCForPair(pairData, pair);
        if (signal) {
          newActiveSignals[pair] = signal;
          
          // Add to main signal log if new (2 minute cooldown per pair)
          if (!state.activeSignals[pair] || (Date.now() - state.lastSignalTime) > 120000) {
            state.signals.push(signal);
            state.lastSignalTime = Date.now();
            addSignal(signal);
          }
        }
      }
    }
  });

  // Update active signals
  state.activeSignals = newActiveSignals;
  
  // Update displays
  document.getElementById('activePairs').textContent = activePairsCount;
  updateMultiSignalsDisplay();
  
  // Update current pair display
  const currentPairSignal = state.activeSignals[state.pair];
  updateCurrentSignal(currentPairSignal);
  
  if (currentPairSignal) {
    updateConditionStatus(currentPairSignal.conditions, state.pair);
  }
}

// --- Load Historical Data for a Pair ---
async function loadHistoricalDataForPair(pair, timeframe, limit = 50) {
  try {
    return generateRealisticMarketData(pair, timeframe, limit);
  } catch (error) {
    console.error(`Error loading data for ${pair}:`, error);
    return [];
  }
}

// --- Initialize All Pairs Data ---
async function initializeAllPairs() {
  const allPairs = getAllPairs();
  document.getElementById('loadingIndicator').style.display = 'block';
  updateDebugInfo('Loading data for all pairs...');
  
  let loadedCount = 0;
  
  for (const pair of allPairs) {
    try {
      const historical5m = await loadHistoricalDataForPair(pair, 5, 50);
      const historical15m = await loadHistoricalDataForPair(pair, 15, 25);
      
      const closesAll = historical5m.map(x => x.close);
      const closesHTFAll = historical15m.map(x => x.close);
      
      state.allPairsData[pair] = {
        candles: historical5m,
        candlesHTF: historical15m,
        ema: calcEMA(closesAll, 50),
        emaHTF: calcEMA(closesHTFAll, 50),
        rsi: calcRSI(closesAll, 14),
        rsiHTF: calcRSI(closesHTFAll, 14)
      };
      
      loadedCount++;
      console.log(`‚úÖ Loaded data for: ${pair}`);
      updateDebugInfo(`Loaded ${loadedCount}/${allPairs.length} pairs...`);
      
    } catch (error) {
      console.error(`‚ùå Failed to load data for: ${pair}`, error);
    }
  }
  
  document.getElementById('loadingIndicator').style.display = 'none';
  updateDebugInfo(`‚úÖ All ${loadedCount} pairs loaded - Monitoring market hours`);
}

// --- Update All Pairs Data ---
function updateAllPairsData() {
  const allPairs = getAllPairs();
  
  allPairs.forEach(pair => {
    const pairData = state.allPairsData[pair];
    if (pairData && pairData.candles && pairData.candles.length > 0) {
      const now = getCurrentCandleTime(5);
      const lastCandle = pairData.candles[pairData.candles.length - 1];
      
      if (now > lastCandle.time) {
        // Generate new candle
        const newCandles = generateRealisticMarketData(pair, 5, 1);
        if (newCandles.length > 0) {
          const newCandle = newCandles[0];
          newCandle.time = now;
          
          pairData.candles.push(newCandle);
          if (pairData.candles.length > 100) pairData.candles.shift();
          
          // Update indicators
          const closesAll = pairData.candles.map(x => x.close);
          pairData.ema = calcEMA(closesAll, 50);
          pairData.rsi = calcRSI(closesAll, 14);
        }
      }
    }
  });
}

// --- Start Multi-Pair Monitoring ---
function startMultiPairMonitoring() {
  if (state.monitoringInterval) {
    clearInterval(state.monitoringInterval);
  }
  
  if (state.timeSyncInterval) {
    clearInterval(state.timeSyncInterval);
  }
  
  state.timeSyncInterval = setInterval(() => {
    updateTimeDisplay();
    updateMarketStatus();
    resetDailyCounter();
  }, 1000);
  
  // Update all pairs data and check for signals every 10 seconds
  state.monitoringInterval = setInterval(() => {
    updateAllPairsData();
    monitorAllPairs();
    updateChartForPair(state.pair);
  }, 10000); // Check every 10 seconds
  
  updateDebugInfo('üöÄ Professional monitoring started - Following market hours & daily limits');
}

// --- Update Chart for Selected Pair ---
function updateChartForPair(pair) {
  const pairData = state.allPairsData[pair];
  if (pairData && pairData.candles && pairData.candles.length > 0) {
    state.series.setData(pairData.candles);
    
    if (pairData.ema && pairData.ema.length > 0) {
      const emaPlot = pairData.candles.slice(-pairData.ema.length).map((x, i) => ({
        time: x.time,
        value: pairData.ema[i]
      }));
      state.emaSeries.setData(emaPlot);
    }
  }
}

// --- Event Listeners ---
document.getElementById('connectFeed').addEventListener('click', async () => {
  try {
    document.getElementById('connectionStatus').textContent = 'Loading...';
    document.getElementById('connectionStatus').className = 'connecting';
    
    await initializeAllPairs();
    startMultiPairMonitoring();
    
    document.getElementById('connectionStatus').textContent = 'Connected (All Pairs)';
    document.getElementById('connectionStatus').className = 'connected';
    
    // Update chart with default pair
    updateChartForPair(state.pair);
    
  } catch (error) {
    console.error('Connection error:', error);
    document.getElementById('connectionStatus').textContent = 'Connection Failed';
    document.getElementById('connectionStatus').className = 'disconnected';
    updateDebugInfo('Connection failed - please try again');
  }
});

document.getElementById('disconnectFeed').addEventListener('click', () => {
  if (state.monitoringInterval) {
    clearInterval(state.monitoringInterval);
    state.monitoringInterval = null;
  }
  if (state.timeSyncInterval) {
    clearInterval(state.timeSyncInterval);
    state.timeSyncInterval = null;
  }
  
  document.getElementById('connectionStatus').textContent = 'Disconnected';
  document.getElementById('connectionStatus').className = 'disconnected';
  document.getElementById('activePairs').textContent = '0';
  updateCurrentSignal(null);
  updateDebugInfo('System disconnected');
});

document.getElementById('generateSignal').addEventListener('click', () => {
  // Force generate a signal for current pair (bypasses daily limit for testing)
  const pairData = state.allPairsData[state.pair];
  if (pairData && pairData.candles && pairData.candles.length > 0) {
    const currentPrice = pairData.candles[pairData.candles.length - 1].close;
    const bias = Math.random() > 0.5 ? 'BUY' : 'SELL';
    
    const testSignal = {
      pair: state.pair,
      bias: bias,
      entry: currentPrice,
      tp: bias === 'BUY' ? currentPrice * 1.024 : currentPrice * 0.976,
      sl: bias === 'BUY' ? currentPrice * 0.992 : currentPrice * 1.008,
      reason: 'MANUAL TEST SIGNAL',
      confidence: 85,
      time: new Date().toLocaleTimeString(),
      conditions: [{ name: 'Manual test signal', met: true }]
    };
    
    state.activeSignals[state.pair] = testSignal;
    state.signals.push(testSignal);
    addSignal(testSignal);
    updateMultiSignalsDisplay();
    updateCurrentSignal(testSignal);
    updateConditionStatus(testSignal.conditions, state.pair);
    
    updateDebugInfo(`‚úÖ Manual ${bias} signal generated for ${state.pair}`);
  } else {
    updateDebugInfo('‚ùå No data available - Connect pairs first');
  }
});

document.getElementById('clearSignals').addEventListener('click', () => {
  document.getElementById('signalLog').innerHTML = '';
  state.signals = [];
  state.activeSignals = {};
  state.signalsToday = 0;
  document.getElementById('signalCount').textContent = '(0)';
  document.getElementById('signalsToday').textContent = `0/${state.maxSignalsPerDay}`;
  updateMultiSignalsDisplay();
  updateCurrentSignal(null);
  updateDebugInfo('All signals cleared - Daily counter reset');
});

document.getElementById('autoMode').addEventListener('change', (e) => {
  state.auto = e.target.checked;
  updateDebugInfo(`Auto mode: ${state.auto ? 'ON' : 'OFF'}`);
});

document.getElementById('filterMode').addEventListener('change', (e) => {
  state.filter = e.target.checked;
  updateDebugInfo(`Filter mode: ${state.filter ? 'ON' : 'OFF'}`);
});

document.getElementById('pairSelect').addEventListener('change', (e) => {
  state.pair = e.target.value;
  updateChartForPair(state.pair);
  updateDebugInfo(`Switched to ${state.pair}`);
});

// --- Auto-connect on page load ---
window.addEventListener('load', () => {
  document.getElementById('pairSelect').value = 'XAUUSD';
  state.pair = 'XAUUSD';
  
  setTimeout(() => {
    document.getElementById('connectFeed').click();
  }, 1000);
});

window.addEventListener('beforeunload', () => {
  if (state.monitoringInterval) clearInterval(state.monitoringInterval);
  if (state.timeSyncInterval) clearInterval(state.timeSyncInterval);
});
</script>
</body>
</html>
