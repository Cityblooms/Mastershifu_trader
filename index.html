<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>AI SMC Multi-Timeframe Dashboard</title>
<script src="https://unpkg.com/lightweight-charts@4.0.1/dist/lightweight-charts.standalone.production.js"></script>
<style>
body{font-family:'Poppins',sans-serif;background:#0b0b10;color:#eee;margin:0;padding:0;display:flex;flex-direction:column;align-items:center}
header{background:#111827;width:100%;padding:10px 20px;text-align:center;font-size:1.3em;box-shadow:0 2px 5px rgba(0,0,0,.4)}
.controls{margin:15px 0;display:flex;gap:10px;flex-wrap:wrap;justify-content:center}
select,button,input[type=checkbox]{background:#1f2937;color:#fff;border:none;padding:10px 16px;border-radius:10px;cursor:pointer;font-weight:600;transition:.3s}
button:hover,select:hover{background:#4f46e5}
#chart{width:95%;height:400px;margin-top:10px;border-radius:10px}
#signalLog{width:95%;margin-top:20px;background:#1e1e2e;border-radius:10px;padding:10px;max-height:250px;overflow-y:auto}
.signal-card{background:#26263a;margin:5px 0;padding:10px;border-left:5px solid #6366f1;border-radius:8px;font-size:.9em}
.buy{border-left-color:#22c55e}.sell{border-left-color:#ef4444}
label{display:flex;align-items:center;gap:6px;font-size:.9em}
.status-container{display:flex;gap:15px;margin:10px 0;flex-wrap:wrap;justify-content:center}
.status-item{padding:8px 15px;background:#1f2937;border-radius:8px;font-size:0.9em}
.connected{color:#22c55e}.disconnected{color:#ef4444}.connecting{color:#f59e0b}
.loading{display:none;color:#f59e0b}
</style>
</head>
<body>
<header>AI SMC Multi-Timeframe Dashboard</header>

<div class="controls">
  <select id="pairSelect">
    <optgroup label="Cryptocurrencies">
      <option value="btcusdt">BTC/USDT</option>
      <option value="ethusdt">ETH/USDT</option>
      <option value="bnbusdt">BNB/USDT</option>
      <option value="adausdt">ADA/USDT</option>
      <option value="solusdt">SOL/USDT</option>
      <option value="dotusdt">DOT/USDT</option>
      <option value="linkusdt">LINK/USDT</option>
      <option value="ltcusdt">LTC/USDT</option>
    </optgroup>
    <optgroup label="Major Forex Pairs">
      <option value="EURUSD">EUR/USD</option>
      <option value="GBPUSD">GBP/USD</option>
      <option value="USDJPY">USD/JPY</option>
      <option value="USDCHF">USD/CHF</option>
      <option value="AUDUSD">AUD/USD</option>
      <option value="USDCAD">USD/CAD</option>
      <option value="NZDUSD">NZD/USD</option>
    </optgroup>
    <optgroup label="Minor Forex Pairs">
      <option value="EURGBP">EUR/GBP</option>
      <option value="EURJPY">EUR/JPY</option>
      <option value="GBPJPY">GBP/JPY</option>
      <option value="EURCAD">EUR/CAD</option>
      <option value="AUDJPY">AUD/JPY</option>
      <option value="CADJPY">CAD/JPY</option>
    </optgroup>
    <optgroup label="Synthetic Indices">
      <option value="SYNTH_Volatility">Volatility 75 Index</option>
      <option value="SYNTH_Boom">Boom 1000 Index</option>
      <option value="SYNTH_Crash">Crash 1000 Index</option>
      <option value="SYNTH_Step">Step Index</option>
      <option value="SYNTH_Range">Range Break Index</option>
      <option value="SYNTH_Jump">Jump Index</option>
    </optgroup>
    <optgroup label="Commodities">
      <option value="XAUUSD">Gold (XAU/USD)</option>
      <option value="XAGUSD">Silver (XAG/USD)</option>
      <option value="XPTUSD">Platinum (XPT/USD)</option>
      <option value="XPDUSD">Palladium (XPD/USD)</option>
    </optgroup>
    <optgroup label="Stock Indices">
      <option value="US30">US30 (Dow Jones)</option>
      <option value="SPX500">SPX500 (S&P 500)</option>
      <option value="NAS100">NAS100 (Nasdaq)</option>
      <option value="UK100">UK100 (FTSE)</option>
      <option value="GER40">GER40 (DAX)</option>
      <option value="JPN225">JPN225 (Nikkei)</option>
    </optgroup>
  </select>
  <button id="connectFeed">üîå Connect Live Feed</button>
  <button id="disconnectFeed">üîå Disconnect</button>
  <button id="generateSignal">‚ö° Manual SMC Signal</button>
  <label><input type="checkbox" id="autoMode"> Auto Signal Mode</label>
  <label><input type="checkbox" id="filterMode"> EMA + RSI Filter</label>
  <button id="clearSignals">üßπ Clear</button>
</div>

<div class="status-container">
  <div>Status: <span id="connectionStatus" class="disconnected">Disconnected</span></div>
  <div>5m Feed: <span id="feed5mStatus" class="disconnected">‚ùå</span></div>
  <div>15m Feed: <span id="feed15mStatus" class="disconnected">‚ùå</span></div>
  <div class="loading" id="loadingIndicator">üîÑ Loading Historical Data...</div>
</div>

<div id="chart"></div>
<h3>üìä Signals</h3>
<div id="signalLog"></div>

<script>
// --- Global State ---
const state = {
  ws: null,
  wsHTF: null,
  pair: "btcusdt",
  candles: [],
  candlesHTF: [],
  ema: [],
  emaHTF: [],
  rsi: [],
  rsiHTF: [],
  auto: false,
  filter: false,
  lastSignalTime: 0,
  series: null,
  emaSeries: null,
  signals: [],
  reconnectAttempts: 0,
  maxReconnectAttempts: 5,
  dataProvider: 'binance' // Default provider
};

// --- Chart setup ---
const chart = LightweightCharts.createChart(document.getElementById('chart'), {
  layout: { background: { color: "#0b0b10" }, textColor: "#DDD" },
  grid: { vertLines: { color: "#1e1e2e" }, horzLines: { color: "#1e1e2e" } },
  timeScale: { timeVisible: true, secondsVisible: false }
});
state.series = chart.addCandlestickSeries();
state.emaSeries = chart.addLineSeries({ color: '#f59e0b', lineWidth: 2 });

// --- Data Provider Configuration ---
const dataProviders = {
  binance: {
    name: 'Binance',
    cryptoPairs: ['btcusdt', 'ethusdt', 'bnbusdt', 'adausdt', 'solusdt', 'dotusdt', 'linkusdt', 'ltcusdt'],
    getWebSocketUrl: (pair, timeframe) => `wss://stream.binance.com:9443/ws/${pair}@kline_${timeframe}`,
    parseData: (data) => {
      const d = data.k;
      return {
        time: d.t / 1000,
        open: parseFloat(d.o),
        high: parseFloat(d.h),
        low: parseFloat(d.l),
        close: parseFloat(d.c),
        volume: parseFloat(d.v)
      };
    }
  },
  forex: {
    name: 'Forex',
    pairs: ['EURUSD', 'GBPUSD', 'USDJPY', 'USDCHF', 'AUDUSD', 'USDCAD', 'NZDUSD', 
            'EURGBP', 'EURJPY', 'GBPJPY', 'EURCAD', 'AUDJPY', 'CADJPY'],
    // Using TradingView-style data for forex (you can replace with your preferred forex provider)
    getWebSocketUrl: (pair, timeframe) => {
      // This is a placeholder - you'll need to replace with actual forex data provider
      return `wss://ws.fxprovider.com/${pair}/${timeframe}`;
    },
    parseData: (data) => {
      // Parse forex data format
      return {
        time: data.t / 1000,
        open: parseFloat(data.o),
        high: parseFloat(data.h),
        low: parseFloat(data.l),
        close: parseFloat(data.c),
        volume: parseFloat(data.v || 0)
      };
    }
  },
  synthetic: {
    name: 'Synthetic',
    pairs: ['SYNTH_Volatility', 'SYNTH_Boom', 'SYNTH_Crash', 'SYNTH_Step', 'SYNTH_Range', 'SYNTH_Jump'],
    // Placeholder for synthetic indices - you'll need actual data source
    getWebSocketUrl: (pair, timeframe) => {
      return `wss://synthetic-data-provider.com/${pair}/${timeframe}`;
    },
    parseData: (data) => {
      return {
        time: data.t / 1000,
        open: parseFloat(data.o),
        high: parseFloat(data.h),
        low: parseFloat(data.l),
        close: parseFloat(data.c),
        volume: 1000 // Synthetic volume
      };
    }
  }
};

// --- Determine Data Provider ---
function getDataProvider(pair) {
  if (dataProviders.binance.cryptoPairs.includes(pair.toLowerCase())) {
    return 'binance';
  } else if (dataProviders.forex.pairs.includes(pair)) {
    return 'forex';
  } else if (dataProviders.synthetic.pairs.includes(pair)) {
    return 'synthetic';
  } else {
    return 'binance'; // fallback
  }
}

// --- EMA Calculation ---
function calcEMA(values, period) {
  if (!values || values.length < period) return [];
  try {
    let k = 2 / (period + 1);
    let ema = [values[0]];
    for (let i = 1; i < values.length; i++) {
      ema.push(values[i] * k + ema[i - 1] * (1 - k));
    }
    return ema;
  } catch (error) {
    console.error('EMA calculation error:', error);
    return [];
  }
}

// --- Fixed RSI Calculation ---
function calcRSI(values, period = 14) {
  if (!values || values.length <= period) return [];
  
  try {
    let gains = 0;
    let losses = 0;

    // Calculate initial gains and losses
    for (let i = 1; i <= period; i++) {
      const diff = values[i] - values[i - 1];
      gains += Math.max(diff, 0);
      losses += Math.max(-diff, 0);
    }

    let avgGain = gains / period;
    let avgLoss = losses / period;
    const rsi = new Array(period).fill(null); // Fill initial values with null

    // Calculate subsequent RSI values
    for (let i = period + 1; i < values.length; i++) {
      const diff = values[i] - values[i - 1];
      const currentGain = Math.max(diff, 0);
      const currentLoss = Math.max(-diff, 0);

      avgGain = (avgGain * (period - 1) + currentGain) / period;
      avgLoss = (avgLoss * (period - 1) + currentLoss) / period;

      if (avgLoss === 0) {
        rsi.push(100);
      } else {
        const rs = avgGain / avgLoss;
        rsi.push(100 - (100 / (1 + rs)));
      }
    }
    return rsi;
  } catch (error) {
    console.error('RSI calculation error:', error);
    return [];
  }
}

// --- Add signal ---
function addSignal(sig) {
  try {
    const div = document.createElement('div');
    div.className = `signal-card ${sig.bias.toLowerCase()}`;
    div.innerHTML = `<b>${sig.pair}</b> | <b>${sig.bias}</b> | Entry ${sig.entry.toFixed(5)} TP ${sig.tp.toFixed(5)} SL ${sig.sl.toFixed(5)}<br>
      Reason: ${sig.reason}<br>Conf: ${sig.confidence} | ${sig.time}`;
    document.getElementById('signalLog').prepend(div);
    
    // Add marker to chart
    state.series.setMarkers([{
      time: Math.floor(Date.now() / 1000),
      position: sig.bias === 'BUY' ? 'belowBar' : 'aboveBar',
      color: sig.bias === 'BUY' ? '#22c55e' : '#ef4444',
      shape: sig.bias === 'BUY' ? 'arrowUp' : 'arrowDown',
      text: sig.bias
    }]);
  } catch (error) {
    console.error('Error adding signal:', error);
  }
}

// --- WebSocket Management ---
function connectWebSocket(url, onMessage, onStatusUpdate) {
  return new Promise((resolve, reject) => {
    try {
      const ws = new WebSocket(url);
      
      ws.onopen = () => {
        onStatusUpdate('connected');
        resolve(ws);
      };
      
      ws.onmessage = onMessage;
      
      ws.onerror = (error) => {
        console.error('WebSocket error:', error);
        onStatusUpdate('error');
        reject(error);
      };
      
      ws.onclose = (event) => {
        if (!event.wasClean) {
          onStatusUpdate('disconnected');
          setTimeout(() => reconnectWebSocket(url, onMessage, onStatusUpdate), 5000);
        }
      };
      
    } catch (error) {
      reject(error);
    }
  });
}

function reconnectWebSocket(url, onMessage, onStatusUpdate) {
  if (state.reconnectAttempts < state.maxReconnectAttempts) {
    state.reconnectAttempts++;
    onStatusUpdate('connecting');
    console.log(`Reconnection attempt ${state.reconnectAttempts}`);
    
    setTimeout(() => {
      connectWebSocket(url, onMessage, onStatusUpdate)
        .then(ws => {
          state.reconnectAttempts = 0;
          return ws;
        })
        .catch(error => {
          console.error('Reconnection failed:', error);
        });
    }, 2000);
  }
}

// --- Load Historical Data ---
async function loadHistoricalData(pair, timeframe, limit = 100) {
  try {
    document.getElementById('loadingIndicator').style.display = 'block';
    
    // For demo purposes, generating synthetic data
    // In production, replace with actual API calls to your data provider
    const candles = [];
    const basePrice = pair.includes('forex') ? 1.0 : 100;
    const volatility = pair.includes('Volatility') ? 0.1 : 0.02;
    
    let currentTime = Math.floor(Date.now() / 1000) - (limit * timeframe * 60);
    let lastClose = basePrice;
    
    for (let i = 0; i < limit; i++) {
      const change = (Math.random() - 0.5) * volatility * lastClose;
      const open = lastClose;
      const close = open + change;
      const high = Math.max(open, close) + Math.random() * volatility * lastClose * 0.5;
      const low = Math.min(open, close) - Math.random() * volatility * lastClose * 0.5;
      
      candles.push({
        time: currentTime,
        open: open,
        high: high,
        low: low,
        close: close,
        volume: 1000 + Math.random() * 5000
      });
      
      lastClose = close;
      currentTime += timeframe * 60;
    }
    
    document.getElementById('loadingIndicator').style.display = 'none';
    return candles;
    
  } catch (error) {
    console.error('Error loading historical data:', error);
    document.getElementById('loadingIndicator').style.display = 'none';
    return [];
  }
}

// --- Detect SMC Signal with multi-timeframe confirmation ---
function detectSMC() {
  try {
    if (!state.candles || state.candles.length < 30 || !state.candlesHTF || state.candlesHTF.length < 10) {
      console.log('Insufficient data for SMC detection');
      return;
    }

    // 5m analysis
    const last = state.candles.slice(-10);
    const closes = last.map(c => c.close);
    const high = Math.max(...closes);
    const low = Math.min(...closes);
    const dir5 = closes[9] > closes[0] ? 'BUY' : 'SELL';
    const range = high - low;
    const retraceZone = dir5 === 'BUY' ? low + range * 0.4 : high - range * 0.4;
    const entry = closes[9];
    const valid5 = dir5 === 'BUY' ? (entry > retraceZone && entry < high) : (entry < retraceZone && entry > low);
    
    if (!valid5) return;

    // 15m higher timeframe
    const lastHTF = state.candlesHTF.slice(-5);
    const closesHTF = lastHTF.map(c => c.close);
    const dirHTF = closesHTF[closesHTF.length - 1] > closesHTF[0] ? 'BUY' : 'SELL';

    // Check if both timeframes agree
    if (dir5 !== dirHTF) return;

    // EMA + RSI Filter
    if (state.filter) {
      const emaNow = state.ema[state.ema.length - 1];
      const emaHTFNow = state.emaHTF[state.emaHTF.length - 1];
      const rsiNow = state.rsi[state.rsi.length - 1];
      const rsiHTFNow = state.rsiHTF[state.rsiHTF.length - 1];
      
      if (!emaNow || !emaHTFNow || !rsiNow || !rsiHTFNow) return;
      
      if (dir5 === 'BUY' && (entry < emaNow || rsiNow < 50 || rsiHTFNow < 50)) return;
      if (dir5 === 'SELL' && (entry > emaNow || rsiNow > 50 || rsiHTFNow > 50)) return;
    }

    const bias = dir5;
    const sl = bias === 'BUY' ? low - range * 0.2 : high + range * 0.2;
    const tp = bias === 'BUY' ? high + range * 0.8 : low - range * 0.8;
    const confidence = (0.8 + Math.random() * 0.15).toFixed(2);
    
    const sig = {
      pair: state.pair.toUpperCase(),
      bias,
      entry,
      tp,
      sl,
      reason: `${bias === 'BUY' ? 'Bullish' : 'Bearish'} OB + Retrace + Multi-Timeframe${state.filter ? ' + EMA+RSI' : ''}`,
      confidence,
      time: new Date().toLocaleTimeString()
    };
    
    if (Date.now() - state.lastSignalTime > 60000) {
      state.lastSignalTime = Date.now();
      state.signals.push(sig);
      addSignal(sig);
    }
  } catch (error) {
    console.error('Error in SMC detection:', error);
  }
}

// --- Connect to Data Feeds ---
document.getElementById('connectFeed').onclick = async () => {
  try {
    const pair = document.getElementById('pairSelect').value;
    state.pair = pair;
    state.dataProvider = getDataProvider(pair);
    
    // Clear existing data
    state.candles = [];
    state.candlesHTF = [];
    
    // Update status
    document.getElementById('connectionStatus').textContent = 'Connecting...';
    document.getElementById('connectionStatus').className = 'connecting';
    
    // Load historical data first
    const historical5m = await loadHistoricalData(pair, 5, 100);
    const historical15m = await loadHistoricalData(pair, 15, 50);
    
    state.candles = historical5m;
    state.candlesHTF = historical15m;
    
    // Update chart with historical data
    if (state.candles.length > 0) {
      state.series.setData(state.candles);
      
      // Calculate and display EMA
      const closesAll = state.candles.map(x => x.close);
      state.ema = calcEMA(closesAll, 50);
      state.rsi = calcRSI(closesAll, 14);
      
      if (state.ema.length > 0) {
        const emaPlot = state.candles.slice(-state.ema.length).map((x, i) => ({
          time: x.time,
          value: state.ema[i]
        }));
        state.emaSeries.setData(emaPlot);
      }
    }
    
    // For demo purposes, we'll simulate live data for all pairs
    // In production, you would connect to actual WebSocket feeds
    
    // Simulate live data updates
    state.liveUpdateInterval = setInterval(() => {
      if (state.candles.length > 0) {
        const lastCandle = {...state.candles[state.candles.length - 1]};
        const change = (Math.random() - 0.5) * 0.01 * lastCandle.close;
        
        const newCandle = {
          time: lastCandle.time + 300, // 5 minutes later
          open: lastCandle.close,
          close: lastCandle.close + change,
          high: Math.max(lastCandle.close, lastCandle.close + change) + Math.random() * 0.005 * lastCandle.close,
          low: Math.min(lastCandle.close, lastCandle.close + change) - Math.random() * 0.005 * lastCandle.close,
          volume: 1000 + Math.random() * 5000
        };
        
        state.candles.push(newCandle);
        if (state.candles.length > 500) state.candles.shift();
        
        // Update 15m chart every 3 updates (15 minutes)
        if (state.candles.length % 3 === 0) {
          const lastHTF = {...state.candlesHTF[state.candlesHTF.length - 1]};
          const newHTFCandle = {
            time: lastHTF.time + 900, // 15 minutes later
            open: lastHTF.close,
            close: newCandle.close,
            high: Math.max(lastHTF.high, newCandle.high),
            low: Math.min(lastHTF.low, newCandle.low),
            volume: lastHTF.volume + newCandle.volume
          };
          state.candlesHTF.push(newHTFCandle);
          if (state.candlesHTF.length > 200) state.candlesHTF.shift();
          
          // Update HTF indicators
          const closesHTFAll = state.candlesHTF.map(x => x.close);
          state.emaHTF = calcEMA(closesHTFAll, 50);
          state.rsiHTF = calcRSI(closesHTFAll, 14);
        }
        
        // Update indicators
        const closesAll = state.candles.map(x => x.close);
        state.ema = calcEMA(closesAll, 50);
        state.rsi = calcRSI(closesAll, 14);
        
        if (state.ema.length > 0) {
          const emaPlot = state.candles.slice(-state.ema.length).map((x, i) => ({
            time: x.time,
            value: state.ema[i]
          }));
          state.emaSeries.setData(emaPlot);
        }
        
        state.series.setData(state.candles);
        
        if (state.auto) detectSMC();
      }
    }, 2000); // Update every 2 seconds for demo
    
    document.getElementById('connectionStatus').textContent = `Connected (${pair}) - ${state.dataProvider.toUpperCase()}`;
    document.getElementById('connectionStatus').className = 'connected';
    document.getElementById('feed5mStatus').textContent = '‚úÖ';
    document.getElementById('feed5mStatus').className = 'connected';
    document.getElementById('feed15mStatus').textContent = '‚úÖ';
    document.getElementById('feed15mStatus').className = 'connected';
    
  } catch (error) {
    console.error('Connection error:', error);
    document.getElementById('connectionStatus').textContent = 'Connection Failed';
    document.getElementById('connectionStatus').className = 'disconnected';
    alert(`Failed to connect: ${error.message}`);
  }
};

// --- Disconnect feeds ---
document.getElementById('disconnectFeed').onclick = () => {
  if (state.ws) {
    state.ws.close();
    state.ws = null;
  }
  if (state.wsHTF) {
    state.wsHTF.close();
    state.wsHTF = null;
  }
  if (state.liveUpdateInterval) {
    clearInterval(state.liveUpdateInterval);
    state.liveUpdateInterval = null;
  }
  
  document.getElementById('connectionStatus').textContent = 'Disconnected';
  document.getElementById('connectionStatus').className = 'disconnected';
  document.getElementById('feed5mStatus').textContent = '‚ùå';
  document.getElementById('feed5mStatus').className = 'disconnected';
  document.getElementById('feed15mStatus').textContent = '‚ùå';
  document.getElementById('feed15mStatus').className = 'disconnected';
};

// --- Manual generation ---
document.getElementById('generateSignal').onclick = detectSMC;

// --- Clear log ---
document.getElementById('clearSignals').onclick = () => {
  document.getElementById('signalLog').innerHTML = '';
  state.signals = [];
};

// --- Auto Mode toggle ---
document.getElementById('autoMode').onchange = (e) => state.auto = e.target.checked;
document.getElementById('filterMode').onchange = (e) => state.filter = e.target.checked;

// --- Auto-connect on page load for demo ---
window.addEventListener('load', () => {
  setTimeout(() => {
    document.getElementById('connectFeed').click();
  }, 1000);
});

// --- Cleanup on page unload ---
window.addEventListener('beforeunload', () => {
  if (state.ws) state.ws.close();
  if (state.wsHTF) state.wsHTF.close();
  if (state.liveUpdateInterval) clearInterval(state.liveUpdateInterval);
});
</script>
</body>
</html>
