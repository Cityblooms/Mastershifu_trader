        function analyze(sym) {
            const d = data.get(sym);
            if (!d || d.candles.length < CFG.PERIOD + 5) return;

            const prices = d.candles.map(c => c.c);
            const rsi = calcRSI(prices);
            if (rsi === null) return;

            const last = prices[prices.length - 1];
            const first = d.first || last;
            const change = ((last - first) / first * 100).toFixed(2);

            d.rsi = rsi;
            d.price = last;
            d.change = parseFloat(change);
            d.time = Date.now();

            const oldSig = signals.get(sym);
            let signal = 'neutral';

            if (rsi <= CFG.OVERSOLD) signal = 'buy';
            else if (rsi >= CFG.OVERBOUGHT) signal = 'sell';

            if (oldSig !== signal) {
                signals.set(sym, signal);
                const asset = ASSETS[sym];
                addLog(sym, signal, last);
                playSound(signal);
                debug(`${asset.name}: ${signal.toUpperCase()} signal (RSI: ${rsi.toFixed(1)})`);
            }
        }

        function updateCard(sym) {
            const d = data.get(sym);
            if (!d) return;

            const asset = ASSETS[sym];
            const card = document.getElementById(`card-${sym}`);
            const priceElem = document.getElementById(`price-${sym}`);
            const changeElem = document.getElementById(`change-${sym}`);
            const rsiElem = document.getElementById(`rsi-${sym}`);
            const barElem = document.getElementById(`bar-${sym}`);
            const timeElem = document.getElementById(`time-${sym}`);
            const sigElem = document.getElementById(`sig-${sym}`);
            const badge = card.querySelector('.badge');

            if (priceElem) {
                priceElem.textContent = d.price.toFixed(asset.dec);
                const changePct = ((d.price - (d.first || d.price)) / (d.first || d.price) * 100);
                const changeVal = changePct.toFixed(2);
                changeElem.textContent = `${changePct >= 0 ? '+' : ''}${changeVal}%`;
                changeElem.className = `change ${changePct >= 0 ? 'up' : 'down'}`;
            }

            if (rsiElem && d.rsi) {
                rsiElem.textContent = d.rsi.toFixed(1);
                
                let barClass = 'mid';
                if (d.rsi <= CFG.OVERSOLD) barClass = 'low';
                else if (d.rsi >= CFG.OVERBOUGHT) barClass = 'high';
                
                barElem.className = `rsi-bar ${barClass}`;
                barElem.style.width = `${Math.min(Math.max(d.rsi, 0), 100)}%`;
            }

            if (timeElem) {
                const now = new Date();
                timeElem.textContent = now.toLocaleTimeString('en-US', {
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                });
            }

            if (sigElem) {
                const sig = signals.get(sym) || 'neutral';
                sigElem.textContent = sig.toUpperCase();
                sigElem.style.color = sig === 'buy' ? 'var(--buy)' : 
                                     sig === 'sell' ? 'var(--sell)' : 'var(--neutral)';
            }

            const sig = signals.get(sym) || 'neutral';
            card.className = `card ${sig}`;
            
            if (badge) {
                badge.className = `badge ${sig}`;
                badge.textContent = sig === 'buy' ? 'BUY' : 
                                   sig === 'sell' ? 'SELL' : 'NEUTRAL';
            }

            updateChart(sym);
        }

        function updateChart(sym) {
            const d = data.get(sym);
            if (!d || d.candles.length < 5) return;

            const container = document.getElementById(`chart-${sym}`);
            if (!container) return;

            let canvas = container.querySelector('canvas');
            if (!canvas) {
                canvas = document.createElement('canvas');
                container.innerHTML = '';
                container.appendChild(canvas);
                
                const style = getComputedStyle(document.documentElement);
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
                
                canvas.style.width = '100%';
                canvas.style.height = '100%';
            }

            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const padding = 5;

            ctx.clearRect(0, 0, width, height);
            ctx.fillStyle = 'rgba(15, 23, 42, 0.5)';
            ctx.fillRect(0, 0, width, height);

            const recent = d.candles.slice(-30);
            if (recent.length < 2) return;

            let min = Infinity;
            let max = -Infinity;
            recent.forEach(c => {
                min = Math.min(min, c.l);
                max = Math.max(max, c.h);
            });

            const range = max - min;
            const chartHeight = height - padding * 2;
            const barWidth = (width - padding * 2) / recent.length * 0.7;

            recent.forEach((c, i) => {
                const x = padding + (i * (width - padding * 2) / recent.length);
                const openY = padding + chartHeight - ((c.o - min) / range * chartHeight);
                const closeY = padding + chartHeight - ((c.c - min) / range * chartHeight);
                const highY = padding + chartHeight - ((c.h - min) / range * chartHeight);
                const lowY = padding + chartHeight - ((c.l - min) / range * chartHeight);

                const isUp = c.c >= c.o;
                ctx.strokeStyle = isUp ? 'var(--buy)' : 'var(--sell)';
                ctx.fillStyle = isUp ? 'var(--buy)' : 'var(--sell)';

                ctx.beginPath();
                ctx.moveTo(x, highY);
                ctx.lineTo(x, lowY);
                ctx.stroke();

                const top = Math.min(openY, closeY);
                const barHeight = Math.abs(openY - closeY);
                
                if (barHeight > 0) {
                    ctx.fillRect(x - barWidth/2, top, barWidth, barHeight);
                } else {
                    ctx.beginPath();
                    ctx.moveTo(x - barWidth/2, top);
                    ctx.lineTo(x + barWidth/2, top);
                    ctx.stroke();
                }
            });
        }

        function addLog(sym, signal, price) {
            const asset = ASSETS[sym];
            const now = new Date();
            const time = now.toLocaleTimeString('en-US', {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });

            const log = {
                time,
                symbol: sym,
                name: asset.name,
                signal,
                price: price.toFixed(asset.dec)
            };

            logs.unshift(log);
            if (logs.length > 20) logs.pop();

            const logList = document.getElementById('logList');
            logList.innerHTML = '';
            
            logs.forEach(log => {
                const item = document.createElement('div');
                item.className = 'log-item';
                item.innerHTML = `
                    <div class="log-time">${log.time}</div>
                    <div class="log-sym">${log.name}</div>
                    <div class="log-sig ${log.signal}">${log.signal.toUpperCase()}</div>
                    <div class="log-price">${log.price}</div>
                `;
                logList.appendChild(item);
            });
        }

        function playSound(type) {
            try {
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);
                
                oscillator.frequency.value = type === 'buy' ? 880 : 440;
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                
                oscillator.start(audioCtx.currentTime);
                oscillator.stop(audioCtx.currentTime + 0.3);
            } catch (e) {
                // Audio not supported
            }
        }

        function updateTime() {
            const now = new Date();
            const timeStr = now.toLocaleTimeString('en-US', {
                hour12: false,
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
            document.getElementById('time').textContent = timeStr;
        }

        function init() {
            debug('KILER ZONE initialized');
            updateTime();
            setInterval(updateTime, 1000);

            document.getElementById('connectBtn').addEventListener('click', () => {
                const btn = document.getElementById('connectBtn');
                btn.disabled = true;
                btn.textContent = 'Connecting...';
                setTimeout(() => {
                    connect();
                    btn.disabled = false;
                    btn.textContent = 'Connect';
                }, 100);
            });

            document.getElementById('demoBtn').addEventListener('click', () => {
                startDemo();
            });

            document.getElementById('disconnectBtn').addEventListener('click', disconnect);

            document.getElementById('assetSelect').addEventListener('change', (e) => {
                currentAsset = e.target.value;
                if (mode !== 'disconnected') {
                    data.clear();
                    signals.clear();
                    loadAsset();
                }
            });

            document.getElementById('period').addEventListener('change', (e) => {
                CFG.PERIOD = parseInt(e.target.value) || 14;
                Object.keys(ASSETS).forEach(sym => {
                    if (data.has(sym)) analyze(sym);
                });
            });

            document.getElementById('oversold').addEventListener('change', (e) => {
                CFG.OVERSOLD = parseInt(e.target.value) || 30;
                Object.keys(ASSETS).forEach(sym => {
                    if (data.has(sym)) analyze(sym);
                });
            });

            document.getElementById('overbought').addEventListener('change', (e) => {
                CFG.OVERBOUGHT = parseInt(e.target.value) || 70;
                Object.keys(ASSETS).forEach(sym => {
                    if (data.has(sym)) analyze(sym);
                });
            });

            document.getElementById('token').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    document.getElementById('connectBtn').click();
                }
            });

            window.addEventListener('beforeunload', () => {
                disconnect();
            });
        }

        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
