<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Bekenet-style AI Signals ‚Äî Robust (Dark)</title>
<style>
:root{
  --bg:#071426; --panel:#0b1524; --muted:#93a5bf; --accent:#60a5fa; --good:#22c55e; --bad:#ef4444;
  --card: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
  --radius:12px;
}
html,body{height:100%;margin:0;background:linear-gradient(180deg,#021028 0%,#04142a 100%);font-family:Inter,system-ui,Roboto,Arial;color:#e6eef8}
.wrap{max-width:1150px;margin:12px auto;padding:12px}
.header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:12px}
.hleft{display:flex;flex-direction:column}
.hleft h1{margin:0;font-size:18px}
.controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
.card{background:var(--card);padding:12px;border-radius:var(--radius);box-shadow:0 8px 24px rgba(2,6,23,0.6);border:1px solid rgba(255,255,255,0.03)}
.row{display:flex;gap:12px}
.col{display:flex;flex-direction:column;gap:12px}
.param-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:8px}
.param-grid input, .param-grid select {
    background: transparent;
    border: 1px solid rgba(255, 255, 255, 0.06);
    padding: 6px;
    border-radius: 8px;
    color: #e6eef8;
}
.small{font-size:12px;color:var(--muted)}
.muted{color:var(--muted)}
.btn{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px;border-radius:8px;color:#e6eef8;cursor:pointer}
.canvasWrap{height:120px;border-radius:8px;overflow:hidden;background:linear-gradient(180deg,#04172b,#031827)}
.canvas{width:100%;height:100%;display:block}
.pairsList{display:flex;flex-direction:column;gap:8px}
.pairRow{display:flex;justify-content:space-between;align-items:center;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.02)}
.badge{padding:6px 10px;border-radius:999px;font-weight:700}
.buy{background:rgba(34,197,94,0.12);color:var(--good)}
.sell{background:rgba(239,68,68,0.12);color:var(--bad)}
.wait{background:rgba(148,163,184,0.06);color:var(--muted)}
.explain{font-size:12px;color:var(--muted);margin-top:6px}
.log{max-height:220px;overflow:auto;padding:8px;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);font-family:monospace;font-size:12px}
@media(max-width:980px){ .row{flex-direction:column} .param-grid{grid-template-columns:1fr} .canvasWrap{height:160px}}
</style>
</head>
<body>
<div class="wrap">
  <div class="header">
    <div class="hleft">
      <h1>Bekenet-style AI Signals ‚Äî Robust Dashboard</h1>
      <div class="small muted">Dark ‚Ä¢ State Persistent ‚Ä¢ Anti-Noise Trade Management</div>
    </div>
    <div class="controls card">
      <div class="small muted">Update every <b>30s</b></div>
      <div style="display:flex;gap:6px;align-items:center;margin-left:12px">
        <label class="small muted">AlphaVantage key (optional for Forex/XAU):</label>
        <input id="avKey" style="background:transparent;border:1px solid rgba(255,255,255,0.06);padding:6px;border-radius:8px;color:#e6eef8" placeholder="paste AV key if you have one"/>
      </div>
      <button id="refreshNow" class="btn">Refresh Now</button>
    </div>
  </div>

  <div class="row">
    <div style="flex:1" class="col">
      <div class="card">
        <div style="display:flex;justify-content:space-between;align-items:flex-start;gap:12px">
          <div style="min-width:220px">
            <div class="small muted">Pairs monitored (state persistent)</div>
            <div class="small muted">Add or remove pair symbols below.</div>
          </div>
          <div style="display:flex;gap:8px;align-items:center">
            <label class="small muted">Add Pair (ex: EUR/USD, XAU/USD, BTC/USD)</label>
            <input id="addPairInput" placeholder="EUR/USD" style="background:transparent;border:1px solid rgba(255,255,255,0.06);padding:6px;border-radius:8px;color:#e6eef8"/>
            <button id="addPairBtn" class="btn">Add</button>
          </div>
        </div>

        <div style="margin-top:12px" class="pairsList card" id="pairsContainer"></div>

        <div style="margin-top:10px;display:flex;gap:8px;align-items:center">
          <button id="clearPairs" class="btn">Reset Pairs</button>
          <div class="small muted">Defaults: EUR/USD, GBP/USD, USD/JPY, XAU/USD, BTC/USD</div>
        </div>
      </div>

      <div class="card" style="margin-top:12px">
        <div class="canvasWrap">
          <canvas id="miniChart" class="canvas"></canvas>
        </div>
        <div style="display:flex;justify-content:space-between;align-items:center;margin-top:8px">
          <div>
            <div class="small muted">Selected pair</div>
            <div id="selectedPair" style="font-weight:700">‚Äî</div>
            <div id="selectedPrice" class="small muted">Price: ‚Äî</div>
          </div>
          <div>
            <div class="small muted">Entry mode</div>
            <select id="entryMode" style="background:transparent;border:1px solid rgba(255,255,255,0.06);padding:6px;border-radius:8px;color:#e6eef8">
              <option value="smart">Smart (EMA+RSI+S/R)</option>
              <option value="aggressive">Aggressive (EMA crossover)</option>
              <option value="conservative">Conservative (RSI+S/R)</option>
            </select>
          </div>
          <div>
            <div class="small muted">TF (for candle building)</div>
            <select id="tf" style="background:transparent;border:1px solid rgba(255,255,255,0.06);padding:6px;border-radius:8px;color:#e6eef8">
              <option value="1m">1m</option><option value="5m">5m</option><option value="15m">15m</option>
            </select>
          </div>
        </div>

        <div class="param-grid" style="margin-top:12px">
          <div><label class="small muted">EMA fast</label><input id="emaFast" type="number" value="50" /></div>
          <div><label class="small muted">EMA slow</label><input id="emaSlow" type="number" value="200" /></div>
          <div><label class="small muted">RSI period</label><input id="rsiPeriod" type="number" value="14" /></div>
          <div><label class="small muted">RSI buy level</label><input id="rsiBuy" type="number" value="35" /></div>
          <div><label class="small muted">RSI sell level</label><input id="rsiSell" type="number" value="65" /></div>
          <div><label class="small muted">S/R lookback bars</label><input id="srLookback" type="number" value="200" /></div>
        </div>
        
        <div style="margin-top: 10px; display: flex; justify-content: flex-end;">
            <button id="loadDefaults" class="btn">Load Default Settings</button>
        </div>

        <div class="explain" id="globalExplain">Signals appear only on closed candles. No repaint. ATR-based SL/TP advisory added to Exit Hints.</div>
      </div>
    </div>

    <div style="width:380px" class="col">
      <div class="card">
        <div style="font-weight:700">Trade Management Panel</div>
        <div id="exitHints" class="explain">No open trades or selected pair.</div>
      </div>

      <div class="card" style="margin-top:12px">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div style="font-weight:700">Live Signals</div>
          <div class="small muted">Updated every 30s</div>
        </div>
        <div id="liveList" style="margin-top:8px;display:flex;flex-direction:column;gap:8px"></div>
      </div>

      <div class="card" style="margin-top:12px">
        <div style="font-weight:700">Log</div>
        <div id="log" class="log" style="margin-top:8px">Ready.</div>
      </div>
    </div>
  </div>
</div>

<script>
/*
  Bekenet-style AI Signal ‚Äî Single-file
  - Robust (No Repaint, State Persistent)
  - Non-Noisy (Trade Management Panel)
*/

// ---------- Utilities ----------
const $ = id => document.getElementById(id);
const sleep = ms => new Promise(r => setTimeout(r, ms));
function nowISO(){ return new Date().toISOString(); }
function log(msg){ $('log').innerText = nowISO() + ' ‚Ä¢ ' + msg + '\n' + $('log').innerText; }

// Local Storage Keys
const PAIRS_KEY = 'bekenet_pairs';
const STATE_KEY = 'bekenet_state';
const PARAMS_KEY = 'bekenet_params';

// ---------- Default pairs & State ----------
const DEFAULT_PAIRS = ['EUR/USD','GBP/USD','USD/JPY','XAU/USD','BTC/USD'];
const DEFAULT_PARAMS = {
    emaFast: 50, emaSlow: 200, rsiPeriod: 14, rsiBuy: 35, rsiSell: 65, srLookback: 200,
    entryMode: 'smart', tf: '1m'
};
let pairs = [...DEFAULT_PAIRS];
const state = {}; // per-pair state and candles


// ---------- Persistence Functions üíæ ----------
function saveParams() {
    const params = {
        emaFast: +$('emaFast').value, emaSlow: +$('emaSlow').value, rsiPeriod: +$('rsiPeriod').value,
        rsiBuy: +$('rsiBuy').value, rsiSell: +$('rsiSell').value, srLookback: +$('srLookback').value,
        entryMode: $('entryMode').value, tf: $('tf').value
    };
    localStorage.setItem(PARAMS_KEY, JSON.stringify(params));
}

function loadParams() {
    const savedParams = localStorage.getItem(PARAMS_KEY);
    const params = savedParams ? JSON.parse(savedParams) : DEFAULT_PARAMS;

    $('emaFast').value = params.emaFast;
    $('emaSlow').value = params.emaSlow;
    $('rsiPeriod').value = params.rsiPeriod;
    $('rsiBuy').value = params.rsiBuy;
    $('rsiSell').value = params.rsiSell;
    $('srLookback').value = params.srLookback;
    $('entryMode').value = params.entryMode;
    $('tf').value = params.tf;
}

// Save the current state to localStorage
function saveState() {
  localStorage.setItem(PAIRS_KEY, JSON.stringify(pairs));
  const serializableState = {};
  for(const p in state){
    serializableState[p] = {
      lastSignal: state[p].lastSignal,
      openPosition: state[p].openPosition,
      lastEvaluated: state[p].lastEvaluated
    };
  }
  localStorage.setItem(STATE_KEY, JSON.stringify(serializableState));
  saveParams();
}

// Load state from localStorage
function loadState() {
  loadParams();

  const savedPairs = localStorage.getItem(PAIRS_KEY);
  if(savedPairs) {
    try {
      pairs = JSON.parse(savedPairs);
      log('Loaded pairs from storage.');
    } catch (e) { log('Error loading pairs, resetting to defaults.'); pairs = [...DEFAULT_PAIRS]; }
  }

  const savedState = localStorage.getItem(STATE_KEY);
  if(savedState) {
    try {
      const loadedState = JSON.parse(savedState);
      for (const p of pairs) {
        state[p] = state[p] || {candles:[], lastSignal:null, openPosition:null, lastEvaluated:0};
        if(loadedState[p]) {
          state[p].lastSignal = loadedState[p].lastSignal;
          state[p].openPosition = loadedState[p].openPosition;
          state[p].lastEvaluated = loadedState[p].lastEvaluated;
        }
      }
      log('Loaded trade state from storage.');
    } catch (e) { log('Error loading trade state, resetting.'); }
  }
}
// ---------------------------------------------


// ---------- Config & UI elements ----------
const refreshInterval = 30 * 1000; // 30s
const miniCanvas = $('miniChart');
const miniCtx = miniCanvas.getContext('2d');
function resizeCanvas(){ miniCanvas.width = miniCanvas.clientWidth * devicePixelRatio; miniCanvas.height = miniCanvas.clientHeight * devicePixelRatio; miniCtx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0); }
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

$('addPairBtn').addEventListener('click', ()=>{ const v=$('addPairInput').value.trim().toUpperCase(); if(v){ addPair(v); $('addPairInput').value=''; }});
$('clearPairs').addEventListener('click', ()=>{ 
  pairs = [...DEFAULT_PAIRS]; 
  initPairs(); 
  saveState(); 
});
$('refreshNow').addEventListener('click', fetchAllOnce);

// Event listeners for saving parameter changes
['emaFast', 'emaSlow', 'rsiPeriod', 'rsiBuy', 'rsiSell', 'srLookback', 'entryMode', 'tf'].forEach(id => {
    $(id).addEventListener('change', saveParams);
});

// Load Defaults button handler
$('loadDefaults').addEventListener('click', () => {
    localStorage.removeItem(PARAMS_KEY);
    loadParams();
    log('Parameters reset to default values.');
});


// initialize UI
function renderPairsUI(){
  const container = $('pairsContainer'); container.innerHTML='';
  pairs.forEach(p=>{
    const div = document.createElement('div'); div.className='pairRow';
    const left = document.createElement('div'); left.innerHTML = `<div style="font-weight:700">${p}</div><div class="small muted" id="p-${p}-info">‚Äî</div>`;
    const right = document.createElement('div');
    const badge = document.createElement('span'); badge.id = `badge-${p}`; badge.className='badge wait'; badge.innerText='WAIT';
    const btnSel = document.createElement('button'); btnSel.className='btn'; btnSel.innerText='Select'; btnSel.onclick=()=> selectPair(p);
    const btnRem = document.createElement('button'); btnRem.className='btn'; btnRem.innerText='Remove'; btnRem.onclick=()=> removePair(p);
    right.appendChild(badge); right.appendChild(btnSel); right.appendChild(btnRem);
    div.appendChild(left); div.appendChild(right);
    container.appendChild(div);
  });
}
function addPair(p){ 
  if(!pairs.includes(p)){ 
    pairs.push(p); 
    initPairs(); 
    log('Added pair '+p);
    saveState(); 
  } 
}
function removePair(p){ 
  pairs = pairs.filter(x=>x!==p); 
  initPairs(); 
  log('Removed pair '+p); 
  saveState(); 
}
function selectPair(p){ $('selectedPair').innerText = p; renderMini(p); }
// initial fill
function initPairs(){ 
  renderPairsUI(); 
  pairs.forEach(p=>{ 
    state[p] = state[p] || {candles:[], lastSignal:null, openPosition:null, lastEvaluated:0}; 
  }); 
  renderLiveList(); 
  saveState(); 
}


// ---------- Indicator helpers (same as original) ----------
function ema(values, period){
  const out = []; const k = 2/(period+1);
  let prev = null;
  for(let i=0;i<values.length;i++){
    if(i===0){ prev = values[0]; out.push(prev); continue; }
    if(prev===null) prev = values[i];
    prev = (values[i]-prev)*k + prev;
    out.push(prev);
  }
  return out;
}
function sma(values, period){
  const out=[]; let sum=0;
  for(let i=0;i<values.length;i++){
    sum += values[i];
    if(i>=period) sum -= values[i-period];
    out.push(i>=period-1 ? sum/period : null);
  }
  return out;
}
function rsi(values, period){
  const out=[]; let gains=0, losses=0;
  for(let i=1;i<values.length;i++){
    const d = values[i]-values[i-1];
    if(i<=period){ if(d>0) gains += d; else losses += Math.abs(Math.min(d,0)); if(i===period){ let ag=gains/period, al=losses/period; let rs=ag/(al||1e-9); out[period] = 100 - (100/(1+rs)); var prevGain=ag, prevLoss=al; } else out.push(null); }
    else{ const gain = Math.max(values[i]-values[i-1],0); const loss = Math.max(values[i-1]-values[i],0); prevGain=(prevGain*(period-1)+gain)/period; prevLoss=(prevLoss*(period-1)+loss)/period; const rs = prevGain/(prevLoss||1e-9); out.push(100 - (100/(1+rs))); }
  }
  while(out.length < values.length) out.unshift(null);
  return out;
}
function atr(highs,lows,closes,period){
  const trs = [];
  for(let i=0;i<highs.length;i++){
    if(i===0) trs.push(highs[i]-lows[i]);
    else trs.push(Math.max(highs[i]-lows[i], Math.abs(highs[i]-closes[i-1]), Math.abs(lows[i]-closes[i-1])));
  }
  return sma(trs, period);
}
// detect S/R as local peaks/troughs (simple)
function detectSR(candles, lookback){
  const sup=[], res=[];
  const n=candles.length;
  for(let i=2;i<n-2;i++){
    if(candles[i].l < candles[i-1].l && candles[i].l < candles[i+1].l) sup.push(candles[i].l);
    if(candles[i].h > candles[i-1].h && candles[i].h > candles[i+1].h) res.push(candles[i].h);
  }
  // cluster
  const cluster = (arr,tol=0.0025)=>{ arr.sort((a,b)=>a-b); const out=[]; arr.forEach(v=>{ if(out.length===0) out.push(v); else{ const last=out[out.length-1]; if(Math.abs(last-v)/last < tol) out[out.length-1]=(last+v)/2; else out.push(v);} }); return out; };
  return {supports: cluster(sup), resistances: cluster(res)};
}

// ---------- Data fetchers (same as original) ----------
async function fetchBinanceKlines(symbol, interval, limit=200){
  const url = `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
  const r = await fetch(url);
  if(!r.ok) throw new Error('Binance fetch failed');
  const j = await r.json();
  return j.map(x=>({t:x[0],o:+x[1],h:+x[2],l:+x[3],c:+x[4],v:+x[5]}));
}
async function fetchAlphaVantageFX(pair, interval, apikey){
  const [from,to] = pair.split('/').map(x=>x.trim());
  const url = `https://www.alphavantage.co/query?function=FX_INTRADAY&from_symbol=${from}&to_symbol=${to}&interval=${interval}&outputsize=full&apikey=${apikey}`;
  const r = await fetch(url);
  if(!r.ok) throw new Error('AlphaV fetch failed: '+r.status);
  const j = await r.json();
  const key = Object.keys(j).find(k=>k.toLowerCase().includes('time series'));
  if(!key) throw new Error('AlphaV unexpected: ' + JSON.stringify(j));
  const series = j[key];
  const out = [];
  const keys = Object.keys(series);
  for(let i = Math.max(0, keys.length-500); i<keys.length; i++){
    const t = keys[i];
    const v = series[t];
    out.push({t: new Date(t+' UTC').getTime(), o:+v['1. open'], h:+v['2. high'], l:+v['3. low'], c:+v['4. close'], v:+(v['5. volume']||0)});
  }
  return out;
}
async function fetchForexQuote(pair){
  const [a,b] = pair.split('/').map(x=>x.trim());
  const url = `https://api.exchangerate.host/latest?base=${encodeURIComponent(a)}&symbols=${encodeURIComponent(b)}`;
  const r = await fetch(url);
  if(!r.ok) throw new Error('Forex quote fetch failed');
  const j = await r.json();
  const rate = j.rates && j.rates[b] ? j.rates[b] : null;
  if(!rate) throw new Error('No rate returned for '+pair);
  return {t: Date.now(), price: +rate};
}

// ---------- Candle-builder (same as original) ----------
function timeframeToMs(tf){
  if(tf==='1m') return 60*1000;
  if(tf==='5m') return 5*60*1000;
  if(tf==='15m') return 15*60*1000;
  return 60*1000;
}
function addQuoteToCandle(store, quote, tf){
  const ms = timeframeToMs(tf);
  const t0 = Math.floor(quote.t / ms) * ms;
  let last = store.candles.length ? store.candles[store.candles.length-1] : null;
  if(!last || last.t !== t0){
    const newc = {t:t0,o:quote.price,h:quote.price,l:quote.price,c:quote.price,v:quote.volume||0};
    store.candles.push(newc);
    if(store.candles.length > 500) store.candles.shift();
  } else {
    last.h = Math.max(last.h, quote.price);
    last.l = Math.min(last.l, quote.price);
    last.c = quote.price;
    last.v = (last.v || 0) + (quote.volume||0);
  }
}

// ---------- Decision engine (same as original) ----------
function evaluateOnClosedCandle(candles, params, mode){
  if(candles.length < Math.max(params.emaSlow, params.rsiPeriod, 10)) return {side:'WAIT', reason:['insufficient data']};
  const closes = candles.map(c=>c.c);
  const highs = candles.map(c=>c.h);
  const lows = candles.map(c=>c.l);
  const emaF = ema(closes, params.emaFast);
  const emaS = ema(closes, params.emaSlow);
  const rsiArr = rsi(closes, params.rsiPeriod);
  const atrArr = atr(highs,lows,closes, 14); // ATR period fixed at 14 for consistency
  const i = candles.length - 1;
  const price = closes[i];
  const emaFast = emaF[i], emaSlow = emaS[i], rsiVal = rsiArr[i], atrVal = atrArr[i];
  const sr = detectSR(candles, params.srLookback);
  const nearSupport = sr.supports.some(s => Math.abs((price - s)/price) < 0.0035);
  const nearResist  = sr.resistances.some(s => Math.abs((price - s)/price) < 0.0035);
  const look = Math.min(60, candles.length-1); // fibLookback fixed at 60
  const slice = candles.slice(candles.length-1-look);
  let maxH = -Infinity, minL = Infinity;
  slice.forEach(x=>{ if(x.h>maxH) maxH=x.h; if(x.l<minL) minL=x.l; });
  const fib38 = maxH - (maxH-minL)*0.382;
  const fib61 = maxH - (maxH-minL)*0.618;
  const nearFib = (price >= Math.min(fib38,fib61) && price <= Math.max(fib38,fib61));
  const momLen = 8;
  const mom = (closes[i] - closes[Math.max(0,i-momLen)]) / Math.max(1e-9, closes[Math.max(0,i-momLen)]);
  const bullish = emaFast > emaSlow;
  const bearish = emaFast < emaSlow;

  let side='WAIT', reasons=[];
  if(mode==='aggressive'){
    if(bullish){ side='BUY'; reasons.push('EMA up'); }
    if(bearish){ side='SELL'; reasons.push('EMA down'); }
  } else if(mode==='conservative'){
    if(rsiVal !== null && rsiVal < params.rsiBuy && nearSupport && mom > 0){ side='BUY'; reasons.push('RSI low + support + momentum'); }
    if(rsiVal !== null && rsiVal > params.rsiSell && nearResist && mom < 0){ side='SELL'; reasons.push('RSI high + resist + momentum'); }
  } else { // smart
    if(bullish && rsiVal !== null && rsiVal < params.rsiBuy && (nearFib || nearSupport) && mom > 0){ side='BUY'; reasons.push('EMA+RSI+Fib/SR+mom'); }
    else if(bearish && rsiVal !== null && rsiVal > params.rsiSell && (nearFib || nearResist) && mom < 0){ side='SELL'; reasons.push('EMA+RSI+Fib/SR+mom'); }
    else {
      if(bullish && (nearSupport || nearFib)) { side='BUY'; reasons.push('EMA up + partial confirm'); }
      if(bearish && (nearResist || nearFib)) { side='SELL'; reasons.push('EMA down + partial confirm'); }
    }
  }
  if(side==='BUY' && rsiVal !== null && rsiVal > 92){ side='WAIT'; reasons.push('RSI extreme high - pause'); }
  if(side==='SELL' && rsiVal !== null && rsiVal < 8){ side='WAIT'; reasons.push('RSI extreme low - pause'); }

  return {side, reasons, context:{price, emaFast, emaSlow, rsiVal, atrVal, nearSupport, nearResist, nearFib, mom, fib38, fib61}, sr};
}

// ---------- UI rendering helpers ----------
function renderExitHints(pair) {
    const hintsEl = $('exitHints');
    const st = state[pair];
    if (!st || !st.lastSignal || !st.lastSignal.context) {
        hintsEl.innerHTML = `<div class="explain">Select a pair and wait for the first data fetch.</div>`;
        return;
    }
    
    const ctx = st.lastSignal.context;
    const atr = ctx.atrVal ? ctx.atrVal.toFixed(6) : '‚Äî';
    
    let html = `
        <div style="font-weight:700; margin-bottom: 4px;">Market Context for ${pair} (${$('tf').value})</div>
        <div class="small muted">
            ‚Ä¢ Current **ATR (14)**: **${atr}**<br>
            ‚Ä¢ **RSI**: ${ctx.rsiVal ? ctx.rsiVal.toFixed(2) : '‚Äî'}<br>
            ‚Ä¢ **S/R Status**: Support Near (${ctx.nearSupport ? 'Yes' : 'No'}), Resistance Near (${ctx.nearResist ? 'Yes' : 'No'})
        </div>
    `;

    if (st.openPosition) {
        const pos = st.openPosition;
        html += `<div style="margin-top: 10px; padding: 8px; border: 1px dashed rgba(96, 165, 250, 0.4); border-radius: 8px;">
            <div style="color: ${pos.side === 'BUY' ? 'var(--good)' : 'var(--bad)'}; font-weight: 700; display:flex; justify-content: space-between;">
                <span>ACTIVE ADVICE: ${pos.side} @ ${pos.entry.toFixed(6)}</span>
                <span>${st.exitHint ? '‚ö†Ô∏è HINT' : 'üü¢ OPEN'}</span>
            </div>
            <div class="small muted" style="margin-top:4px;">
                ‚Ä¢ **Suggested SL**: ${pos.sl ? pos.sl.toFixed(6) : '‚Äî'} (1.5x ATR)<br>
                ‚Ä¢ **Suggested TP**: ${pos.tp ? pos.tp.toFixed(6) : '‚Äî'} (2.5x ATR)
            </div>
            ${st.exitHint ? `<div style="color:var(--bad); margin-top: 6px;">**EXIT HINT**: ${st.exitHint}</div>` : ''}
        </div>`;
    } else {
        html += `<div style="margin-top: 10px;" class="small muted">No active trade to manage on this pair.</div>`;
    }
    
    hintsEl.innerHTML = html;
}

function updateLiveList(){
  const container = $('liveList'); container.innerHTML='';
  pairs.forEach(p=>{
    const st = state[p] || {candles:[], lastSignal:null, openPosition:null, lastEvaluated:0};
    const badge = document.createElement('div');
    badge.className = 'pairRow';
    
    // Left side: Pair and Price Info
    const left = document.createElement('div'); 
    let infoText = 'Price: ‚Äî';
    if(st.candles.length > 0) infoText = 'Price: ' + st.candles[st.candles.length-1].c.toFixed(6);

    // Right side: Signal Badge and Action Text
    const right = document.createElement('div'); right.style.display='flex'; right.style.gap='8px'; right.style.alignItems='center';
    const sig = document.createElement('span'); sig.id='sig-'+p; sig.className='badge wait'; sig.innerText='WAIT';
    const hint = document.createElement('div'); hint.className='small muted'; hint.id='hint-'+p; hint.innerText='';

    if(st.lastSignal){
      const side = st.lastSignal.side;
      sig.className='badge ' + side.toLowerCase(); sig.innerText=side;
      
      if(st.openPosition){
        // Only show open status on the main list (less noisy)
        hint.innerText = `${st.openPosition.side} open @ ${st.openPosition.entry.toFixed(6)}`;
      } else {
        // Show signal reason if no open position
        hint.innerText = st.lastSignal.reasons ? st.lastSignal.reasons.join('; ') : '';
      }
    }
    
    left.innerHTML = `<div style="font-weight:700">${p}</div><div class="small muted" id="info-${p}">${infoText}</div>`;

    right.appendChild(sig); right.appendChild(hint);
    badge.appendChild(left); badge.appendChild(right);
    container.appendChild(badge);
  });
}

// render mini chart for selected pair
function renderMini(pair){
  const st = state[pair]; 
  const currentPair = $('selectedPair').innerText;
  
  // Update chart only if the selected pair matches the one being rendered
  if(pair === currentPair){
    if(!st || !st.candles || st.candles.length===0) { 
        miniCtx.clearRect(0,0,miniCanvas.width,miniCanvas.height); 
        $('selectedPrice').innerText='Price: ‚Äî'; 
        renderExitHints(pair);
        return; 
    }
    const candles = st.candles.slice(-120);
    const w = miniCanvas.clientWidth, h = miniCanvas.clientHeight;
    miniCtx.clearRect(0,0,miniCanvas.width,miniCanvas.height);
    let min=Infinity,max=-Infinity; candles.forEach(c=>{ min=Math.min(min,c.l); max=Math.max(max,c.h); });
    const pad = (max-min)*0.06; min-=pad; max+=pad;
    const N=candles.length; const cw = Math.max(2, (w / N) * 0.8); const gap=(w - cw*N)/Math.max(1,N-1);
    for(let i=0;i<N;i++){
      const c=candles[i]; const x = i*(cw+gap)+4;
      const yOpen = h - ((c.o-min)/(max-min)*h), yClose = h - ((c.c-min)/(max-min)*h), yHigh = h - ((c.h-min)/(max-min)*h), yLow = h - ((c.l-min)/(max-min)*h);
      miniCtx.beginPath(); miniCtx.moveTo(x+cw/2,yHigh); miniCtx.lineTo(x+cw/2,yLow); miniCtx.lineWidth=1; miniCtx.strokeStyle='rgba(255,255,255,0.05)'; miniCtx.stroke();
      const bullish = c.c>=c.o; miniCtx.fillStyle = bullish ? 'rgba(34,197,94,0.9)' : 'rgba(239,68,68,0.9)';
      miniCtx.fillRect(x, Math.min(yOpen,yClose), cw, Math.max(1, Math.abs(yOpen-yClose)));
    }
    const last = candles[candles.length-1]; $('selectedPrice').innerText = 'Price: ' + last.c.toFixed(6);
  }
  
  // Always update Exit Hints panel for the pair requested
  renderExitHints(pair);
}

// ---------- Signal lifecycle and exit logic ----------
function processClosedCandleFor(pair){
  const st = state[pair]; if(!st) return;
  const params = {
    emaFast: +$('emaFast').value,
    emaSlow: +$('emaSlow').value,
    rsiPeriod: +$('rsiPeriod').value,
    rsiBuy: +$('rsiBuy').value,
    rsiSell: +$('rsiSell').value,
    atrPeriod: 14,
    fibLookback: 60,
    srLookback: +$('srLookback').value,
    momLen: 8
  };
  const mode = $('entryMode').value;
  const lastCandle = st.candles[st.candles.length-1];
  if(!lastCandle) return;
  if(st.lastEvaluated === lastCandle.t) return; 
  
  const result = evaluateOnClosedCandle(st.candles, params, mode);
  st.lastSignal = result;
  st.lastEvaluated = lastCandle.t;

  if(st.openPosition){
    const open = st.openPosition;
    const ctx = result.context;
    let exitReason = null;
    if(result.side && result.side !== 'WAIT' && result.side !== open.side){
      exitReason = 'Opposite signal triggered on closed candle';
    }
    if(!exitReason && ((open.side==='BUY' && ctx.emaFast < ctx.emaSlow) || (open.side==='SELL' && ctx.emaFast > ctx.emaSlow))){
      exitReason = 'EMA crossover reversed';
    }
    if(!exitReason){
      if(open.side==='BUY' && ctx.rsiVal && ctx.rsiVal > 80) exitReason = 'RSI extreme high';
      if(open.side==='SELL' && ctx.rsiVal && ctx.rsiVal < 20) exitReason = 'RSI extreme low';
    }
    if(!exitReason){
      if(open.side==='BUY' && ctx.nearResist && ctx.price > ctx.fib61) exitReason = 'Price reached nearby resistance';
      if(open.side==='SELL' && ctx.nearSupport && ctx.price < ctx.fib38) exitReason = 'Price reached nearby support';
    }

    if(exitReason){
      st.exitHint = exitReason;
      log(`Exit hint for ${pair}: ${exitReason}`);
    } else {
      st.exitHint = null;
    }

  } else {
    if(result.side === 'BUY' || result.side === 'SELL'){
      if(result.reasons && result.reasons.length > 0){
        const entry = result.context.price;
        const side = result.side;
        const atrVal = result.context.atrVal;
        
        // ATR-based SL/TP (Advisory)
        const atr_multiplier = 0.0001; // Scale ATR if needed, typically 1.5x SL, 2.5x TP
        const sl_dist = atrVal * 1.5;
        const tp_dist = atrVal * 2.5;
        const sl = (side === 'BUY') ? entry - sl_dist : entry + sl_dist;
        const tp = (side === 'BUY') ? entry + tp_dist : entry - tp_dist;

        st.openPosition = {
            side, entry, entryIndex: st.candles.length-1, 
            reason: result.reasons.join('; '), t: Date.now(),
            atrVal: atrVal, sl: sl, tp: tp
        };
        log(`Opened advisory ${side} on ${pair} at ${entry.toFixed(6)} ‚Äî reasons: ${result.reasons.join('; ')}`);
      }
    }
  }
  
  updateLiveList();
  const selected = $('selectedPair').innerText;
  if(selected === pair) renderMini(pair);
  
  saveState(); 
}

// ---------- Main fetch loop (same as original) ----------
async function fetchForPair(pair){
  try {
    const tf = $('tf').value;
    const ms = timeframeToMs(tf);
    const isCrypto = pair.replace('/','').toUpperCase().endsWith('USDT') || pair.toUpperCase().includes('BTC') || pair.toUpperCase().includes('ETH');
    const avKey = $('avKey').value.trim();

    state[pair] = state[pair] || {candles:[], lastSignal:null, openPosition:null, lastEvaluated:0};

    if(isCrypto){
      let bsymbol = pair.replace('/','').toUpperCase();
      if(!bsymbol.endsWith('USDT')) {
        if(bsymbol.endsWith('USD')) bsymbol = bsymbol.replace('USD','USDT');
        else bsymbol = bsymbol + 'USDT';
      }
      const interval = tf; 
      const klines = await fetchBinanceKlines(bsymbol, interval, 500);
      state[pair].candles = klines.map(k=>({t:k.t,o:k.o,h:k.h,l:k.l,c:k.c,v:k.v}));
    } else {
      if(avKey){
        const avInterval = tf === '1m' ? '1min' : tf === '5m' ? '5min' : '15min';
        try {
          const av = await fetchAlphaVantageFX(pair, avInterval, avKey);
          state[pair].candles = av.map(x=>({t:x.t,o:x.o,h:x.h,l:x.l,c:x.c,v:x.v}));
        } catch(e){
          log('AlphaV fetch failed for '+pair+': '+e.message+' ‚Äî falling back to live quotes');
        }
      }
      if(!state[pair].candles || state[pair].candles.length < 50){
        const quote = await fetchForexQuote(pair);
        addQuoteToCandle(state[pair], {t: quote.t, price: quote.price}, tf);
      }
    }
    
    const now = Date.now();
    const ms_tf = timeframeToMs(tf);
    const lastCandle = state[pair].candles[state[pair].candles.length-1];
    if(!lastCandle){ log('No candles for '+pair); return; }
    
    if(lastCandle.t + ms_tf <= now){
      processClosedCandleFor(pair);
    } else {
      if(state[pair].candles.length>0){
        const last = state[pair].candles[state[pair].candles.length-1];
        const infoEl = document.getElementById('p-'+pair+'-info');
        if(infoEl) infoEl.innerText = 'Price: '+last.c.toFixed(6)+' (intra)';
      }
    }

  } catch(err){
    log('Fetch error for '+pair+': '+err.message);
    console.error(err);
  }
}

async function fetchAllOnce(){
  const copy = [...pairs];
  for(let i=0;i<copy.length;i++){
    const p = copy[i];
    await fetchForPair(p);
    updateLiveList();
    await sleep(300);
  }
  const selected = $('selectedPair').innerText || pairs[0];
  if(selected) renderMini(selected);
}

// continuous loop
let running = true;
async function runLoop(){
  while(running){
    try {
      await fetchAllOnce();
    } catch(e){ console.error(e); }
    await sleep(refreshInterval);
  }
}

// ---------- Initialization ----------
(function init(){
  loadState();

  initPairs();
  const initialPair = pairs.length > 0 ? pairs[0] : 'EUR/USD';
  selectPair(initialPair); 
  $('selectedPair').innerText = initialPair;
  
  runLoop();
  log('Started main loop ‚Äî updates every 30s');
})();

</script>
</body>
</html>
