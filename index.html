<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>AI SMC Multi-Timeframe Dashboard ‚Äî Deriv Ready</title>

<!-- Lightweight Charts -->
<script src="https://unpkg.com/lightweight-charts@4.0.1/dist/lightweight-charts.standalone.production.js"></script>

<style>
  /* --- Theme & Layout (kept close to your original) --- */
  body{font-family:'Poppins',sans-serif;background:#0b0b10;color:#eee;margin:0;padding:0;display:flex;flex-direction:column;align-items:center}
  header{background:#111827;width:100%;padding:10px 20px;text-align:center;font-size:1.2em;box-shadow:0 2px 5px rgba(0,0,0,.4)}
  .controls{margin:12px 0;display:flex;gap:10px;flex-wrap:wrap;justify-content:center}
  select,button,input[type=checkbox],input[type=password]{background:#1f2937;color:#fff;border:none;padding:10px 12px;border-radius:10px;cursor:pointer;font-weight:600;transition:.25s}
  button:hover,select:hover,input[type=password]:hover{background:#4f46e5}
  #chart{width:95%;height:420px;margin-top:10px;border-radius:10px}
  #signalLog{width:95%;margin-top:16px;background:#1e1e2e;border-radius:10px;padding:10px;max-height:260px;overflow-y:auto}
  .signal-card{background:#26263a;margin:5px 0;padding:10px;border-left:5px solid #6366f1;border-radius:8px;font-size:.9em}
  .buy{border-left-color:#22c55e}.sell{border-left-color:#ef4444}
  label{display:flex;align-items:center;gap:8px;font-size:.9em}
  .status-container{display:flex;gap:15px;margin:10px 0;flex-wrap:wrap;justify-content:center}
  .status-item{padding:8px 12px;background:#1f2937;border-radius:8px;font-size:0.9em}
  .connected{color:#22c55e}.disconnected{color:#ef4444}.connecting{color:#f59e0b}
  .loading{display:none;color:#f59e0b}
  .time-display{font-size:0.9em;color:#888;margin:6px 0}
  .conditions{background:#1a1a2e;padding:10px;border-radius:8px;margin:10px 0;font-size:0.85em;width:95%}
  .condition-met{color:#22c55e}
  .condition-failed{color:#ef4444}
  .small{font-size:0.85em;color:#bbb}
  input[type=password]{width:220px}
</style>
</head>
<body>
<header>AI SMC Multi-Timeframe Dashboard ‚Äî Deriv Ready</header>

<div class="controls">
  <select id="pairSelect" title="Locked pair list (non-tamper)">
    <optgroup label="Crypto Futures / Cross (kept for convenience)">
      <option value="BTCUSD">BTCUSD</option>
      <option value="ETHUSD">ETHUSD</option>
    </optgroup>
    <optgroup label="Forex">
      <option value="frxEURUSD">EUR/USD</option>
      <option value="frxGBPUSD">GBP/USD</option>
      <option value="frxUSDJPY">USD/JPY</option>
      <option value="frxAUDUSD">AUD/USD</option>
    </optgroup>
    <optgroup label="Indices">
      <option value="IDXSP">US 500 (S&P)</option>
      <option value="IDXNAS">US Tech 100</option>
      <option value="IDXUKX">UK 100</option>
    </optgroup>
    <optgroup label="Deriv Synthetics">
      <option value="R_10">R_10</option>
      <option value="R_25">R_25</option>
      <option value="R_50">R_50</option>
      <option value="R_100">R_100</option>
      <option value="VRTT">Volatility 75</option>
    </optgroup>
  </select>

  <button id="connectReal">üîê Connect (Real)</button>
  <button id="connectDemo">üß™ Connect (Demo)</button>
  <button id="disconnectFeed">üîå Disconnect</button>
  <button id="generateSignal">‚ö° Manual SMC Signal</button>

  <label><input type="checkbox" id="autoMode" checked> Auto Signal Mode</label>
  <label><input type="checkbox" id="filterMode" checked> EMA + RSI Filter</label>
  <button id="clearSignals">üßπ Clear</button>
</div>

<div class="controls" style="margin-top:0;">
  <!-- Paste your Deriv token here (optional). If empty -> demo mode. -->
  <input type="password" id="derivToken" placeholder="Paste Deriv API token (optional)"/>
  <div class="small">App ID (test): <span id="appId" class="small">1089</span></div>
</div>

<div class="status-container">
  <div class="status-item">Status: <span id="connectionStatus" class="disconnected">Disconnected</span></div>
  <div class="status-item">5m Feed: <span id="feed5mStatus" class="disconnected">‚ùå</span></div>
  <div class="status-item">15m Feed: <span id="feed15mStatus" class="disconnected">‚ùå</span></div>
  <div class="status-item loading" id="loadingIndicator">üîÑ Loading historical data...</div>
</div>

<div class="time-display">
  Last Update: <span id="lastUpdateTime">-</span> |
  Chart Time: <span id="chartTime">-</span> |
  Next Candle: <span id="nextCandleTime">-</span>
</div>

<div class="conditions">
  <strong>Signal Conditions:</strong>
  <div id="conditionStatus">Waiting for data...</div>
</div>

<div id="chart"></div>
<h3>üìä Signals <span id="signalCount">(0)</span></h3>
<div id="signalLog"></div>

<script>
/* ============================
   AI SMC Dashboard ‚Äî DERIV READY
   - Uses Deriv WebSocket if token provided
   - Falls back to Demo simulation otherwise
   - Non-tamper pair list validated against allowedPairs
   ============================ */

/* ---------- State ---------- */
const state = {
  ws: null,
  connectedReal: false,
  demoMode: true,
  pair: document.getElementById('pairSelect').value,
  app_id: 1089, // test app_id (replace with your own app_id for production)
  candles: [],       // 5m candles
  candlesHTF: [],    // 15m candles
  ema: [],
  emaHTF: [],
  rsi: [],
  rsiHTF: [],
  signals: [],
  series: null,
  emaSeries: null,
  lastSignalTime: 0,
  liveUpdateInterval: null
};

/* ---------- Allowed pair list (locked) ---------- */
const allowedPairs = [
  // crypto/others (kept for convenience)
  "BTCUSD","ETHUSD",
  // forex (Deriv uses specific prefixes like frx)
  "frxEURUSD","frxGBPUSD","frxUSDJPY","frxAUDUSD",
  // indices (Deriv naming - ensure matches Deriv active symbols)
  "IDXSP","IDXNAS","IDXUKX",
  // Deriv synthetics
  "R_10","R_25","R_50","R_100","VRTT"
];

/* Utility: validate pair selection (prevents tamper) */
function validatePair(p) {
  if (!allowedPairs.includes(p)) {
    alert("Invalid pair selection. Operation cancelled.");
    throw new Error("Invalid pair selection: " + p);
  }
}

/* ---------- Chart Setup (LightweightCharts) ---------- */
const chart = LightweightCharts.createChart(document.getElementById('chart'), {
  layout: { background: { color: "#0b0b10" }, textColor: "#DDD" },
  grid: { vertLines: { color: "#1e1e2e" }, horzLines: { color: "#1e1e2e" } },
  timeScale: { timeVisible: true, secondsVisible: false, rightOffset: 12, barSpacing: 6 },
});
state.series = chart.addCandlestickSeries();
state.emaSeries = chart.addLineSeries({ lineWidth: 2, color: '#f59e0b' });

/* ---------- Indicator Functions ---------- */
function calcEMA(values, period) {
  if (!values || values.length < period) return [];
  const k = 2 / (period + 1);
  const ema = [values[0]];
  for (let i = 1; i < values.length; i++) {
    ema.push(values[i] * k + ema[i - 1] * (1 - k));
  }
  return ema;
}

function calcRSI(values, period = 14) {
  if (!values || values.length <= period) return [];
  let gains = 0, losses = 0;
  for (let i = 1; i <= period; i++) {
    const diff = values[i] - values[i - 1];
    gains += Math.max(diff, 0);
    losses += Math.max(-diff, 0);
  }
  let avgGain = gains / period, avgLoss = losses / period;
  const rsi = new Array(period).fill(null);
  for (let i = period + 1; i < values.length; i++) {
    const diff = values[i] - values[i - 1];
    const gain = Math.max(diff, 0), loss = Math.max(-diff, 0);
    avgGain = (avgGain * (period - 1) + gain) / period;
    avgLoss = (avgLoss * (period - 1) + loss) / period;
    if (avgLoss === 0) rsi.push(100);
    else {
      const rs = avgGain / avgLoss;
      rsi.push(100 - (100 / (1 + rs)));
    }
  }
  return rsi;
}

/* ---------- UI Updaters ---------- */
function updateTimeDisplay() {
  const now = new Date();
  document.getElementById('lastUpdateTime').textContent = now.toLocaleTimeString();
  if (state.candles.length) {
    const last = state.candles[state.candles.length - 1];
    document.getElementById('chartTime').textContent = new Date(last.time * 1000).toLocaleTimeString();
    document.getElementById('nextCandleTime').textContent = new Date((last.time + 300) * 1000).toLocaleTimeString();
  }
}

function updateConditionStatus(conds) {
  const el = document.getElementById('conditionStatus');
  el.innerHTML = conds.map(c => {
    return `<div class="${c.met ? 'condition-met' : 'condition-failed'}">${c.met ? '‚úÖ' : '‚ùå'} ${c.name}</div>`;
  }).join('');
}

/* ---------- Signal UI ---------- */
function addSignal(sig) {
  state.signals.unshift(sig);
  const div = document.createElement('div');
  div.className = `signal-card ${sig.bias === 'BUY' ? 'buy' : 'sell'}`;
  div.innerHTML = `<b>${sig.pair}</b> | <b>${sig.bias}</b> | Entry ${sig.entry.toFixed(5)} TP ${sig.tp.toFixed(5)} SL ${sig.sl.toFixed(5)}<br>
    Reason: ${sig.reason}<br>Conf: ${sig.confidence} | ${sig.time}`;
  document.getElementById('signalLog').prepend(div);
  document.getElementById('signalCount').textContent = `(${state.signals.length})`;
  // marker
  const lastTime = state.candles[state.candles.length - 1]?.time;
  if (lastTime) {
    state.series.setMarkers([{
      time: lastTime,
      position: sig.bias === 'BUY' ? 'belowBar' : 'aboveBar',
      color: sig.bias === 'BUY' ? '#22c55e' : '#ef4444',
      shape: sig.bias === 'BUY' ? 'arrowUp' : 'arrowDown',
      text: sig.bias
    }]);
  }
}

/* ---------- SMC Detection (kept similar to your logic) ---------- */
function detectSMC() {
  try {
    // basic data check
    if (state.candles.length < 35 || state.candlesHTF.length < 15) {
      updateConditionStatus([{ name: 'Minimum data (35 x 5m, 15 x 15m)', met: false }]);
      return;
    }
    const conditions = [];
    let allOk = true;

    const last20 = state.candles.slice(-20);
    const currentClose = last20[last20.length - 1].close;
    const recentHigh = Math.max(...last20.slice(-10).map(c=>c.high));
    const recentLow = Math.min(...last20.slice(-10).map(c=>c.low));
    const volatility = (recentHigh - recentLow) / recentLow;
    const hasVol = volatility > 0.005;
    conditions.push({ name: `Minimum volatility (0.5%): ${(volatility*100).toFixed(2)}%`, met: hasVol });
    if (!hasVol) allOk = false;

    // Market structure (simple swing detection)
    const highs = last20.map(c=>c.high), lows = last20.map(c=>c.low);
    const swingHighs = [], swingLows = [];
    for (let i = 2; i < highs.length-2; i++){
      if (highs[i]>highs[i-1] && highs[i]>highs[i-2] && highs[i]>highs[i+1] && highs[i]>highs[i+2]) swingHighs.push(highs[i]);
      if (lows[i]<lows[i-1] && lows[i]<lows[i-2] && lows[i]<lows[i+1] && lows[i]<lows[i+2]) swingLows.push(lows[i]);
    }
    const hasStructure = swingHighs.length>=2 && swingLows.length>=2;
    conditions.push({ name: 'Market structure (min 2 swings)', met: hasStructure });
    if (!hasStructure) allOk = false;

    // Multi-timeframe alignment
    const lastHTF = state.candlesHTF.slice(-5);
    const dirHTF = lastHTF[lastHTF.length-1].close > lastHTF[0].close ? 'BUY' : 'SELL';
    const recent5m = last20.slice(-5);
    const dir5m = recent5m[recent5m.length-1].close > recent5m[0].close ? 'BUY' : 'SELL';
    const aligned = dir5m === dirHTF;
    conditions.push({ name: `Multi-timeframe (5m: ${dir5m}, 15m: ${dirHTF})`, met: aligned });
    if (!aligned) allOk = false;

    // EMA + RSI filter (if enabled)
    let filterOk = true;
    if (document.getElementById('filterMode').checked) {
      const emaNow = state.ema[state.ema.length-1];
      const emaHTFNow = state.emaHTF[state.emaHTF.length-1];
      const rsiNow = state.rsi[state.rsi.length-1];
      const rsiHTFNow = state.rsiHTF[state.rsiHTF.length-1];
      if (!emaNow || !emaHTFNow || !rsiNow || !rsiHTFNow) filterOk = false;
      else {
        const buyEma = dir5m==='BUY' ? (currentClose>emaNow && currentClose>emaHTFNow) : (currentClose<emaNow && currentClose<emaHTFNow);
        const buyRsi = dir5m==='BUY' ? (rsiNow>50 && rsiNow<80 && rsiHTFNow>50 && rsiHTFNow<80) : (rsiNow<50 && rsiNow>20 && rsiHTFNow<50 && rsiHTFNow>20);
        filterOk = buyEma && buyRsi;
        conditions.push({ name: `EMA alignment`, met: buyEma });
        conditions.push({ name: `RSI filter (5m:${rsiNow?.toFixed(1) || 'n/a'} 15m:${rsiHTFNow?.toFixed(1) || 'n/a'})`, met: buyRsi });
      }
      if (!filterOk) allOk = false;
    }

    // Retracement requirement
    const range = recentHigh - recentLow;
    const retracementLevel = (currentClose - recentLow) / (range || 1);
    const validRetrace = retracementLevel >= 0.4 && retracementLevel <= 0.6;
    conditions.push({ name: `Retracement (${(retracementLevel*100).toFixed(1)}%)`, met: validRetrace });
    if (!validRetrace) allOk = false;

    // Breakout confirmation
    const previousHigh = Math.max(...state.candles.slice(-20, -5).map(c=>c.high));
    const previousLow  = Math.min(...state.candles.slice(-20, -5).map(c=>c.low));
    let breakout = false, bias = null, reason = '';
    if (dir5m==='BUY' && last20[last20.length-1].high > previousHigh) { breakout=true; bias='BUY'; reason='Break of structure'; }
    if (dir5m==='SELL' && last20[last20.length-1].low < previousLow)  { breakout=true; bias='SELL'; reason='Break of structure'; }
    conditions.push({ name: 'Breakout confirmation', met: breakout });
    if (!breakout) allOk = false;

    updateConditionStatus(conditions);

    if (allOk && bias) {
      const sl = bias==='BUY' ? recentLow - range*0.1 : recentHigh + range*0.1;
      const tp = bias==='BUY' ? currentClose + range*1.2 : currentClose - range*1.2;
      let confidence = 0.7;
      if (volatility>0.01) confidence+=0.1;
      if (aligned) confidence+=0.1;
      if (validRetrace && retracementLevel>=0.45 && retracementLevel<=0.55) confidence+=0.1;
      const sig = {
        pair: state.pair,
        bias,
        entry: currentClose,
        tp: parseFloat(tp.toFixed(5)),
        sl: parseFloat(sl.toFixed(5)),
        reason: `${reason} ${document.getElementById('filterMode').checked ? '+ EMA+RSI' : ''}`,
        confidence: Math.min(confidence,0.95).toFixed(2),
        time: new Date().toLocaleTimeString()
      };
      if (Date.now() - state.lastSignalTime > 120000) { // cooldown 2 minutes
        state.lastSignalTime = Date.now();
        addSignal(sig);
        console.log('Signal generated', sig);
      } else console.log('Cooldown active');
    } else {
      // no signal
    }

  } catch (err) {
    console.error('SMC detection error', err);
    updateConditionStatus([{ name: 'Error in detection logic', met: false }]);
  }
}

/* ---------- DEMO / SIMULATION (fallback) ---------- */
function getCurrentCandleTime(timeframe = 5) {
  const now = Math.floor(Date.now() / 1000);
  return now - (now % (timeframe * 60));
}
function generateHistorical(pair, timeframe=5, limit=100) {
  // realistic seeded generator
  const candles = [];
  const base = pair.toLowerCase().includes('btc') ? 50000 : (pair.toLowerCase().includes('frx') ? 1.2 : 100);
  let t = getCurrentCandleTime(timeframe) - limit * timeframe * 60;
  let last = base;
  let trend = Math.random() > 0.5 ? 1 : -1;
  for (let i=0;i<limit;i++){
    if (Math.random()<0.04) trend*=-1;
    const vol = pair.toLowerCase().includes('frx') ? 0.002 : 0.01;
    const change = (Math.random()-0.5+trend*0.2)*vol*last;
    const open = last;
    const close = open + change;
    const high = Math.max(open,close) + Math.random()*vol*last*0.3;
    const low  = Math.min(open,close) - Math.random()*vol*last*0.3;
    candles.push({ time: t, open: +open.toFixed(5), high: +high.toFixed(5), low: +low.toFixed(5), close: +close.toFixed(5), volume: 1000+Math.random()*4000 });
    last = close; t += timeframe*60;
  }
  return candles;
}

function startDemoLive() {
  // Clear any existing interval
  if (state.liveUpdateInterval) clearInterval(state.liveUpdateInterval);

  // generate base historical
  const p = state.pair;
  state.candles = generateHistorical(p, 5, 120);
  state.candlesHTF = generateHistorical(p, 15, 80);
  // compute indicators
  updateIndicatorsAndChart();

  // run per-second simulation that appends/updates candle when new 5m alignment occurs
  state.liveUpdateInterval = setInterval(() => {
    if (!state.candles.length) return;
    const nowAligned = getCurrentCandleTime(5);
    const last = state.candles[state.candles.length-1];
    if (nowAligned > last.time) {
      // push a new candle
      const vol = state.pair.toLowerCase().includes('frx') ? 0.002 : 0.01;
      const change = (Math.random()-0.5)*vol*last.close;
      const newC = {
        time: nowAligned,
        open: last.close,
        close: +(last.close + change).toFixed(5),
        high: +Math.max(last.close, last.close + change + Math.random()*vol*last.close*0.3).toFixed(5),
        low: +Math.min(last.close, last.close + change - Math.random()*vol*last.close*0.3).toFixed(5),
        volume: 1000 + Math.random()*4000
      };
      state.candles.push(newC);
      if (state.candles.length>300) state.candles.shift();
      // update HTF every 3 x 5min candles
      if ((state.candles.length)%3 === 0) {
        const lastHTF = state.candlesHTF[state.candlesHTF.length-1] || { close: state.candles[state.candles.length-4].close, high:newC.high, low:newC.low };
        const recent5 = state.candles.slice(-3);
        const htf = {
          time: getCurrentCandleTime(15),
          open: lastHTF.close,
          close: newC.close,
          high: Math.max(lastHTF.high || -Infinity, ...recent5.map(c=>c.high)),
          low: Math.min(lastHTF.low || Infinity, ...recent5.map(c=>c.low)),
          volume: recent5.reduce((s,c)=>s+c.volume,0)
        };
        state.candlesHTF.push(htf);
        if (state.candlesHTF.length>150) state.candlesHTF.shift();
      }
      updateIndicatorsAndChart();
      if (document.getElementById('autoMode').checked) detectSMC();
    } else {
      // update last candle (while current bar forming)
      const volatility = state.pair.toLowerCase().includes('frx') ? 0.002 : 0.01;
      const updateChange = (Math.random()-0.5)*volatility*last.close*0.2;
      last.close = +(last.close + updateChange).toFixed(5);
      last.high = Math.max(last.high,last.close);
      last.low = Math.min(last.low,last.close);
      updateIndicatorsAndChart(false); // update but no heavy ops
    }
  }, 1000);
}

/* ---------- Helpers to update indicators and chart ---------- */
function updateIndicatorsAndChart(setMarkers=true) {
  const closes = state.candles.map(c=>c.close);
  const closesHTF = state.candlesHTF.map(c=>c.close);
  state.ema = calcEMA(closes, 50);
  state.rsi = calcRSI(closes, 14);
  state.emaHTF = calcEMA(closesHTF, 50);
  state.rsiHTF = calcRSI(closesHTF, 14);

  // Update candle series
  state.series.setData(state.candles);

  // EMA plot
  if (state.ema.length>0) {
    const emaPlot = state.candles.slice(-state.ema.length).map((c,i)=>({ time: c.time, value: state.ema[i]}));
    state.emaSeries.setData(emaPlot);
  }

  updateTimeDisplay();
}

/* ---------- DERIV WebSocket Integration ---------- */
/* Important: Deriv uses a WebSocket endpoint: wss://ws.binaryws.com/websockets/v3?app_id=<APP_ID>
   For real production usage, register an app on Deriv and replace app_id and use your token.
   This script will:
     - open WS
     - authorize with { authorize: 'TOKEN' } if token supplied
     - request ticks_history in candles format for 5m (granularity 300) and 15m (granularity 900)
     - parse responses (best-effort) and maintain the 5m & 15m arrays
*/
function connectDerivLive(token) {
  // validate
  const p = state.pair;
  validatePair(p);

  const app_id = state.app_id;
  const endpoint = `wss://ws.binaryws.com/websockets/v3?app_id=${app_id}`;
  try {
    state.ws = new WebSocket(endpoint);
  } catch (err) {
    console.error('WebSocket creation failed', err);
    startDemoLive();
    return;
  }

  document.getElementById('loadingIndicator').style.display = 'inline-block';
  state.connectedReal = false;

  state.ws.onopen = () => {
    console.log('Connected to Deriv WS (endpoint):', endpoint);
    // authorize if token provided
    if (token) {
      const authMsg = { authorize: token };
      state.ws.send(JSON.stringify(authMsg));
    } else {
      // if no token, we still try to request market data that is public (some endpoints don't require auth)
      console.log('No token provided ‚Äî limited access expected. Falling back to demo for continuous updates.');
      // close and fallback to demo for stability
      state.ws.close();
      startDemoLive();
    }
  };

  state.ws.onmessage = (evt) => {
    try {
      const raw = JSON.parse(evt.data);
      // Handle authorize responses
      if (raw.authorize) {
        if (raw.authorize && raw.authorize.error) {
          console.warn('Authorize error', raw.authorize.error);
          // fallback to demo
          state.ws.close();
          startDemoLive();
        } else {
          console.log('Authorized successfully:', raw.authorize);
          state.connectedReal = true;
          document.getElementById('connectionStatus').textContent = `Connected (Deriv)`;
          document.getElementById('connectionStatus').className = 'connected';
          // subscribe/request history for 5m and 15m
          requestCandlesViaHistory(state.pair, 300, '5m');  // granularity 300 sec = 5m
          requestCandlesViaHistory(state.pair, 900, '15m'); // granularity 900 sec = 15m
        }
      }

      // Deriv returns responses keyed by the request type ‚Äî we'll attempt to capture ticks_history/candles
      if (raw.history || raw.candles || raw.tick) {
        // Some example response bodies may include "history": { "candles": [...] } or similar.
        // We'll attempt to parse both possibilities.
        if (raw.history && raw.history.candles) {
          // direct candles array (time in epoch seconds maybe)
          const arr = raw.history.candles;
          // map to consistent candle format
          const mapped = arr.map(c=>{
            // Deriv candle might be { time: 161..., open: '1.2345' ... } or { epoch:..., open:... }
            const timeSec = c.epoch || c.time || Math.floor(Date.now()/1000);
            return {
              time: Math.floor(timeSec),
              open: parseFloat(c.open),
              high: parseFloat(c.high),
              low: parseFloat(c.low),
              close: parseFloat(c.close),
              volume: c.volume || 0
            };
          });
          // Determine which granularity based on length/time gaps ‚Äî we keep both arrays from requests
          // If it's a 5m set (most recent timeframe) update state.candles; else update HTF
          if (mapped.length > 0 && (mapped[1]?.time - mapped[0]?.time) === 300) {
            state.candles = mapped;
            document.getElementById('feed5mStatus').textContent = '‚úÖ';
            document.getElementById('feed5mStatus').className = 'connected';
          } else if (mapped.length > 0 && (mapped[1]?.time - mapped[0]?.time) === 900) {
            state.candlesHTF = mapped;
            document.getElementById('feed15mStatus').textContent = '‚úÖ';
            document.getElementById('feed15mStatus').className = 'connected';
          }
          updateIndicatorsAndChart();
          document.getElementById('loadingIndicator').style.display = 'none';
        } else if (raw.candles) {
          // try raw.candles
        } else if (raw.tick) {
          // For real-time tick stream; could aggregate ticks into candles if desired
          // Example: raw.tick.quote contains latest price
          // TODO: implement tick->candle aggregation if delivering ticks only
        }
      }

      // Some APIs return "error" fields ‚Äî manage fallback
      if (raw.error) {
        console.warn('Deriv WS error:', raw.error);
      }

    } catch (err) {
      console.error('Error parsing WS message', err, evt.data);
    }
  };

  state.ws.onclose = (ev) => {
    console.warn('Deriv WS closed', ev);
    document.getElementById('connectionStatus').textContent = 'Disconnected';
    document.getElementById('connectionStatus').className = 'disconnected';
    // If we were connected in real mode and it closed unexpectedly -> fallback to demo
    if (!state.connectedReal) {
      startDemoLive();
    } else {
      // On unexpected disconnect, try to reconnect after short delay
      setTimeout(() => {
        const tok = document.getElementById('derivToken').value.trim();
        if (tok) connectDerivLive(tok);
        else startDemoLive();
      }, 3000);
    }
  };

  state.ws.onerror = (err) => {
    console.error('WebSocket error', err);
    // fallback to demo
    if (state.ws) state.ws.close();
    startDemoLive();
  };

  // Helper: request candles using ticks_history in candles format (best-effort)
  function requestCandlesViaHistory(symbol, granularity, label) {
    const req = {
      ticks_history: symbol,
      // Deriv expects end: "latest" and possibly count or start
      end: "latest",
      // request enough candles (count)
      count: 200,
      // style or format: some docs use "candles" or "ticks"
      style: "candles",
      // granularity in seconds (e.g., 300 for 5min)
      granularity: granularity
    };
    state.ws.send(JSON.stringify(req));
  }
}

/* ---------- UI Button Handlers ---------- */
document.getElementById('connectReal').onclick = () => {
  try {
    const p = document.getElementById('pairSelect').value;
    validatePair(p);
    state.pair = p;
    // clear old state & UI
    state.candles = []; state.candlesHTF = []; state.signals = [];
    document.getElementById('signalLog').innerHTML = ''; document.getElementById('signalCount').textContent='(0)';
    document.getElementById('connectionStatus').textContent = 'Connecting...'; document.getElementById('connectionStatus').className = 'connecting';
    document.getElementById('loadingIndicator').style.display = 'inline-block';
    // if existing demo interval, clear it
    if (state.liveUpdateInterval) { clearInterval(state.liveUpdateInterval); state.liveUpdateInterval = null; }
    const token = document.getElementById('derivToken').value.trim();
    if (!token) {
      if (!confirm('No token provided. Click OK to start demo mode instead.')) return;
      // start demo
      state.demoMode = true;
      startDemoLive();
      document.getElementById('connectionStatus').textContent = 'Demo Mode';
      document.getElementById('connectionStatus').className = 'connecting';
      return;
    }
    state.demoMode = false;
    connectDerivLive(token);
  } catch (err) {
    console.error(err);
  }
};

document.getElementById('connectDemo').onclick = () => {
  try {
    const p = document.getElementById('pairSelect').value;
    validatePair(p);
    state.pair = p;
    state.demoMode = true;
    if (state.ws) { try { state.ws.close(); } catch(e){} state.ws=null; }
    document.getElementById('connectionStatus').textContent = 'Demo Mode (Running)'; document.getElementById('connectionStatus').className = 'connected';
    startDemoLive();
  } catch (err) { console.error(err); }
};

document.getElementById('disconnectFeed').onclick = () => {
  try {
    if (state.ws) { state.ws.close(); state.ws = null; }
    if (state.liveUpdateInterval) { clearInterval(state.liveUpdateInterval); state.liveUpdateInterval=null; }
    document.getElementById('connectionStatus').textContent = 'Disconnected'; document.getElementById('connectionStatus').className = 'disconnected';
    document.getElementById('feed5mStatus').textContent='‚ùå'; document.getElementById('feed5mStatus').className='disconnected';
    document.getElementById('feed15mStatus').textContent='‚ùå'; document.getElementById('feed15mStatus').className='disconnected';
  } catch (err) { console.error(err); }
};

document.getElementById('generateSignal').onclick = () => {
  detectSMC();
};

document.getElementById('clearSignals').onclick = () => {
  state.signals = []; document.getElementById('signalLog').innerHTML=''; document.getElementById('signalCount').textContent='(0)';
};

document.getElementById('autoMode').onchange = (e)=>{ console.log('Auto mode', e.target.checked); };
document.getElementById('filterMode').onchange = (e)=>{ console.log('Filter mode', e.target.checked); };

/* Auto-start demo mode after short delay so the page is interactive without token */
window.addEventListener('load', () => {
  setTimeout(()=> {
    // start demo for the currently selected pair automatically
    try {
      const p = document.getElementById('pairSelect').value;
      validatePair(p);
      state.pair = p;
      startDemoLive();
      document.getElementById('connectionStatus').textContent = 'Demo Mode (Auto)'; document.getElementById('connectionStatus').className = 'connecting';
    } catch (err) { console.error(err); }
  }, 600);
});

/* Cleanup */
window.addEventListener('beforeunload', ()=> {
  if (state.liveUpdateInterval) clearInterval(state.liveUpdateInterval);
  if (state.ws) try{ state.ws.close(); } catch(e){}
});

</script>
</body>
</html>
